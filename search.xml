<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="/2024/01/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/5.Docker/"/>
      <url>/2024/01/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/5.Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>背景：</strong></p><p>一个项目从开发到上线，从操作环境，到运行环境，再到应用配置，需要关心很多东西，特别是各种版本的迭代之后，不同版本环境的兼容问题，对于开发和运维都是不小的考验。</p><p>Docker对此给出了一个标准化的解决方案：安装的时候，把原始环境一模一样地复制过来，极大地减少了不同机器不能运行的问题。</p><p>Docker镜像的设计，打破了过去「程序即应用」的观念。透过镜像(images)可以将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</p><p><strong>理念：</strong></p><p>Docker是基于Go语言实现的云开源项目，目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</p><p>过往技术：虚拟机（virtual machine），是带环境安装的一种解决方案。</p><p>缺点：资源占用多；冗余步骤多；启动慢</p><p>为了解决弥补以往的缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><blockquote><p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</p></blockquote><p>Docker 和传统虚拟化方式的差别：</p><ol><li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟，更加轻便。</li><li>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</li></ol><p><strong>官网：</strong><a href="https://www.docker.com/">Docker</a></p><p><strong>仓库：</strong><a href="https://hub.docker.com/">Docker Hub</a></p><blockquote><p>因为 Red Hat 即将停止CentOS系列的维护，所以官网不再推荐。未来可尝试 Debian</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用CentOS 7，要求系统为64位、系统内核版本为 3.10 以上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印当前系统相关信息</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看内核版本</span></span><br><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><ol><li>安装gcc环境（为了意外）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><ol start="2"><li>卸载旧版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载</span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除所有映像、容器和卷</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载旧版本以及相关的依赖项</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><ol start="3"><li>安装软件包（提供实用程序）并设置存储库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">官网</span></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推荐</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ol start="4"><li>安装</li></ol><ul><li>最新版</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装当前系统支持的最新版本</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul><li>指定版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前系统支持版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装指定版本</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ol start="5"><li>校验</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><ol start="6"><li>配置加速镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有就创建</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加配置</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启服务</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>配置开机启动：<code>systemctl enable docker</code></p></blockquote><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>run 命令的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20240113211513.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20240113211513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e27d6910ca291baf9f382e063766cbc0.png"></p><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><p>容器，是一个运行时环境，也就是Logo上的集装箱。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20240113211518.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20240113211518.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="be989fd0ab3c05b2f35e5b5caa24eef7.png"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看指令手册</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看本机镜像</span></span><br><span class="line">docker images [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>-a：列出本地所有的镜像（含中间映像层）</li><li>-q：只显示镜像ID</li><li>–digests：显示镜像的摘要信息</li><li>–no-trunc：显示完整的镜像信息</li></ul><p>数据说明：</p><ol><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ol><blockquote><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果不指定版本标签，默认使用latest，示例：ubuntu:latest</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找远程镜像</span></span><br><span class="line">docker search [OPTIONS] 镜像名字</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>–no-trunc：显示完整的镜像描述</li><li>-s：列出收藏数不小于指定值的镜像</li><li>–automated：只列出 automated build类型的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull 镜像名字[:TAG]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi 镜像名字[:TAG]/ID</span><br></pre></td></tr></table></figure><ul><li>-f：强制删除</li></ul><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除多个</span></span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除全部</span></span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure></blockquote><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建并启动容器</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动交互式容器,在容器内执行/bin/bash命令</span></span><br><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>–name&#x3D;”容器新名字”: 为容器指定一个名称；</li><li>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</li><li>-i：以交互模式运行容器，通常与 -t 同时使用；</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>-P: 随机端口映射；</li><li>-p: 指定端口映射，有以下四种格式：<ul><li>ip:hostPort:containerPort</li><li>ip::containerPort</li><li>hostPort:containerPort</li><li>containerPort</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出当前所有正在运行的容器</span></span><br><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-a :列出当前所有正在运行的容器+历史上运行过的</li><li>-l :显示最近创建的容器</li><li>-n：显示最近n个创建的容器</li><li>-q :静默模式，只显示容器编号</li><li>–no-trunc :不截断输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出并关闭容器</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">容器不停止退出(快捷键)</span></span><br><span class="line">ctrl+P+Q</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动/重启/停止/强制停止容器</span></span><br><span class="line">docker start/restart/stop/kill 容器ID或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除已停止的容器</span></span><br><span class="line">docker rm 容器ID</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除多个容器</span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h4 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h4><p>后台启动需要守护进程，不是所有的服务都可以后台启动的。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后台启动</span></span><br><span class="line">docker run -d centos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看运行容器</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>会发现容器已经退出，因为没有前台服务，导致服务启动后会因为无事可做而被杀掉，而像redis、mysql等服务，由于存在守护进程，所以可以后台启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器日志</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-t 是加入时间戳；-f 跟随最新的日志打印；--<span class="built_in">tail</span> 数字，显示最后多少条</span></span><br><span class="line">docker logs -f -t --tail 条数 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内运行的进程</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内部细节</span></span><br><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新进入后台容器</span></span><br><span class="line">docker exec -it 容器ID</span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><blockquote><p>attach 直接进入容器启动命令的终端，不会启动新的进程</p><p>exec 是在容器中打开新的终端，并且可以启动新的进程</p><p>即使用attach命令时输入exit容易导致容器关闭。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从容器内拷贝文件到主机上</span></span><br><span class="line">docker cp  容器ID:容器内路径 目的主机路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">导出容器内容（备份）</span></span><br><span class="line">docker export 容器ID &gt; 文件名.tar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">导入tar包中的内容为一个镜像并创建新的文件系统</span></span><br><span class="line">docker import 文件名.tar - 镜像名:TAG</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:8080 -v 主机目录:容器目录 --privileged=true 容器名</span><br></pre></td></tr></table></figure><p><code>-v</code>：目录挂载，将容器中的目录挂载到主机目录中（共享文件夹）；可以实现将容器内的数据保存进主机中</p><blockquote><p>默认容器具有读写权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:8080 -v 主机目录:容器目录:ro --privileged=true 容器名</span><br></pre></td></tr></table></figure><p>其中ro表示readonly</p></blockquote><p><code>--privileged=true</code>：在centos7中目录挂载被视为不安全行为，所以需要使用此命令来解决权限问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看数据卷是否挂载成功</span></span><br><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">继承其它容器的卷规则</span></span><br><span class="line">docker run -it --privileged=true --volumes-from 容器id --name 容器名 镜像名</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容。</p><p>**联合文件系统(UnionFS)**：联合文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一个提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><p>UnionFS 是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像（类似花卷）。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p>注意：Docker镜像层都是只读的，容器层（最外暴露的一层）时可写的</p><h3 id="制作与提交"><a href="#制作与提交" class="headerlink" title="制作与提交"></a>制作与提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提交容器副本使之成为一个新的镜像</span></span><br><span class="line">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名:标签名</span><br></pre></td></tr></table></figure><p>上面的操作只是将镜像提交到了本地，可以通过<code>docker images</code>查看</p><p>我们可以将提交的本地镜像提交到阿里云个人仓库：<a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">开放云原生应用-云原生（Cloud Native）</a></p><p>登录后搜索 容器镜像服务，然后选择个人根据提示创建命名空间及仓库（选择本地仓库），然后根据操作指南进行提交即可，以下记录一下相关命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录</span></span><br><span class="line">docker login --username=lemonpuer registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从Registry中拉取镜像</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lemonpuer/lemon:[镜像版本号]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重命名镜像</span></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/lemonpuer/lemon:[镜像版本号]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送镜像</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/lemonpuer/lemon:[镜像版本号]</span><br></pre></td></tr></table></figure><blockquote><p>登录密码为开通服务是设置的秘密</p></blockquote><h4 id="私有库"><a href="#私有库" class="headerlink" title="私有库"></a>私有库</h4><p>Docker Registry：Docker官方提供的工具，用于构建私有镜像仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">docker run -d -p 5000:5000  -v /registry/myregistry/:/tmp/registry --privileged=true registry</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看库中镜像</span></span><br><span class="line">curl -XGET http://ip:5000/v2/_catalo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认不支持http，修改配置文件</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://dockerhub.azk8s.cn&quot;,</span><br><span class="line">        &quot;https://hub-mirror.c.163.com&quot;</span><br><span class="line">    ],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;ip:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改本地镜像TAG</span></span><br><span class="line">docker tag  镜像名:TAG ip:5000/镜像名:TAG</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送到私服</span></span><br><span class="line">docker push ip:5000/镜像名:TAG</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull ip:5000/镜像名:TAG</span><br></pre></td></tr></table></figure><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>不建议直接使用<code>docker run mysql</code>，数据容易丢失。</p><p>推荐命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql mysql:8.0.31-debian</span><br></pre></td></tr></table></figure><blockquote><p>这样即使直接将容器删除，也不会影响表中的数据</p></blockquote><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -p 6379:6379 --name redis --privileged=true -v /mydata/redis/redis.conf:/etc/redis/redis.conf -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>配置文件：<a href="../../_resources/redis.conf">redis.conf</a></p><h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动master</span></span><br><span class="line">docker run -d -p 3306:3306 --privileged=true -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql-master mysql:8.0.31-debian</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入master</span></span><br><span class="line">docker exec -it mysql-master /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录后创建数据同步用户</span></span><br><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动slave</span></span><br><span class="line">docker run -d -p 3307:3306 --privileged=true -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql-slave mysql:8.0.31-debian</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入slave</span></span><br><span class="line">docker exec -it mysql-slave /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登陆后配置主从复制</span></span><br><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3306, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure><p>主从复制参数说明：</p><ul><li>master_host：主数据库的IP地址；</li><li>master_port：主数据库的运行端口；</li><li>master_user：在主数据库创建的用于同步数据的用户账号；</li><li>master_password：在主数据库创建的用于同步数据的用户密码；</li><li>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</li><li>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</li><li>master_connect_retry：连接失败重试的时间间隔，单位为秒。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在数据库中查看主从同步状态</span><br><span class="line">show slave status \G;</span><br><span class="line">#在从数据库中开启主从同步</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;G 表示以键值对的形式展示</p></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>理论：</p><p>redis集群有三种存储方案：</p><ul><li>哈希取余分区</li></ul><p>缺点：扩容和缩容后，映射关系需要重新进行计算(很多数据要迁移)</p><ul><li>一致性哈希算法分区</li></ul><p>乍一听听不懂，其实也很好理解，构建一个一致性哈希环[0,2^32-1]，根据Redis的信息映射到哈希环的一个点，key根据计算会落到哈希环的一个点，它顺时针遇到的第一个Redis便存储该数据。</p><p>有更好的容错性和扩展性，扩缩容只会改变哈希环中两个redis节点之间的数据，但新的问题是容易因为节点分布不均匀造成数据倾斜。</p><ul><li>哈希槽（Redis采用的方式）</li></ul><p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。我们只需要控制每个Redis节点分配的槽数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /mydata/redis/share/redis-node-1:/mydata redis --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /mydata/redis/share/redis-node-2:/mydata redis --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /mydata/redis/share/redis-node-3:/mydata redis --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /mydata/redis/share/redis-node-4:/mydata redis --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /mydata/redis/share/redis-node-5:/mydata redis --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /mydata/redis/share/redis-node-6:/mydata redis --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置主从关系</span></span><br><span class="line">redis-cli --cluster create 192.168.124.106:6381 192.168.124.106:6382 192.168.124.106:6383 192.168.124.106:6384 192.168.124.106:6385 192.168.124.106:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure><blockquote><p>–cluster-replicas 1 表示为每个master创建一个slave节点；集群会自动搭配对应的主从关系</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看节点状态</span></span><br><span class="line">cluster info</span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接集群</span></span><br><span class="line">redis-cli -p 6381 -c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群信息</span></span><br><span class="line">redis-cli --cluster check ip:6381</span><br></pre></td></tr></table></figure><blockquote><p>-c：优化路由；如果不带会导致部分数据不能存储</p></blockquote><h4 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新增节点</span></span><br><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /mydata/redis/share/redis-node-7:/mydata redis --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /mydata/redis/share/redis-node-8:/mydata redis --cluster-enabled yes --appendonly yes --port 6388</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将7号节点作为master加入集群</span></span><br><span class="line">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新分配槽号</span></span><br><span class="line">redis-cli --cluster reshard ip:6381</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分配从节点</span></span><br><span class="line">redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从节点可以直接删除</span></span><br><span class="line">redis-cli --cluster del-node ip:6388 从机6388节点ID</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将7号节点中的槽位分配给其它节点</span></span><br><span class="line">redis-cli --cluster reshard ip:6381</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除7号节点</span></span><br></pre></td></tr></table></figure><blockquote><p>扩缩容其实和Redis第五章在虚拟机中的操作一样</p></blockquote><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><p>官方教程：<a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference | Docker Docs</a></p><p>规范：</p><ul><li>每条保留字指令都<strong>必须为大写字母</strong>且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ul><p>内部流程：</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>循环上面操作直到所有指令都执行完成</li></ol><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol><li>FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条指令必须是from</li><li>MAINTAINER：镜像维护者的姓名和邮箱地址</li><li>RUN：容器构建时需要运行的命令，有两种格式：<ul><li>shell格式：<code>RUN &lt;命令行命令&gt;</code>；示例：<code>RUN yum -y install vim</code></li><li>exec格式：<code>RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;...]</code>；示例：<code>RUN [&quot;~/zk.sh&quot;,&quot;stop&quot;]</code>等价于<code>RUN ~/zk.sh stop</code></li></ul></li><li>EXPOSE：声明当前容器对外暴露的端口</li><li>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</li><li>USER：指定该镜像以什么样的用户去执行，如果都不指定，默认是root</li><li>ENV：用来在构建镜像过程中设置环境变量</li><li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li><li>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。<code>COPY src源路径 dest目标路径</code>或<code>COPY [&quot;src源路径&quot;, &quot;dest目标路径&quot;]</code></li><li>VOLUME：容器数据卷，用于数据保存和持久化工作</li><li>CMD：指定容器启动后的操作，除了shell格式和exec格式，当指定了ENTRYPOINT指令时，会成为参数列表格式：<code>CMD [&quot;参数1&quot;,&quot;参数2&quot;...]</code></li></ol><blockquote><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>CMD是在docker run时运行；RUN是在docker build时运行。</p></blockquote><ol start="12"><li>ENTRYPOINT：用来指定一个容器启动时要运行的命令；类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，并且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</li></ol><p>案例说明：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment">#定参</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="comment">#变参</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实际效果：nginx -c /etc/nginx/nginx.conf</span></span><br><span class="line">docker run nginx:test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实际效果：nginx -c /etc/nginx/new.conf</span></span><br><span class="line">docker run  nginx:test /etc/nginx/new.conf</span><br></pre></td></tr></table></figure><p>配置Redis+Java8的镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前最新的7.2.3；debian</span></span><br><span class="line"><span class="keyword">FROM</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u391-linux-x64.tar.gz /usr/local/java/</span></span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_391</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">构建</span></span><br><span class="line">docker build -t mylinux:1.0 .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行</span></span><br><span class="line">docker run  -p 6379:6379 -p 80:8080 --name mylinux --privileged=true -v /mydata/redis/redis.conf:/etc/redis/redis.conf -v /mydata/redis/data:/data -d mylinux:1.0 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>仓库名、标签都是<none>的镜像，俗称dangling image</p><p>虚悬镜像没有存在的价值，一般都删掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">docker image ls -f dangling=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除</span></span><br><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>在我们启动Docker后，使用<code>ip addr</code>会发现列表中多了一个docker0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker网络模式命令</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>默认三大网络模式：</p><ol><li>bridge：网桥模式（相当于NAT）</li><li>host：主机网络（相当于主机网络）</li><li>none：无网络</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看网络源数据</span></span><br><span class="line">docker network inspect XXX网络名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建网络</span></span><br><span class="line">docker network create XXX网络名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除网络</span></span><br><span class="line">docker network rm XXX网络名字</span><br></pre></td></tr></table></figure><p>作用：内置了容器服务名和ip的映射，容器IP变动时候可以通过服务名直接网络通信而不受到影响</p><ol start="4"><li>container：和已经存在的一个容器共享一个网络ip配置</li></ol><p>示例：<code>docker run -it --network container:alpine1 --name alpine2  alpine /bin/sh</code></p><blockquote><p>关闭alpine1；alpine2的网路数据也会消失</p></blockquote><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p><p>当服务过多并且相互有依赖关系（设定启动顺序）的情况是，我们手动一个个启动容器是非常累的，Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），这样可以很容易地用一个配置文件定义一个多容器的工程，然后使用一条指令完成项目构建和启动。</p><p>官网介绍：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">Compose 文件版本 3 参考 |Docker 文档</a></p><p>下载：<a href="https://docs.docker.com/compose/install/linux/#install-the-plugin-manually">安装 Compose 插件 |Docker 文档</a></p><p>概念：</p><ul><li>服务：应用容器实例</li><li>工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义</li></ul><p>使用步骤：</p><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>执行<code>docker-compose up</code>命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><p>常用命令：</p><table><thead><tr><th align="center">命令</th><th>说明</th></tr></thead><tbody><tr><td align="center">docker-compose -h</td><td>查看帮助</td></tr><tr><td align="center">docker-compose up</td><td>启动所有docker-compose服务</td></tr><tr><td align="center">docker-compose up -d</td><td>启动所有docker-compose服务并后台运行</td></tr><tr><td align="center">docker-compose down</td><td>停止并删除容器、网络、卷、镜像</td></tr><tr><td align="center">docker-compose exec  yml里面的服务id</td><td>进入容器实例内部  docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</td></tr><tr><td align="center">docker-compose ps</td><td>展示当前docker-compose编排过的运行的所有容器</td></tr><tr><td align="center">docker-compose top</td><td>展示当前docker-compose编排过的容器进程</td></tr><tr><td align="center">docker-compose logs  yml里面的服务id</td><td>查看容器输出日志</td></tr><tr><td align="center">docker-compose config</td><td>检查配置</td></tr><tr><td align="center">docker-compose config -q</td><td>检查配置，有问题才有输出</td></tr><tr><td align="center">docker-compose restart</td><td>重启服务</td></tr><tr><td align="center">docker-compose start</td><td>启动服务</td></tr><tr><td align="center">docker-compose stop</td><td>停止服务</td></tr></tbody></table><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">microService:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zzyy_docker:1.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6001:6001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/microService:/data</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0.8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">   <span class="attr">atguigu_net:</span> </span><br></pre></td></tr></table></figure><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><p>官网：<a href="https://www.portainer.io/">Portainer</a>；<a href="https://docs.portainer.io/start/install-ce/server/docker/linux">Install Portainer CE with Docker</a></p><blockquote><p>CE表示社区版；跟着官网操作安装即可</p></blockquote><h2 id="容器监控CIG"><a href="#容器监控CIG" class="headerlink" title="容器监控CIG"></a>容器监控CIG</h2><p>通过<code>docker status</code>可以查看当前机器上所有容器的资源占用数据，但数据资料是实时的，没有数据存储、健康预警等功能。</p><p>CIG：CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</p><p>对应的docker-compose.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">grafana_data:</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">influxdb:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">tutum/influxdb:0.9</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PRE_CREATE_DB=cadvisor</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./data/influxdb:/data</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">cadvisor:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">google/cadvisor</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">-storage_driver=influxdb</span> <span class="string">-storage_driver_db=cadvisor</span> <span class="string">-storage_driver_host=influxsrv:8086</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">grafana:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">grafana_data:/var/lib/grafana</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HTTP_USER=admin</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HTTP_PASS=admin</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_HOST=influxsrv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_PORT=8086</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_NAME=cadvisor</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_USER=root</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_PASS=root</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--restart=always</code>：跟随docker容器启动</p></blockquote><p>一般中小公司就够用了，更完善的功能就需要上K8S了</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2024/01/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/4.Kafka/"/>
      <url>/2024/01/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/4.Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>官网：<a href="https://kafka.apache.org/">Apache Kafka</a></p><p>传统定义：Kafka是一个分布式的基于发布&#x2F;订阅模式的消息队列(Message Queue)，主要应用于大数据实时处理领域。</p><p>新定义： Kafka是一个开源的分布式事件流平台(Event Streaming Platform)，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用。</p><p>传统的消息队列的主要应用场景包括：缓存&#x2F;消峰、解耦和异步通信。</p><ul><li><p>缓冲&#x2F;消峰：有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p></li><li><p>允许独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>允许用户把一个消息放入队列，并不立即处理它(不需要等待不那么重要的系统流程)。</p></li></ul><p>两种常见的模式：</p><ol><li>点对点模式：消费者主动拉取数据，消息收到后清除数据</li><li>发布&#x2F;订阅模式：可以有多个topic主题；消费者消费数据之后，<strong>不删除数据</strong>；每个消费者相互独立，都可以消费到数据</li></ol><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><ol><li>为了方便拓展&amp;提高吞吐量，一个topic分为多个partition</li><li>配合分区的设计，突出消费者组的概念，组内每个消费者并行消费</li><li>为提高可用性，为每个partition增加若干个副本</li><li>ZK中记录这Leader的信息(2.8.0版本以后可以不采用ZK)</li></ol><p>工作示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216173313.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216173313.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f8dc7ddc2e2580bad5a310935a4ba87b.png"></p><ul><li>Producer：消息生产者，就是向 Kafka broker 发消息的客户端。</li><li>Consumer：消息消费者，向 Kafka broker 取消息的客户端。</li><li>Consumer Group（CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，<strong>一个分区只能由一个组内消费者消费</strong>；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li>Broker：一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li><li>Topic：主题，生产者和消费者面向的都是一个 topic。</li><li>Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。</li><li>Replica：副本。一个 topic 的每个分区都有若干个副本，一个 Leader 和若干个 Follower。</li><li>Leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。</li><li>Follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>清华镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/">Index of &#x2F;apache&#x2F;kafka (tsinghua.edu.cn)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf kafka_2.13-3.6.0.tgz -C /opt/app/</span><br><span class="line"><span class="comment"># 修改名称</span></span><br><span class="line"><span class="built_in">mv</span> kafka_2.13-3.6.0/ kafka</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim kafka/config/server.properties</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># broker 的全局唯一编号，不能重复，只能是数字。</span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 处理网络请求的线程数量</span></span><br><span class="line"><span class="attr">num.network.threads</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 用来处理磁盘 IO 的线程数量</span></span><br><span class="line"><span class="attr">num.io.threads</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 发送套接字的缓冲区大小</span></span><br><span class="line"><span class="attr">socket.send.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"><span class="comment"># 接收套接字的缓冲区大小</span></span><br><span class="line"><span class="attr">socket.receive.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"><span class="comment"># 请求套接字的缓冲区大小</span></span><br><span class="line"><span class="attr">socket.request.max.bytes</span>=<span class="string">104857600</span></span><br><span class="line"><span class="comment"># kafka 运行日志(数据)存放的路径，路径不需要提前创建，kafka 自动帮你创建</span></span><br><span class="line"><span class="comment"># 可以配置多个磁盘路径，路径与路径之间可以用&quot;,&quot;分隔</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/tmp/kafka-logs</span></span><br><span class="line"><span class="comment"># topic 在当前 broker 上的分区个数</span></span><br><span class="line"><span class="attr">num.partitions</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 用来恢复和清理 data 下数据的线程数量</span></span><br><span class="line"><span class="attr">num.recovery.threads.per.data.dir</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 每个topic创建时的副本数，默认时 1 个副本</span></span><br><span class="line"><span class="attr">offsets.topic.replication.factor</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># segment文件保留的最长时间，超时将被删除</span></span><br><span class="line"><span class="attr">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"><span class="comment"># 每个 segment 文件的大小，默认最大 1G</span></span><br><span class="line"><span class="attr">log.segment.bytes</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment"># 检查过期数据的时间，默认 5 分钟检查一次是否数据过期</span></span><br><span class="line"><span class="attr">log.retention.check.interval.ms</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment"># 配置连接 Zookeeper 地址（在 zk 根目录下创建/kafka，方便管理，集群使用,分隔）</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">localhost:2181</span></span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile.d/kafka.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#KAFKA_HOME</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_HOME=/opt/module/kafka</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KAFKA_HOME</span>/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动Kafka前需要先启动Zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./zk.sh start</span><br><span class="line"><span class="comment"># 启动Kafka</span></span><br><span class="line"><span class="built_in">cd</span> /opt/app/kafka</span><br><span class="line">bin/kafka-server-start.sh -daemon config/server.properties</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure><blockquote><p>应为Zookeeper和Kafka都是Java开发，查看当前进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbitmq kafka]<span class="comment"># jps</span></span><br><span class="line">1345 QuorumPeerMain</span><br><span class="line">10916 Jps</span><br><span class="line">3034 Kafka</span><br></pre></td></tr></table></figure></blockquote><p>脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;start&quot;</span>)&#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot; --------启动 <span class="variable">$i</span> Kafka-------&quot;</span></span><br><span class="line"> /opt/app/kafka/bin/kafka-server-start.sh -daemon /opt/app/kafka/config/server.properties</span><br><span class="line">&#125;;;</span><br><span class="line"><span class="string">&quot;stop&quot;</span>)&#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot; --------停止 <span class="variable">$i</span> Kafka-------&quot;</span></span><br><span class="line"> /opt/app/kafka/bin/kafka-server-stop.sh</span><br><span class="line">&#125;;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>此时连接Zookeeper的客户端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] <span class="built_in">ls</span> /</span><br><span class="line">[admin, brokers, cluster, config, consumers, controller, controller_epoch, feature, isr_change_notification, latest_producer_id_block, log_dir_event_notification, zookeeper]</span><br></pre></td></tr></table></figure><blockquote><p><code>/brokers/ids/</code>下就绑定着我们在配置文件设定的<code>broker.id</code></p></blockquote><h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>查看命令参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–bootstrap-server &lt;String: server toconnect to&gt;</td><td>连接的 Kafka Broker 主机名称和端口号</td></tr><tr><td>–topic &lt;String: topic&gt;</td><td>操作的 topic 名称</td></tr><tr><td>–create</td><td>创建主题</td></tr><tr><td>–delete</td><td>删除主题</td></tr><tr><td>–alter</td><td>修改主题</td></tr><tr><td>–list</td><td>查看所有主题</td></tr><tr><td>–describe</td><td>查看主题详细描述</td></tr><tr><td>–partitions &lt;Integer: # of partitions&gt;</td><td>设置分区数</td></tr><tr><td>–replication-factor &lt;Integer: replication factor&gt;</td><td>设置分区副本</td></tr><tr><td>–config &lt;String: name&#x3D;value&gt;</td><td>更新系统默认的配置</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class="line"><span class="comment"># 创建1分区1副本的topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --partitions 1 --replication-factor 1 --topic topic1</span><br><span class="line"><span class="comment"># 查看 topic1 主题的详情</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic topic1</span><br><span class="line"><span class="comment"># 修改分区数（注意：分区数只能增加，不能减少）</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --alter --topic topic1 --partitions 3</span><br><span class="line"><span class="comment"># 删除主题</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic topic1</span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>查看命令参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–bootstrap-server &lt;String: server toconnect to&gt;</td><td>连接的 Kafka Broker 主机名称和端口号</td></tr><tr><td>–topic &lt;String: topic&gt;</td><td>操作的 topic 名称</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">bin/kafka-console-producer.sh --bootstrap-server 127.0.0.1:9092 --topic topic1</span><br></pre></td></tr></table></figure><blockquote><p>这里不能识别localhost：DNS resolution failed for loaclhost</p></blockquote><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>查看命令参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–bootstrap-server &lt;String: server toconnect to&gt;</td><td>连接的 Kafka Broker 主机名称和端口号</td></tr><tr><td>–topic &lt;String: topic&gt;</td><td>操作的 topic 名称</td></tr><tr><td>–from-beginning</td><td>从头开始消费</td></tr><tr><td>–group &lt;String: consumer group id&gt;</td><td>指定消费者组名称</td></tr></tbody></table><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从当前时间开始消费</span></span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic topic1</span><br><span class="line"><span class="comment"># 消费所有数据</span></span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --from-beginning --topic topic1</span><br></pre></td></tr></table></figure><h1 id="2-生产者"><a href="#2-生产者" class="headerlink" title="2. 生产者"></a>2. 生产者</h1><h2 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h2><p>在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程。在 main 线程中创建了一个双端队列 RecordAccumulator。main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka Broker。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216173320.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216173320.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="36731856a8c24bd0e7f00aef59ceb1a5.png"></p><blockquote><p>是Sender线程主动去拉数据。</p><p>batch.size：只有数据积累到batch.size之后，sender才会发送数据。默认16k </p><p>linger.ms：如果数据迟迟未达到batch.size，sender等待linger.ms设置的时间 到了之后就会发送数据。单位ms，默认值是0ms，表示没有延迟。</p></blockquote><ul><li>ProducerRecord: 消息对象。</li><li>Interceptor: 拦截器，Kafka一共有两种拦截器:生产者拦截器和消费者拦截器。生产者拦截器既可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。</li><li>Partitioner: 分区器，消息经过序列化之后确定它发往的分区</li><li>RecordAccumulator: 主要用来缓存消息以便Sender线程可以批量发送，进而减少网络传输的资源消耗以提升性能。RecordAccumulator缓存的大小可以通过生产者客户端参数buffer.memory配置，默认值为32M。如果生产者发送消息的速度超过发送到服务器的速度，则会导致生产者空间不足，这个时候Producer的send()方法调用要么被阻塞，要么抛出异常，这个取决于参数max.block.ms的配置，此参数的默认值为60秒。主线程中发送过来的消息都会被迫加到RecordAccumulator的某个双端队列(Deque)中，在RecordAccumulator的内部为每个分区都维护了一个双端队列，队列中的内容就是ProducerBatch，即Deque<ProducerBatch>。消息写入缓存时，追加到双端队列的尾部:Sender读取消息时，从双端队列的头部读取。</li></ul><blockquote><p>RecordAccumulator内部还有个BufferPool，主要用来复用特定大小的ProducerBatch块，这个特定大小会通过batch.size指定，默认为16KB，例如说当有一条消息（ProducerRecord）流入RecordAccumulator，会先通过分区号寻找双端队列（如果没有则创建），再从队列的尾部获取一个ProducerBatch（如果没有则新建），查看ProducerBatch是否还可以装的下这个ProducerRecord，如果可以则写入，如果不可以则需创建个新的ProducerBatch。在新建ProducerBatch时会评估这个ProducerRecord的大小是否超过batch.size，也就是可复用ProducerBatch的大小，如果没超过，那么可以从BufferPool中拿个闲置的ProducerBatch来使用。如果超过，那么就按实际的大小创建ProducerBatch，这个ProducerBatch不会再被复用。</p></blockquote><ul><li>InFlightRequests: 请求在从Sender线程发往Kafka之前还会保存到InFlightRequests中，InFlightRequests保存对象的具体形式为Map&lt;Nodeld,Deque&gt;，它的主要作用是缓存了已经发出去但还没有收到响应的请求(Nodeld表示broker节点的id编号)。InFlightRequests还提供了许多管理类的方法，并且通过配置参数还可以限制每个连接(也就是客户端与Node之间的连接)最多缓存的请求数。这个配置参数为max.in.flight.requests.per.connection，默认值为5，即每个连接最多只能缓存5个未响应的请求，超过该数值之后就不能再向这个连接发送更多的请求了，除非有缓存的请求收到了响应。<strong>InFlightRequests还可以获得leastLoadedNode，即所有Node中负载最小的那一个。</strong>选择leastLoadedNode发送请求可以使它能够尽快发出，避免因网络拥塞等异常而影响整体的进度。比如元数据请求，当需要更新元数据时，会先挑选出leastLoadedNode,然后向这个Node发送MetadataRequest请求来获取具体的元数据信息。</li></ul><h3 id="应答机制"><a href="#应答机制" class="headerlink" title="应答机制"></a>应答机制</h3><p>分区收到生产者发送的数据后，都需要向生产者发送ack参数可设置的值为<strong>0</strong>、<strong>1</strong>、<strong>all(-1)</strong></p><ul><li>0：代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li><li>1：代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li><li>all：<strong>默认值</strong>。代表producer往集群发送数据需要ISR都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低</li></ul><p>当ACK&#x3D;all时，Leader和follower（ISR）落盘才会返回ack，<strong>会有数据重复现象</strong>，如果在leader已经写完成，且follower同步完成，但是在返回ack的出现故障，则会出现数据重复现象；<strong>极限情况下，这个也会有数据丢失的情况</strong>，比如follower和leader通信都很慢，所以ISR中只有一个leader节点，这个时候，leader完成落盘，就会返回ack，如果此时leader故障后，就会导致丢失数据。</p><p><strong>ISR</strong>：</p><p>为了防止一个follower的宕机导致集群的瘫痪（所有follower都同步信息的条件不能达成，导致不能应答），Leader中维护了一个动态的<code>in-sync replica set（ISR）</code>，意为和Leader保持同步的Follower+Leader集合(leader：0，isr:0,1,2)。</p><p>如果Follower长时间未向Leader发送通信请求或同步数据，则该Follower将被踢出ISR。该时间阈值由replica.lag.time.max.ms参数设定，默认30s。例如2超时，(leader:0, isr:0,1)。这样就不用等长期联系不上或者已经故障的节点。</p><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>重要参数</p><ul><li><code>retry.backoff.ms</code>：两次重试之间的时间间隔，默认是 100ms。</li><li><code>retries</code>：重试次数。默认是 int 最大值，2147483647。</li></ul><p>当消费者接收数据失败或者响应时间超过了设置的<code>retry.backoff.ms</code>参数时，Selecto会根据设置的<code>retries</code>参数进行重试。</p><p>如果设置了重试，同时想要保证消息的有序性，需要设置<code>MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION=1</code> ，避免在其之后消息的在重试时被发送出去。</p><ul><li><code>enable.idempotence</code>：是否开启幂等性，默认 true</li><li><code>compression.type</code>：生产者发送的所有数据的压缩方式，默认是 none。支持压缩类型：none、gzip、snappy、lz4 和 zstd。</li></ul><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>异步发送就是非阻塞的，即发送消息后不会等待消息是否成功发送到 Kafka。</p><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 配置Kafka服务地址</span></span><br><span class="line">    properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置key的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 配置value的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 自动关闭</span></span><br><span class="line">    <span class="keyword">try</span> (KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;在吗？&quot;</span>);</span><br><span class="line">        <span class="comment">// 不带回调函数</span></span><br><span class="line">        kafkaProducer.send(producerRecord);</span><br><span class="line">        <span class="comment">// 带回调函数</span></span><br><span class="line">        kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;你好！&quot;</span>), <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;主题：&quot;</span> + recordMetadata.topic() + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + recordMetadata.partition());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;运行完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，kafka配置文件中要进行以下设置，否则不能远程连接：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;listeners</span>=<span class="string">PLAINTEXT://localhost:9092</span></span><br></pre></td></tr></table></figure></blockquote><p>可以事先在xShell中开启一个消费者，以便更好的观察效果。</p><p>消息发送失败会自动重试，不需要我们在回调函数中手动重试。</p><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>只需要在异步发送的基础上再调用一下 get()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafkaProducer.send(producerRecord).get();</span><br></pre></td></tr></table></figure><p>异步和同步获取<code>RecordMetadata</code>的时机不同：</p><ul><li>同步发送的 <code>send</code> 方法会将消息添加到内部的缓冲区，但它不会立即返回，<code>get</code> 调用会一直阻塞，直到消息成功发送到 Kafka 或者发送出错，然后返回 <code>RecordMetadata</code>。</li><li>异步发送的 <code>send</code> 方法时，它会将消息添加到内部的缓冲区，并立即返回，Kafka 生产者会有一个后台线程，负责将缓冲区中的消息异步发送到 Kafka 服务器。</li></ul><blockquote><p>比如在异步调用的例子中，运行成功的提示是先打印的。</p></blockquote><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区的好处：</p><ul><li><strong>便于合理使用存储资源</strong>，每个Partition在一个Broker上存储，可以把海量的数据按照分区切割成一 块一块数据存储在多台Broker上。合理控制分区的任务，可以实现负载均衡的效果。</li><li><strong>提高并行度</strong>，生产者可以以分区为单位发送数据；消费者可以以分区为单位进行消费数据。</li></ul><h3 id="默认分区策略"><a href="#默认分区策略" class="headerlink" title="默认分区策略"></a>默认分区策略</h3><p><strong>默认的分区器 DefaultPartitioner</strong>：</p><ol><li>指明partition的情况下，直接将指明的值作为partition值；例如partition&#x3D;0，所有数据写入分区0</li><li>没有指明partition值但有key的情况下，将key的hash值与topic的partition数进行取余得到partition值；</li><li>既没有partition值又没有key值的情况下(此时key默认为空串)，Kafka采用Sticky Partition(<strong>黏性分区器</strong>)，会随机选择一个分区，并尽可能一直使用该分区，待该分区的batch已满或者已完成，Kafka再随机一个分区进行使用（和上一次的分区不同）。</li></ol><p>简单测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span> + i, <span class="string">&quot;test1&quot;</span>), (metadata, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + metadata.partition());</span><br><span class="line">    &#125;);</span><br><span class="line">    kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;test&quot;</span> + i, <span class="string">&quot;test2&quot;</span>), (metadata, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + metadata.partition());</span><br><span class="line">    &#125;);</span><br><span class="line">    kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;test3&quot;</span>), (metadata, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + metadata.partition());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义分区器"><a href="#自定义分区器" class="headerlink" title="自定义分区器"></a>自定义分区器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.toString().contains(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.toString().contains(<span class="string">&quot;2&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 配置Kafka服务地址</span></span><br><span class="line">    properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置key的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 配置value的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 配置自定义分区器</span></span><br><span class="line">    properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class.getName());</span><br><span class="line">    <span class="keyword">try</span> (KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">// 为了方便观察分区器的效果，这里使用同步发送</span></span><br><span class="line">            kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="string">&quot;test&quot;</span> + i, <span class="string">&quot;test2&quot;</span>), (metadata, e) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;test2&quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + metadata.partition());</span><br><span class="line">            &#125;).get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><h3 id="提高吞吐量"><a href="#提高吞吐量" class="headerlink" title="提高吞吐量"></a>提高吞吐量</h3><p>调整吞吐量的重要参数：</p><ul><li>batch.size：批次大小，默认16k </li><li>linger.ms：等待时间，修改为5-100ms</li><li>compression.type：压缩，常用 snappy</li><li>RecordAccumulator：缓冲区大小，修改为64m</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// batch.size：批次大小，默认 16K</span></span><br><span class="line"> properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">// linger.ms：等待时间，单位ms，默认 0;</span></span><br><span class="line"> properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// RecordAccumulator：缓冲区大小，默认 32M：buffer.memory</span></span><br><span class="line"> properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG,<span class="number">33554432</span>);</span><br><span class="line"><span class="comment">// compression.type：压缩，默认 none，可配置值 gzip、snappy、lz4 和 zstd</span></span><br><span class="line">properties.put(ProducerConfig.COMPRESSION_TYPE_CONFIG,<span class="string">&quot;snappy&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="数据可靠"><a href="#数据可靠" class="headerlink" title="数据可靠"></a>数据可靠</h3><p><strong>数据完全可靠条件 &#x3D; ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</strong></p><p>在生产环境中，acks&#x3D;0很少使用；acks&#x3D;1，一般用于传输普通日志，允许丢个别数据；acks&#x3D;-1，可靠性要求比较高的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 acks</span></span><br><span class="line">properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"><span class="comment">// 重试次数 retries，默认是 int 最大值，2147483647</span></span><br><span class="line">properties.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h3><p>在应答机制中讲到过，达成数据完全可靠条件的同时，会引发数据重复的问题：</p><ul><li>至少一次（At Least Once）&#x3D; ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</li><li>最多一次（At Most Once）&#x3D; ACK级别设置为0</li></ul><p>精确一次（Exactly Once）：对于一些非常重要的信息，比如和钱相关的数据，要求数据既不能重复也不丢失。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>指Producer不论向Broker发送多少次重复数据，Broker端都只会持久化一条，保证了不重复。</p><p><strong>精确一次（Exactly Once） &#x3D; 幂等性 + 至少一次（ ack&#x3D;-1 + 分区副本数&gt;&#x3D;2 + ISR最小副本数量&gt;&#x3D;2） 。</strong></p><p>重复数据的判断标准：具有&lt;PID, Partition, SeqNumber&gt;相同主键的消息提交时，Broker只会持久化一条。其中PID是Kafka每次重启都会分配一个新的；Partition 表示分区号；Sequence Number是单调自增的。</p><blockquote><p><strong>只能保证单分区单会话内的幂等性</strong>，默认开启</p></blockquote><h3 id="生产者事务"><a href="#生产者事务" class="headerlink" title="生产者事务"></a>生产者事务</h3><p>事务是建立在幂等性的功能上的，所以开启事务<strong>必须开启幂等性</strong>。</p><p>事务流程</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232730.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232730.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="501ee1504ab41bf5c02ea90ffdb330eb.png"></p><blockquote><p>Producer 在使用事务功能前，必须先自定义一个唯一的 transactional.id。有 了 transactional.id，即使客户端挂掉了， 它重启后也能继续处理未完成的事务</p></blockquote><p>相关API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 初始化事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initTransactions</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 2 开启事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line"><span class="comment">// 3 在事务内提交已经消费的偏移量（主要用于消费者）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line"><span class="comment">// 4 提交事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line"><span class="comment">// 5 放弃事务（类似于回滚事务的操作）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 配置Kafka服务地址</span></span><br><span class="line">    properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置key的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 配置value的序列化</span></span><br><span class="line">    properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    <span class="comment">// 设置事务 id（必须），事务 id 任意起名</span></span><br><span class="line">    properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 自动关闭</span></span><br><span class="line">    KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        kafkaProducer.initTransactions();</span><br><span class="line">        kafkaProducer.beginTransaction();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            kafkaProducer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span> + i, <span class="string">&quot;test&quot;</span> + i), (metadata, e) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;test1&quot;</span> + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;分区：&quot;</span> + metadata.partition());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// if (i == 3) &#123;</span></span><br><span class="line">            <span class="comment">//     i /= 0;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        kafkaProducer.commitTransaction();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        kafkaProducer.abortTransaction();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据有序"><a href="#数据有序" class="headerlink" title="数据有序"></a>数据有序</h3><p>单分区内，Kafka接收和发送的数据是有序的。</p><p>两种设置方式：</p><ul><li>未开启幂等性：<code>max.in.flight.requests.per.connection=1</code></li><li>开启幂等性：<code>max.in.flight.requests.per.connection</code>需要设置小于等于5。</li></ul><p>启用幂等后，kafka服务端会缓存producer发来的最近5个request的元数据， 故无论如何，都可以保证最近5个request的数据都是有序的。</p><blockquote><p>1.x之前的版本：需要设置：<code>max.in.flight.requests.per.connection=1</code>，即上一条消息确认接收才发下一条</p></blockquote><h1 id="3-Broker"><a href="#3-Broker" class="headerlink" title="3. Broker"></a>3. Broker</h1><p>之前浅略地查看了zookeeper中存放的broker的信息，接下来进行详细的讲解。</p><p>Zookeaper 中存储的Kafka 信息：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232741.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232741.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9ded261691166286fcbdefb1162a75c4.png"></p><h2 id="总体工作流程"><a href="#总体工作流程" class="headerlink" title="总体工作流程"></a>总体工作流程</h2><p>Broker 总体工作流程</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232800.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232800.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="26a8d1b563d5695f55814dd2325f54fe.png"></p><blockquote><p>ISR之前做过介绍，不再赘述。<br><code>OSR</code>：表示 <code>Follower</code> 与 <code>Leader</code> 副本同步时，延迟过多的副本。<br><code>AR</code>：指的是分区中的所有副本，所以<code>AR = ISR + OSR</code>。</p></blockquote><h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><ol><li>Kafka 副本的作用：提高数据可靠性。</li><li>默认副本 1 个，生产环境一般配置为 2 个，保证数据可靠性；太多副本会增加磁盘存储空间，增加网络上数据传输，降低效率。</li><li>副本分为：Leader 和 Follower。Leader负责消息的接收和发送， Follower 主动从 Leader 同步数据。</li><li>Kafka 分区中的所有副本统称为 AR</li></ol><h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><p>Kafka 集群中有一个 broker 的 Controller 会被选举为 Controller Leader，负责管理集群 broker 的上下线，所有 topic 的分区副本分配和 Leader 选举等工作。</p><p><strong>leader选举规则</strong>：在isr中存活为前提，按 照AR中排在前面的优先。例如 ar[1,0,2]，isr[1,0,2]，那么leader 就会按照1，0，2的顺序轮询。</p><p>假设上图中的broker1宕机，那么broker0中的Controller会在监听到节点变化后从Zookeeper中获取ISR，通过前面提到的选举规则选举出新的Leader，最后更新Zookeeper中的Leader和ISR。</p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>replica.lag.time.max.ms</td><td>ISR 中，如果 Follower 长时间未向 Leader 发送通信请求或同步数据，则该 Follower 将被踢出 ISR。时间阈值默认 30s。</td></tr><tr><td>auto.leader.rebalance.enable</td><td>默认是 true。 自动 Leader Partition 平衡。</td></tr><tr><td>leader.imbalance.per.broker.percentage</td><td>默认是 10%。每个 broker 允许的不平衡的 leader 的比率。如果每个 broker 超过了这个值，控制器会触发 leader 的平衡。</td></tr><tr><td>leader.imbalance.check.interval.seconds</td><td>默认值 300 秒。检查 leader 负载是否平衡的间隔时间</td></tr><tr><td>log.segment.bytes</td><td>Kafka 中 log 日志是分成一块块存储的，此配置是指 log 日志划分成块的大小，默认值 1G。</td></tr><tr><td>log.index.interval.bytes</td><td>默认 4kb，每当kafka 写入了 4kb 大小的日志（.log），然后就往 index 文件里面记录一个索引。</td></tr><tr><td>log.retention.hours</td><td>Kafka 中数据保存的时间，默认 7 天</td></tr><tr><td>log.retention.minutes</td><td>Kafka 中数据保存的时间，分钟级别，默认关闭</td></tr><tr><td>log.retention.ms</td><td>Kafka 中数据保存的时间，毫秒级别，默认关闭</td></tr><tr><td>log.retention.check.interval.ms</td><td>检查数据是否保存超时的间隔，默认是 5 分钟。</td></tr><tr><td>log.retention.bytes</td><td>默认等于-1，表示无穷大。超过设置的所有日志总大小，删除最早的 segment。</td></tr><tr><td>log.cleanup.policy</td><td>默认是 delete，表示所有数据启用删除策略；如果设置值为 compact，表示所有数据启用压缩策略。</td></tr><tr><td>num.io.threads</td><td>默认是 8。负责写磁盘的线程数。整个参数值要占总核数的 50%</td></tr><tr><td>num.replica.fetchers</td><td>副本拉取线程数，这个参数占总核数的 50%的 1&#x2F;3</td></tr><tr><td>num.network.threads</td><td>默认为 3。数据传输线程数，这个参数占总核数的 50%的 2&#x2F;3 。</td></tr><tr><td>log.flush.interval.messages</td><td>强制页缓存刷写到磁盘的条数，默认是 long 的最大值，9223372036854775807。一般不建议修改，交给系统自己管理。</td></tr><tr><td>log.flush.interval.ms</td><td>刷数据到磁盘的间隔时间，默认是 null。一般不建议修改，交给系统自己管理。</td></tr></tbody></table><h3 id="服役新节点"><a href="#服役新节点" class="headerlink" title="服役新节点"></a>服役新节点</h3><blockquote><p>如果不是新装的kafka，需要删除对应存放的日志（指定的日志目录和目录下的logs文件夹）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要复杂均衡的主题</span></span><br><span class="line">vim topics-to-move.json</span><br><span class="line"><span class="comment"># 让kafka生成负载均衡计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --topics-to-move-json-file topics-to-move.json --broker-list <span class="string">&quot;0,1,2,3&quot;</span> --generate</span><br><span class="line"><span class="comment"># 创建副本存储计划,即将生成的计划存储到文件中</span></span><br><span class="line">vim increase-replication-factor.json</span><br><span class="line"><span class="comment"># 执行副本存储计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --execute</span><br><span class="line"><span class="comment"># 查看副本存储计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --verify</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;topics&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;first&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>退役节点可以直接停掉服务，或者按照服役新节点的操作手动执行新存储计划(broker-list&#96;少一个节点)</p><h3 id="故障处理原理"><a href="#故障处理原理" class="headerlink" title="故障处理原理"></a>故障处理原理</h3><p>概念：</p><ul><li>LEO（Log End Offset）：每个副本的最后一个offset，LEO其实就是最新的offset + 1。</li><li>HW（High Watermark）：所有副本中最小的LEO 。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232811.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232811.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0ce75a9848110d2c4fde91841f28034a.png"></p><p><strong>Follower</strong></p><ol><li>Follower发生故障后会被临时踢出ISR</li><li>期间内Leader和其它Follower继续接收数据</li><li>待该Follower恢复后，Follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分删除掉，从HW开始向Leader进行同步。</li><li>等该Follower的LEO大于等于HW，即 Follower追上Leader之后，就可以重新加入ISR了。</li></ol><p><strong>Leader</strong></p><ol><li>Leader发生故障之后，会从ISR中选出一个新的Leader</li><li>为保证多个副本之间的数据一致性，其余的Follower会先将各自的log文件高于HW的部分截掉，然后从新的Leader同步数据。</li></ol><blockquote><p>只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p></blockquote><h3 id="分区副本分配"><a href="#分区副本分配" class="headerlink" title="分区副本分配"></a>分区副本分配</h3><p>默认Kafka会进行分区以及副本的负载均衡，以下3Broker16分区3副本可以体现(未出现宕机等情况)：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232832.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232832.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5463422f9a4fe32a8beda34ce4a8be99.png"></p><h4 id="手动调整"><a href="#手动调整" class="headerlink" title="手动调整"></a>手动调整</h4><p>每台服务器的配置和性能不一致，但是Kafka只会根据自己的代码规则创建对应的分区副本，就会导致个别服务器存储压力较大。所有需要手动调整分区副本的存储。</p><p>比如当前有四台服务器，但希望将将所有分区和副本放在前两个机器中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的 topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --create --partitions 4 --replication-factor 2 --topic three</span><br><span class="line"><span class="comment"># 查看分区副本存储情况</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --describe --topic three</span><br><span class="line"><span class="comment"># 创建副本存储计划</span></span><br><span class="line">vim increase-replication-factor.json</span><br><span class="line"><span class="comment"># 执行副本存储计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --execute</span><br><span class="line"><span class="comment"># 验证副本存储计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --verify</span><br><span class="line"><span class="comment"># 查看分区副本存储情况</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --describe --topic three</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;three&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;three&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;three&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;three&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="增加副本"><a href="#增加副本" class="headerlink" title="增加副本"></a>增加副本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --create --partitions 3 --replication-factor 1 --topic four</span><br><span class="line"><span class="comment"># 创建副本存储计划</span></span><br><span class="line">vim increase-replication-factor.json</span><br><span class="line"><span class="comment"># 执行副本存储计划</span></span><br><span class="line">bin/kafka-reassign-partitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --execute</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;four&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;four&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span><span class="string">&quot;four&quot;</span><span class="punctuation">,</span><span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;replicas&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="数据存储机制"><a href="#数据存储机制" class="headerlink" title="数据存储机制"></a>数据存储机制</h3><p>Topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文件，该log文件中存储的就是Producer生产的数据。</p><p>Producer生产的数据会被不断追加到该log文件末端，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片和索引机制</strong>，将每个partition分为多个segment。</p><p>每个segment包括：“.index”文件、“.log”文件和.timeindex等文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号，例如：first-0。</p><ul><li>.log：日志文件</li><li>.index：偏移量索引文件</li><li>.timeindex：时间戳索引文件</li></ul><blockquote><p>index和log文件以当前segment的第一条消息的offset命名</p></blockquote><p>可以通过工具查看index和log信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看索引文件</span></span><br><span class="line">/opt/app/kafka/bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files ./00000000000000000000.index</span><br><span class="line"><span class="comment"># 查看日志文件</span></span><br><span class="line">/opt/app/kafka/bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files ./00000000000000000000.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>定位消息：</p><ol><li>根据目标offset定位Segment文件</li><li>找到小于等于目标offset的最大offset对应的索引项</li><li>定位到log文件</li><li>向下遍历找到目标Record</li></ol><blockquote><p>Index文件中保存的offset为相对offset，这样能确保offset的值所占空间不会过大， 因此能将offset的值控制在固定大小</p></blockquote><h3 id="文件清理策略"><a href="#文件清理策略" class="headerlink" title="文件清理策略"></a>文件清理策略</h3><p>参数列表处介绍了Kafka文件清理的四个参数：</p><ul><li>log.retention.hours</li><li>log.retention.minutes</li><li>log.retention.ms</li><li>log.retention.check.interval.ms</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有数据启用删除策略</span></span><br><span class="line"><span class="attr">log.cleanup.policy</span>=<span class="string">delete</span></span><br></pre></td></tr></table></figure><ol><li>基于时间删除：默认打开。以 segment 中所有记录中的最大时间戳作为该文件时间戳。</li></ol><blockquote><p>也就是说文件中的数据全部都过期才会删除</p></blockquote><ol start="2"><li>基于大小：默认关闭。超过设置的日志总大小，删除最早的segment。log.retention.bytes，默认等于-1，表示无穷大</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有数据启用删除策略</span></span><br><span class="line"><span class="attr">log.cleanup.policy</span>=<span class="string">compact</span></span><br></pre></td></tr></table></figure><blockquote><p>对于相同key的不同value值，只保留最后一个版本。</p><p>这种策略只适合特殊场景，比如消息的key是用户ID，value是用户的资料，通过这种压缩策略，整个消息集里就保存了所有用户最新的资料。</p></blockquote><h3 id="高效读写数据"><a href="#高效读写数据" class="headerlink" title="高效读写数据"></a>高效读写数据</h3><p>原因：</p><ol><li>Kafka 本身是分布式集群，可以采用分区技术，并行度高</li><li>读数据采用稀疏索引，可以快速定位要消费的数据</li><li>顺序写磁盘</li></ol><blockquote><p>Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端，省去了大量磁头寻址的时间</p></blockquote><ol start="4"><li><strong>页缓存 + 零拷贝技术</strong></li></ol><p>PageCache页缓存：Kafka重度依赖底层操作系统提供的PageCache功 能。当上层有写操作时，操作系统只是将数据写入 PageCache。当读操作发生时，先从PageCache中查找，如果找不到，再去磁盘中读取。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用</p><p>零拷贝：Kafka的数据加工处理操作交由Kafka生产者和Kafka消费者处理。Kafka Broker应用层不关心存储的数据，所以就不用走应用层，传输效率高。</p><p>零拷贝技术示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232917.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231225232917.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9b1c966edc7c54e964838414f8ee2111.png"></p><h1 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4. 消费者"></a>4. 消费者</h1><p>Kafka消费方式：</p><ol><li>pull（拉）模式：consumer采用从broker中主动拉取数据。<strong>Kafka采用</strong></li><li>push（推）模式：由broker 决定消息发送速率，很难适应所有消费者的消费速率。没采用</li></ol><blockquote><p>pull模式不足之处是，如果Kafka没有数据，消费者可能会陷入循环中，一直返回空数据。</p></blockquote><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>生产者将数据发送到Broker，根据策略发送到多个分区，消费者订阅的分区中拉取数据，同时会在每个broker中维护一个offset信息，用于记录数据消费的偏移量。</p><p><strong>消费者组</strong>：由一个或多个groupid相同的消费者构成。</p><ul><li>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由组内的一个消费者消费。</li></ul><blockquote><p>如果消费者组的消费者数超过主题分区数，那么会有一部分消费者被闲置</p></blockquote><ul><li>消费者组之间互不影响。消费者组是逻辑上的一个订阅者。</li></ul><h3 id="消费分配"><a href="#消费分配" class="headerlink" title="消费分配"></a>消费分配</h3><p>在 Kafka 中，每个消费者组都有三个主要的 Coordinator：</p><ol><li><strong>Group Coordinator（组协调器）：</strong> 负责管理消费者组的整体信息，处理组的加入和离开，以及进行 Rebalance 操作。每个消费者组有一个对应的 Group Coordinator。</li><li><strong>Offset Coordinator（偏移协调器）：</strong> 负责处理消费者组提交的 offset 信息。每个消费者组中的每个消费者都会有一个 Offset Coordinator。</li><li><strong>Transaction Coordinator（事务协调器）：</strong> 用于支持事务性生产者，负责管理事务的开始、提交和回滚等操作。每个事务性生产者都有一个对应的 Transaction Coordinator。</li></ol><p>这里介绍的组协调器，规则：groupid的hashcode值 % 50（ __consumer_offsets主题的默认分区数量）</p><blockquote><p><code>__consumer_offsets</code> 主题是实际存储消费者组的 offset 信息的地方。每个分区对应一个消费者组的 offset 数据。这些 offset 数据包含了消费者组在各个分区中的消费进度。</p></blockquote><p>消费分配流程：</p><ol><li>每个consumer都向Coordinator发送JoinGroup请求</li><li>Coordinator选出一个消费者作为消费者组的leader</li><li>Coordinator把要消费的topic情况发送给leader 消费者</li><li>leader制定好消费方案后将消费方案发送给Coordinator</li><li>Coordinator把消费方案下发给各个consumer，consumer根据消费方案拉取数据</li></ol><blockquote><p>每个消费者都会和coordinator保持心跳（默认3s），一旦超时(<code>session.timeout.ms=45s</code>)，该消费者会被移除，并触发再平衡；或者消费者处理消息的时间过长(<code>max.poll.interval.ms</code>：5分钟)，也会触发再平衡。</p></blockquote><h3 id="参数列表-1"><a href="#参数列表-1" class="headerlink" title="参数列表"></a>参数列表</h3><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>bootstrap.servers</td><td>向 Kafka 集群建立初始连接用到的 host&#x2F;port 列表。</td></tr><tr><td>key.deserializer 和 value.deserializer</td><td>指定接收消息的 key 和 value 的反序列化类型(全类名)。</td></tr><tr><td>group.id</td><td>标记消费者所属的消费者组。</td></tr><tr><td>enable.auto.commit</td><td>默认值为 true，消费者会自动周期性地向服务器提交偏移量。</td></tr><tr><td>auto.commit.interval.ms</td><td>如果设置了 enable.auto.commit 的值为 true， 则该值定义了消费者偏移量向 Kafka 提交的频率，默认 5s。</td></tr><tr><td>auto.offset.reset</td><td>当 Kafka 中没有初始偏移量或当前偏移量在服务器中不存在(如，数据被删除了)，该如何处理？ earliest：自动重置偏移量到最早的偏移量。 latest：默认，自动重置偏移量为最新的偏移量。 none：如果消费组原来的（previous）偏移量不存在，则向消费者抛异常。 anything：向消费者抛异常。</td></tr><tr><td>offsets.topic.num.partitions</td><td>__consumer_offsets 的分区数，默认是 50 个分区。</td></tr><tr><td>heartbeat.interval.ms</td><td>Kafka 消费者和 coordinator 之间的心跳时间，默认 3s。该值必须小于 session.timeout.ms ，且不应该高于 session.timeout.ms 的 1&#x2F;3。</td></tr><tr><td>session.timeout.ms</td><td>Kafka 消费者和 coordinator 之间连接超时时间，默认 45s。超过该值，该消费者被移除，消费者组执行再平衡</td></tr><tr><td>max.poll.interval.ms</td><td>消费者处理消息的最大时长，默认是 5 分钟。超过该值，该消费者被移除，消费者组执行再平衡。</td></tr><tr><td>fetch.min.bytes</td><td>默认 1 个字节。消费者获取服务器端一批消息最小的字节数。</td></tr><tr><td>fetch.max.wait.ms</td><td>默认 500ms。如果没有从服务器端获取到一批数据的最小字节数。该时间到，仍然会返回数据。</td></tr><tr><td>fetch.max.bytes</td><td>默认 Default: 52428800（50 m）。消费者获取服务器端一批消息最大的字节数。如果服务器端一批次的数据大于该值 (50m)仍然可以拉取回来这批数据，因此，这不是一个绝对最大值。一批次的大小受 message.max.bytes(broker  config) or max.message.bytes (topic config)影响。</td></tr><tr><td>max.poll.records</td><td>一次 poll 拉取数据返回消息的最大条数，默认是 500 条。</td></tr></tbody></table><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>指定消费主题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 给消费者配置对象添加参数</span></span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置序列化</span></span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    <span class="comment">// 配置消费者组（组名任意起名）</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        <span class="comment">// 注册要消费的主题（可以消费多个主题）</span></span><br><span class="line">        List&lt;String&gt; topics = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        topics.add(<span class="string">&quot;topic1&quot;</span>);</span><br><span class="line">        kafkaConsumer.subscribe(topics);</span><br><span class="line">        <span class="comment">// 拉取数据打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 1s 中消费一批数据</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>StringDeserializer</code>实现反序列化</p></blockquote><p>指定消费分区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">    <span class="comment">// 指定分区消费</span></span><br><span class="line">    List&lt;TopicPartition&gt; topics = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    topics.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    kafkaConsumer.assign(topics);</span><br><span class="line">    <span class="comment">// 拉取数据打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置 1s 中消费一批数据</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配策略与再平衡"><a href="#分配策略与再平衡" class="headerlink" title="分配策略与再平衡"></a>分配策略与再平衡</h3><p>前面介绍到了消费分配，但是消费者Leader是根据什么来指定消费方案呢？</p><p>Kafka有四种主流的分区分配策略： <strong>Range</strong>、<strong>RoundRobin</strong>、<strong>Sticky</strong>、<strong>CooperativeSticky</strong>。</p><p>可以通过配置参数<code>partition.assignment.strategy</code>来修改分区的分配策略，Kafka可以同时使用多个分区分配策略。默认策略是Range + CooperativeSticky。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>Range 是对每个 topic 而言的。</p><p>首先对同一个topic中的分区按照序号进行排序，并对消费者按照字母顺序进行排序；通过partitions数&#x2F;consumer数 来决定每个消费者应该消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。</p><blockquote><p>问题：容易产生数据倾斜，因为对于多个topic而言，前面的消费者会多消费一些分区</p></blockquote><p>再平衡策略：</p><ol><li>在45s以内某个消费者宕机，kafka会将其本应该担任的分区<strong>整体分配</strong>给其它消费者。</li><li>在45s以后，宕机的消费者会被踢出消费者组，消费者的分区进行重新分配</li></ol><h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><p>RoundRobin 针对集群中所有Topic而言。</p><p>RoundRobin 轮询分区策略，是把所有的 partition 和所有的 consumer 都列出来，然后按照 hashcode 进行排序，最后通过轮询算法来分配 partition 给到各个消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改分区分配策略</span></span><br><span class="line">properties.put(ConsumerConfig.PARTITION_ASSIGNMENT_STRATEGY_CONFI</span><br><span class="line">G, <span class="string">&quot;org.apache.kafka.clients.consumer.RoundRobinAssignor&quot;</span>);</span><br></pre></td></tr></table></figure><p>再平衡策略：</p><ol><li>45s内，按照 RoundRobin 的方式，分别将分区数据交给剩余的消费者</li><li>45s后，重新按照 RoundRobin 方式分配</li></ol><h4 id="Sticky"><a href="#Sticky" class="headerlink" title="Sticky"></a>Sticky</h4><p>粘性分区定义：在执行一次新的分配之前，考虑上一次分配的结果，尽量少的调整分配的变动，可以节省大量的开销</p><p>首先会尽量均衡的放置分区到消费者上面，在出现同一消费者组内消费者出现问题的时候，会尽量保持原有分配的分区不变化。</p><p>再平衡策略：</p><ol><li>45s内，尽可能均衡地随机将分区数据交给其他消费者</li><li>45s后，重新按照粘性方式分配</li></ol><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>0.9版本前，consumer默认将offset保存在Zookeeper中；0.9版本之后，consumer默认将offset保存在Kafka的<code>__consumer_offsets</code>主题中。</p><p>其中数据的key是<code>group.id+topic+ 分区号</code>，value就是当前offset的值。每隔一段时间，kafka内部会对这个topic进行compact，也就是保留最新数据。</p><p>该主题默认是不能消费的，需要在配置文件<code>config/consumer.properties</code>中添加配置<code>exclude.internal.topics=false</code>。</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>默认开启，相关参数</p><ul><li>enable.auto.commit：是否开启自动提交offset功能</li><li>auto.commit.interval.ms：自动提交offset的时间间隔，默认是5s</li></ul><h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p>手动提交offset的方法有两种：分别是commitSync（同步提交）和commitAsync（异步提交）。</p><ul><li>相同点：都会将本次提交的一批数据最高的偏移量提交</li><li>不同点：同步提交阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而异步提交则没有失败重试机制，故有可能提交失败。</li></ul><blockquote><p>同步提交必须等待offset提交完毕，才能去消费下一批数据</p></blockquote><p>同步提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 给消费者配置对象添加参数</span></span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置序列化</span></span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    <span class="comment">// 设置手动提交</span></span><br><span class="line">    properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 配置消费者组（组名任意起名）</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        <span class="comment">// 指定分区消费</span></span><br><span class="line">        List&lt;TopicPartition&gt; topics = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        topics.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        kafkaConsumer.assign(topics);</span><br><span class="line">        <span class="comment">// 拉取数据打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 1s 中消费一批数据</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">            kafkaConsumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步提交 offset</span></span><br><span class="line">consumer.commitAsync();</span><br></pre></td></tr></table></figure><h3 id="指定Offset消费"><a href="#指定Offset消费" class="headerlink" title="指定Offset消费"></a>指定Offset消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 给消费者配置对象添加参数</span></span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置序列化</span></span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    <span class="comment">// 设置手动提交</span></span><br><span class="line">    properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 配置消费者组（组名任意起名）</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        <span class="comment">// 指定主题消费</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;topic1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;TopicPartition&gt; assignment= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (assignment.isEmpty()) &#123;</span><br><span class="line">            kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 获取消费者分区分配信息（有了分区分配信息才能开始消费）</span></span><br><span class="line">            assignment = kafkaConsumer.assignment();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有分区，并指定 offset 从 200 的位置开始消费</span></span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp: assignment) &#123;</span><br><span class="line">            kafkaConsumer.seek(tp, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉取数据打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 1s 中消费一批数据</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">            kafkaConsumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>poll方法不是调用一次就能返回数据，需要多次交互等待消费方案的确定。</p></blockquote><h3 id="指定时间消费"><a href="#指定时间消费" class="headerlink" title="指定时间消费"></a>指定时间消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 给消费者配置对象添加参数</span></span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.124.105:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置序列化</span></span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    <span class="comment">// 设置手动提交</span></span><br><span class="line">    properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 配置消费者组（组名任意起名）</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties)) &#123;</span><br><span class="line">        <span class="comment">// 指定主题消费</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;topic1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;TopicPartition&gt; assignment = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (assignment.isEmpty()) &#123;</span><br><span class="line">            kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 获取消费者分区分配信息（有了分区分配信息才能开始消费）</span></span><br><span class="line">            assignment = kafkaConsumer.assignment();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;TopicPartition, Long&gt; timeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 得到一周前的时间戳</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().minusWeeks(<span class="number">1</span>).toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">// 封装集合存储，每个分区对应一天前的数据</span></span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">            timeMap.put(tp, time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取从 1 周前开始消费的每个分区的 offset</span></span><br><span class="line">        Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsetMap = kafkaConsumer.offsetsForTimes(timeMap);</span><br><span class="line">        <span class="comment">// 遍历每个分区，对每个分区设置消费时间。</span></span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">            <span class="type">OffsetAndTimestamp</span> <span class="variable">offsetAndTimestamp</span> <span class="operator">=</span> offsetMap.get(tp);</span><br><span class="line">            <span class="comment">// 根据时间指定开始消费的位置</span></span><br><span class="line">            <span class="keyword">if</span> (offsetAndTimestamp != <span class="literal">null</span>) &#123;</span><br><span class="line">                kafkaConsumer.seek(tp, offsetAndTimestamp.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拉取数据打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 1s 中消费一批数据</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">            kafkaConsumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏消费和重复消费"><a href="#漏消费和重复消费" class="headerlink" title="漏消费和重复消费"></a>漏消费和重复消费</h3><ul><li>重复消费：已经消费了数据，但是 offset 没提交。</li></ul><p>自动提交offset的情况下，如果提交offset后的2s，consumer挂了，再次重启consumer，则从上一次提交的offset处继续消费，导致重复消费</p><ul><li>漏消费：先提交 offset 后消费，有可能会造成数据的漏消费。</li></ul><p>offset为手动提交，当offset被提交时，数据还在内存中未落盘，此时刚好消费者线程被kill掉，那么offset已经提交，但是数据未处理完成，导致这部分内存中的数据丢失。</p><p>消费者事务：</p><p>想要Consumer端实现精准一次性消费，需要Kafka消费端将消费过程和提交offset 过程做原子绑定，可以将Kafka的offset保存到支持事务的自定义介质(比 如 MySQL)。</p><h3 id="提高吞吐量-1"><a href="#提高吞吐量-1" class="headerlink" title="提高吞吐量"></a>提高吞吐量</h3><ol><li>增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数 &#x3D; 分区数。</li><li>提高每批次拉取的数量</li></ol><h1 id="5-Kafka-Eagle-监控"><a href="#5-Kafka-Eagle-监控" class="headerlink" title="5. Kafka-Eagle 监控"></a>5. Kafka-Eagle 监控</h1><p>Kafka-Eagle 框架可以监控 Kafka 集群的整体运行情况。Kafka-Eagle 的安装依赖于 MySQL。</p><blockquote><p>配置不足，该章节仅作记录</p></blockquote><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>关闭服务后，修改kafka文件<code>bin/kafka-server-start.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原设置</span></span><br><span class="line">if [ &quot;x$KAFKA_HEAP_OPTS&quot; = &quot;x&quot; ]; then</span><br><span class="line">export KAFKA_HEAP_OPTS=&quot;-Xmx1G -Xms1G&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改为：</span></span><br><span class="line"></span><br><span class="line">if [ &quot;x$KAFKA_HEAP_OPTS&quot; = &quot;x&quot; ]; then</span><br><span class="line"> export KAFKA_HEAP_OPTS=&quot;-server -Xms2G -Xmx2G -XX:PermSize=128m -XX:+UseG1GC -   XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70&quot;</span><br><span class="line"> export JMX_PORT=&quot;9999&quot;</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-Xmx1G -Xms1G&quot;</span></span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>官网下载安装包：<a href="https://www.kafka-eagle.org/">EFAK (kafka-eagle.org)</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压完成后改名</span></span><br><span class="line">mv efak-web-2.0.8/ efak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line">vim efak/conf/system-config.properties</span><br></pre></td></tr></table></figure><p>需要修改的点：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">efak.zk.cluster.alias</span>=<span class="string">cluster1</span></span><br><span class="line"><span class="attr">cluster1.zk.list</span>=<span class="string">hadoop102:2181,hadoop103:2181,hadoop104:2181/kafka</span></span><br><span class="line"><span class="comment"># offset 保存在 kafka</span></span><br><span class="line"><span class="attr">cluster1.efak.offset.storage</span>=<span class="string">kafka</span></span><br><span class="line"><span class="comment"># 配置 mysql 连接</span></span><br><span class="line"><span class="attr">efak.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">efak.url</span>=<span class="string">jdbc:mysql://hadoop102:3306/ke?useUnicode=true&amp;characterEncoding=UT</span></span><br><span class="line"><span class="attr">F-8&amp;zeroDateTimeBehavior</span>=<span class="string">convertToNull</span></span><br><span class="line"><span class="attr">efak.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">efak.password</span>=<span class="string">000000</span></span><br></pre></td></tr></table></figure><p>添加环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile.d/efak.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kafkaEFAK</span></span><br><span class="line">export KE_HOME=/opt/module/efak</span><br><span class="line">export PATH=$PATH:$KE_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷新配置</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>启动zk以及kafka后启动efak：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/ke.sh start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">bin/ke.sh stop</span><br></pre></td></tr></table></figure><h2 id="Kafka-Kraft-模式"><a href="#Kafka-Kraft-模式" class="headerlink" title="Kafka-Kraft 模式"></a>Kafka-Kraft 模式</h2><blockquote><p>此部分没有进行实践，算是对未来架构的窥探，了解即可</p></blockquote><p>在现有结构中，元数据在zookeeper中，运行时动态选举controller，由controller进行Kafka集群管理。</p><p>在Kraft模式架构中，是与哦给你三台controller节点代替zookeeper，元数据保存在controller中，由controller直接进行 Kafka 集群管理，不再依赖 zookeeper 集群。</p><p>好处：</p><ul><li>Kafka 不再依赖外部框架，而是能够独立运行；</li><li>controller 管理集群时，不再需要从 zookeeper 中先读取数据，集群性能上升；</li><li>由于不依赖 zookeeper，集群扩展时不再受到 zookeeper 读写能力限制；</li><li>controller 不再动态选举，而是由配置文件规定。这样我们可以有针对性的加强 controller 节点的配置，而不是对随机 controller 节点的高负载束手无策。</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压kafka安装包</span></span><br><span class="line">tar -zxvf kafka_2.12-3.0.0.tgz -C /opt/module/</span><br><span class="line">mv kafka_2.12-3.0.0/ kafka</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line">vim /opt/module/kafka/config/kraft/server.properties</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kafka 的角色（controller 相当于主机、broker 节点相当于从机，主机类似 zk 功能）</span></span><br><span class="line">process.roles=broker,controller</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">节点 ID</span></span><br><span class="line">node.id=2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">controller 服务协议别名</span></span><br><span class="line">controller.listener.names=CONTROLLER</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全 Controller 列表</span></span><br><span class="line">controller.quorum.voters=2@hadoop102:9093,3@hadoop103:9093,4@hadoop104:9093</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不同服务器绑定的端口</span></span><br><span class="line">listeners=PLAINTEXT://:9092,CONTROLLER://:9093</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker 服务协议别名</span></span><br><span class="line">inter.broker.listener.name=PLAINTEXT</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker 对外暴露的地址</span></span><br><span class="line">advertised.Listeners=PLAINTEXT://hadoop102:9092</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">协议别名到安全协议的映射</span></span><br><span class="line">listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kafka 数据存储目录</span></span><br><span class="line">log.dirs=/opt/module/kafka/data</span><br></pre></td></tr></table></figure><blockquote><p>node.id需要保证全局唯一，用于controller选举，值需要和 controller.quorum.voters 对应。</p></blockquote><p>初始化集群数据目录：</p><ol><li>生成存储目录唯一 ID</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-storage.sh random-uuid</span><br></pre></td></tr></table></figure><blockquote><p>得到的值为：J7s9e8PPTKOO47PxzI39VA，用于之后指令执行</p></blockquote><ol start="2"><li>格式化 kafka 存储目录(三台节点)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别在三台机器中执行</span></span><br><span class="line">bin/kafka-storage.sh format -t J7s9e8PPTKOO47PxzI39VA -c</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Kafka集群</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别在三台机器中执行</span></span><br><span class="line">bin/kafka-server-start.sh -daemon config/kraft/server.properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure><p>启停脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line"> for i in hadoop102 hadoop103 hadoop104</span><br><span class="line"> do</span><br><span class="line"> echo &quot; --------启动 $i Kafka-------&quot;</span><br><span class="line"> ssh $i &quot;/opt/module/kafka2/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/kraft/server.properties&quot;</span><br><span class="line"> done</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line"> for i in hadoop102 hadoop103 hadoop104</span><br><span class="line"> do</span><br><span class="line"> echo &quot; --------停止 $i Kafka-------&quot;</span><br><span class="line"> ssh $i &quot;/opt/module/kafka2/bin/kafka-server-stop.sh &quot;</span><br><span class="line"> done</span><br><span class="line">&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h1 id="6-SpringBoot整合"><a href="#6-SpringBoot整合" class="headerlink" title="6. SpringBoot整合"></a>6. SpringBoot整合</h1><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kafkaApp</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.124</span><span class="number">.105</span><span class="string">:9092</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">workspace:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(KafkaApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KafkaProducer&lt;String, String&gt; <span class="title function_">kafkaProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KafkaConsumer&lt;String, String&gt; <span class="title function_">kafkaConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;consumer1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &#123;&quot;topic1&quot;&#125;, groupId = &quot;group1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">        System.out.println(record);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然也可以在配置文件中声明</p></blockquote><p>控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/kafka&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaProducer&lt;String, String&gt; producer;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic1&quot;</span>, message));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get/&#123;topic&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">(<span class="meta">@PathVariable</span> String topic)</span> &#123;</span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; poll = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : poll) &#123;</span><br><span class="line">            result.append(record.value()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-性能调优"><a href="#7-性能调优" class="headerlink" title="7. 性能调优"></a>7. 性能调优</h1><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><ol><li>服务器台数&#x3D; 2 * （生产者峰值生产速率 * 副本 &#x2F; 100） + 1</li></ol><blockquote><p>（生产者峰值生产速率 * 副本 &#x2F; 100）的值需要进位，比如<code>20*2/100-&gt;1</code></p></blockquote><ol start="2"><li>磁盘：kafka 底层主要是顺序写，建议选择普通的机械硬盘。</li><li>Kafka 内存组成：堆内存 + 页缓存</li></ol><ul><li>Kafka 堆内存建议每个节点：10g ~ 15g</li></ul><p>修改<code>kafka-server-start.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;x$KAFKA_HEAP_OPTS&quot; = &quot;x&quot; ]; then</span><br><span class="line">  export KAFKA_HEAP_OPTS=&quot;-Xmx10G -Xms10G&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>查看GC情况：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看kafka进程号</span></span><br><span class="line">jps</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据进程号查看GC情况</span></span><br><span class="line">jstat -gc [进程号] 1s 10</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="center">参数</th><th>解释</th></tr></thead><tbody><tr><td align="center">S0C</td><td>年轻代中第一个survivor (幸存区)的容量(kb)</td></tr><tr><td align="center">S1C</td><td>年轻代中第二个survivor (幸存区)的容量(kb)</td></tr><tr><td align="center">S0U</td><td>年轻代中第一个survivor (幸存区)目前已使用空间(kb)</td></tr><tr><td align="center">S1U</td><td>年轻代中第二个survivor (幸存区)目前已使用空间(kb)</td></tr><tr><td align="center">EC</td><td>年轻代中Eden（伊甸园）的容量 (kb)</td></tr><tr><td align="center">EU</td><td>年轻代中Eden（伊甸园）目前已使用空间 (kb)</td></tr><tr><td align="center">OC</td><td>Old代的容量 (kb)</td></tr><tr><td align="center">OU</td><td>Old代目前已使用空间 (kb)</td></tr><tr><td align="center">PC</td><td>Perm(持久代)的容量 (kb)</td></tr><tr><td align="center">PU</td><td>Perm(持久代)目前已使用空间 (kb)</td></tr><tr><td align="center">YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td align="center">YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr><tr><td align="center">FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td align="center">FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s)</td></tr><tr><td align="center">GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr></tbody></table><ul><li>查看 Kafka 的堆内存</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap [进程号]</span><br></pre></td></tr></table></figure><ul><li>每个节点页缓存大小 &#x3D;（分区数 * 1g * 25%）&#x2F; 节点数</li></ul><blockquote><p>页缓存：页缓存是 Linux 系统服务器的内存。只需要保证 1 个 segment（1g）中 25%的数据在内存中就好。</p></blockquote><ol start="4"><li>CPU<ul><li>num.io.threads：负责写磁盘的线程数，整个参数值要占总核数的 50%</li><li>num.replica.fetchers：副本拉取线程数，这个参数占总核数的 50%的 1&#x2F;3</li><li>num.network.threads：数据传输线程数，这个参数占总核数的 50%的 2&#x2F;3</li></ul></li><li>网络带宽 &#x3D; 峰值吞吐量</li></ol><blockquote><p>100Mbps 单位是 bit；10M&#x2F;s 单位是 byte ; 1byte &#x3D; 8bit，100Mbps&#x2F;8 &#x3D; 12.5M&#x2F;s。</p></blockquote><h1 id="8-源码分析"><a href="#8-源码分析" class="headerlink" title="8. 源码分析"></a>8. 源码分析</h1><p>继续学习：<a href="https://www.bilibili.com/video/BV1vr4y1677k?p=83&vd_source=3acac9cf7f1674a7677cd0687f9b24c8">83_尚硅谷_Kafka_源码_环境准备_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2023/12/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/3.Zookeeper/"/>
      <url>/2023/12/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/3.Zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>官网：<a href="https://zookeeper.apache.org/">Apache ZooKeeper</a></p><p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。</p><p>从设计模式的角度来理解，Zookeeper是一个基于观察者模式设计的分布式服务管理框架，负责存储和管理系统服务的关键数据。</p><p>特点：</p><ol><li>一个Leader，多个Follower组成的集群。</li><li>集群中只要有半数以上的节点存活，Zookeeper集群就能正常服务，所以集群机器一般为奇数</li><li>全局数据一致：每个Server保存一份相同的数据副本</li><li>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。</li><li>数据更新原子性，一次数据更新要么成功，要么失败。</li><li>实时性，在一定时间范围内，Client能读到最新数据。</li></ol><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识。</p><p>应用场景：</p><p>Zookeeper能够提供的服务包括：：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下 线、软负载均衡等。</p><p><strong>统一命名服务</strong>：在分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别。</p><p><strong>统一配置管理</strong>：可以将配置信息写入一个Znode，各个客户端服务器监听这个Znode。</p><blockquote><p>比如Kafka集群中，可以保证所有节点的配置信息是一致的。</p></blockquote><p><strong>统一集群管理</strong>：ZooKeeper可以实现实时监控节点状态变化；监听对应的ZNode可获取到对应的节点信息。</p><p><strong>服务器动态上下线</strong>：客户端可以通过Zookeeper实时得知服务器上下线的变化。</p><p><strong>软负载均衡</strong>：Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>镜像下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/">&#x2F;apache&#x2F;zookeeper(tsinghua.edu.cn)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.7.2-bin.tar.gz -C /opt/app/</span><br><span class="line"><span class="comment">#修改名称</span></span><br><span class="line"><span class="built_in">mv</span> apache-zookeeper-3.7.2 -bin/ zookeeper</span><br><span class="line"><span class="comment">#zookeeper目录下创建数据存放地</span></span><br><span class="line"><span class="built_in">mkdir</span> zkData</span><br><span class="line"><span class="comment">#修改conf目录下的zoo_sample.cfg</span></span><br><span class="line"><span class="built_in">mv</span> zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">dataDir=/opt/app/zookeeper/zkData</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line"><span class="comment">#zkData目录下创建myid，官网指定，固定名称</span></span><br><span class="line"><span class="built_in">touch</span> myid</span><br></pre></td></tr></table></figure><blockquote><p>配置文件不一定要使用zoo.cfg的名称</p><p>myid文件中只需要添加与server对应的编号</p></blockquote><p>配置参数解读：</p><ol><li>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</li><li>initLimit &#x3D; 10：LF初始通信时限。Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）</li><li>syncLimit &#x3D; 5：LF同步通信时限；超过时限Leader就会认为Follwer宕机</li><li>dataDir：保存Zookeeper中的数据</li><li>clientPort &#x3D; 2181：客户端连接端口，通常不做修改。</li><li><code>server.A=B:C:D</code>：A表示是第几号服务器，记录在myid文件中；B是服务器的地址；C是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口；D是用来执行选举时服务器相互通信的端口。</li></ol><h3 id="启停指令"><a href="#启停指令" class="headerlink" title="启停指令"></a>启停指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="comment">#查看java进程</span></span><br><span class="line">jps</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"><span class="comment">#启动客户端</span></span><br><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="comment">#退出客户端</span></span><br><span class="line">quit</span><br><span class="line"><span class="comment">#关闭</span></span><br><span class="line">bin/zkServer.sh stop</span><br></pre></td></tr></table></figure><p>启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">  echo ---------- zookeeper 启动 ------------</span><br><span class="line">  /opt/app/zookeeper/bin/zkServer.sh start</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">  echo ---------- zookeeper 关闭 ------------</span><br><span class="line">  /opt/app/zookeeper/bin/zkServer.sh stop</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;status&quot;)&#123;</span><br><span class="line">  echo ---------- zookeeper 状态 ------------</span><br><span class="line">  /opt/app/zookeeper/bin/zkServer.sh status</span><br><span class="line">&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>Zookeeper 内部维护有一些信息来决定 Leader 的归属：</p><ul><li>SID：服务器ID；用来唯一标识集群中的机器，不能重复，和myid一致</li><li>ZXID：事务ID；ZXID是一个事务ID，用来标识一次服务器状态的变更。</li></ul><blockquote><p>在某一时刻， 集群中的每台机器的ZXID值不一定完全一 致，这和ZooKeeper服务器对于客户端“更 新请求”的处理逻辑有关。</p></blockquote><ul><li>Epoch：每个Leader任期的代号；没有 Leader 时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</li></ul><h3 id="首次启动"><a href="#首次启动" class="headerlink" title="首次启动"></a>首次启动</h3><p>假设当前的集群由五台Zookeeper组成。</p><ol><li>1号启动，发起第一次选举；优先投给自己，此时票数为1，选举无法完成（小于3），服务器状态保持为LOOKING；</li><li>2号启动，发起第二次选举；1号和2号各自投自己一票并交换选票信息，此时1号发现2号的myid比自己当前投票推举的（1号）更大，更改选票推举2号。此时1号0票，2号两票，选举无法完成，1号、2号保持LOOKING；</li><li>3号启动，发起第三次选举；根据之前的规律，选举完成后3号持有三票，3号成为Leader。1，2号状态为FOLLOWING，3号更改状态为LEADING；</li><li>4号启动，发起第四次选举，但此时1，2，3已经不是LOOKING状态，不会更改选票信息。结果为3号3票，4号1票。4号服从多数将更改选票为3号，状态变为FOLLOWING；</li><li>5号启动，成为FOLLOWING；</li></ol><h3 id="非首次启动"><a href="#非首次启动" class="headerlink" title="非首次启动"></a>非首次启动</h3><p>当集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：</p><ul><li>服务器初始化启动</li><li>服务器运行期间无法和Leader保持连接</li></ul><p>当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：</p><ul><li>集群中存在Leader；</li></ul><p>选举阶段会被告知Leader的信息，仅需要和Leader建立连接，同步状态即可。</p><ul><li>集群中不存在Leader</li></ul><p>Leader选举规则：</p><ol><li>EPOCH大的胜出</li><li>EPOCH相同，事务id大的胜出</li><li>事务id相同，服务器id大的胜出</li></ol><p>集群搭配推荐：10 台服务器：3 台 zk；20 台服务器：5 台 zk；100 台及以上服务器：11 台 zk；</p><blockquote><p>服务器台数越多；好处：提高可靠性；坏处：提高通信延时</p></blockquote><h1 id="客户端操作命令"><a href="#客户端操作命令" class="headerlink" title="客户端操作命令"></a>客户端操作命令</h1><table><thead><tr><th align="center">命令基本语法</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="center">help</td><td align="left">显示所有操作命令</td></tr><tr><td align="center">ls [path]</td><td align="left">使用 ls 命令来查看当前 znode 的子节点 [可监听]<br> -w 监听子节点变化<br> -s 附加次级信息</td></tr><tr><td align="center">create</td><td align="left">普通创建<br> -s 含有序列<br> -e 临时（重启或者超时消失）</td></tr><tr><td align="center">get [path]</td><td align="left">获得节点的值 [可监听]<br/> -w 监听子节点变化<br/> -s 附加次级信息</td></tr><tr><td align="center">set</td><td align="left">设置节点的具体值</td></tr><tr><td align="center">stat</td><td align="left">查看节点状态</td></tr><tr><td align="center">delete</td><td align="left">删除节点</td></tr><tr><td align="center">deleteall</td><td align="left">递归删除节点</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建临时目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /test</span><br><span class="line">Created /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] <span class="built_in">ls</span> -s /</span><br><span class="line">[<span class="built_in">test</span>, zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0xd</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure><ul><li><strong>cZxid</strong>：创建节点的事务 zxid</li><li>ctime：znode 被创建的毫秒数（从 1970 年开始）</li><li>mzxid：znode 最后更新的事务 zxid</li><li>mtime：znode 最后修改的毫秒数（从 1970 年开始）</li><li>pZxid：znode 最后更新的子节点 zxid</li><li>cversion：znode 子节点变化号，znode 子节点修改次数</li><li><strong>dataversion</strong>：znode 数据变化号</li><li>aclVersion：znode 访问控制列表的变化号</li><li>ephemeralOwner：如果是临时节点，这个是 znode 拥有者的 session id。如果不是 临时节点则是 0。</li><li><strong>dataLength</strong>：znode 的数据长度</li><li><strong>numChildren</strong>：znode 子节点数量</li></ul><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>Zookeeper中的节点分为两种类型：</p><ul><li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除<ul><li>持久化目录节点</li><li>持久化顺序编号目录节点</li></ul></li><li>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除<ul><li>临时目录节点</li><li>临时顺序编号目录节点</li></ul></li></ul><blockquote><p>创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护</p><p><strong>临时节点不能有孩子节点</strong></p></blockquote><p>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建永久节点（不带序号）</span></span><br><span class="line">create /test</span><br><span class="line"><span class="comment">#创建节点+绑定数据</span></span><br><span class="line">create /test/city <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"><span class="comment">#获取节点数据</span></span><br><span class="line">get /test/city</span><br><span class="line"><span class="comment">#修改节点数据</span></span><br><span class="line"><span class="built_in">set</span> /test/city <span class="string">&quot;wuhan&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>节点只能绑定一个数据</p><p>简单理解： <code>路径：数据</code>相当于Java中Map的<code>Key：Value</code></p></blockquote><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>Zookeeper中内置两种监听指令：</p><ul><li><code>get -w [path]</code>：监听节点数据的变化</li><li><code>ls -w [path]</code>：监听子节点增减的变化</li></ul><p>原理：</p><ol><li>客户端创建main()线程</li><li>在main线程中连接zookeeper客户端，再创建两个线程，一个负责网络连接(connet)，一个负责监听(listener)</li><li>通过connet线程将注册的监听事件发送给Zookeeper</li><li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中</li><li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程</li><li>listener线程内部调用了process()方法</li></ol><p>注意：调用一次监听指令(get&#x2F;ls)只能监听一次变化</p><h2 id="Java客户端调用"><a href="#Java客户端调用" class="headerlink" title="Java客户端调用"></a>Java客户端调用</h2><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实践：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="comment">// 集群可以使用,分隔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.124.105:2181&quot;</span>;</span><br><span class="line">    <span class="comment">// 时间太短的话打断点会断开连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sessionTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ZookeeperTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperTest</span>();</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        test.connect();</span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        System.out.println(test.create(<span class="string">&quot;/servers&quot;</span>, <span class="string">&quot;hello&quot;</span>.getBytes()));</span><br><span class="line">        <span class="comment">// 获取节点</span></span><br><span class="line">        System.out.println(test.getList(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置节点数据</span></span><br><span class="line">        System.out.println(test.setData(<span class="string">&quot;/servers&quot;</span>, <span class="string">&quot;hi&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取节点数据</span></span><br><span class="line">        System.out.println(test.getData(<span class="string">&quot;/servers&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        test.delNode(<span class="string">&quot;/servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getList(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        test.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        zk.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(String path)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">        zk.delete(path, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getData</span><span class="params">(String path)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(zk.getData(path, <span class="literal">false</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stat <span class="title function_">setData</span><span class="params">(String path, String data)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">        <span class="comment">// 这里的version是实现乐观锁的版本号，当版本号不匹配就不能成功更新</span></span><br><span class="line">        <span class="comment">// 设置-1表示忽略版本号直接更新</span></span><br><span class="line">        <span class="keyword">return</span> zk.setData(path, data.getBytes(), -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getList</span><span class="params">(String path)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">        <span class="keyword">return</span> zk.getChildren(path, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">create</span><span class="params">(String path, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">        <span class="comment">// 第三个参数表示权限控制，这里设置所有人都能操作</span></span><br><span class="line">        <span class="comment">// 第四个参数表示生成模式，这里使用的是临时非有序</span></span><br><span class="line">        <span class="keyword">return</span> zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTime, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;===========监听记录============&quot;</span>);</span><br><span class="line">                System.out.println(watchedEvent.getPath());</span><br><span class="line">                System.out.println(watchedEvent.getState());</span><br><span class="line">                System.out.println(watchedEvent.getType());</span><br><span class="line">                System.out.println(watchedEvent.getWrapper());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// true表示使用默认的Watcher</span></span><br><span class="line">                    System.out.println(zk.getChildren(<span class="string">&quot;/&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;===========监听结束============&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实创建节点就相当于在Zookeeper中注册，当连接断开就表示服务停止了。</p></blockquote><h3 id="分布式锁案例"><a href="#分布式锁案例" class="headerlink" title="分布式锁案例"></a>分布式锁案例</h3><p>手动实现分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.124.105:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sessionTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> String current;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">watchNode</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">connect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZookeeperLock</span><span class="params">()</span> &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTime, (watchedEvent) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getState().equals(Watcher.Event.KeeperState.SyncConnected)) &#123;</span><br><span class="line">                    connect.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getPath().equals(watchNode) &amp;&amp; watchedEvent.getType().equals(Watcher.Event.EventType.NodeDeleted)) &#123;</span><br><span class="line">                    wait.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 确保成功连接Zookeeper</span></span><br><span class="line">            connect.await();</span><br><span class="line">            <span class="type">Stat</span> <span class="variable">exists</span> <span class="operator">=</span> zk.exists(<span class="string">&quot;/locks&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (exists == <span class="literal">null</span>) &#123;</span><br><span class="line">                zk.create(<span class="string">&quot;/locks&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        current = zk.create(<span class="string">&quot;/locks/task&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        List&lt;String&gt; children = zk.getChildren(<span class="string">&quot;/locks&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (children.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到需要监听的节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> Long.parseLong(current.substring(<span class="string">&quot;/locks/task&quot;</span>.length()));</span><br><span class="line">        <span class="keyword">for</span> (String temp : children) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">watch</span> <span class="operator">=</span> Long.parseLong(temp.substring(<span class="string">&quot;/task&quot;</span>.length()));</span><br><span class="line">            <span class="keyword">if</span> (watch &lt; cur) &#123;</span><br><span class="line">                watchNode = <span class="string">&quot;/locks/&quot;</span> + temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(watchNode, <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zk.getData(watchNode, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 确保监听完成</span></span><br><span class="line">        wait.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        zk.delete(current, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZookeeperLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperLock</span>();</span><br><span class="line">        <span class="type">ZookeeperLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1上锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1解锁&quot;</span>);</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2上锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2解锁&quot;</span>);</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h4><p>原生JavaAPI开发存在的问题：</p><ol><li>会话连接是异步的，需要自己去处理。比如使用 CountDownLatch</li><li>Watch 需要重复注册，不然就不能生效</li><li>不支持多节点删除和创建</li></ol><p>Curator 是一个专门解决分布式锁的框架，解决了原生 JavaAPI 开发分布式遇到的问题。</p><p>官方文档：<a href="https://curator.apache.org/docs/about">Welcome to Apache Curator | Apache Curator</a></p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Zookeeper 实现分布式锁的场景并不多，这里仅提供一个简单例子作为使用参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> </span><br><span class="line">    org.apache.curator.framework.recipes.locks.InterProcessLock;</span><br><span class="line"><span class="keyword">import</span> </span><br><span class="line">    org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">rootNode</span> <span class="operator">=</span> <span class="string">&quot;/locks&quot;</span>;</span><br><span class="line">    <span class="comment">// zookeeper server 列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;</span><br><span class="line">    <span class="comment">// connection 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectionTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// session 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CuratorLockTest</span>().test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分布式锁 1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InterProcessLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), rootNode);</span><br><span class="line">        <span class="comment">// 创建分布式锁 2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InterProcessLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), rootNode);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁对象</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 1 获取锁&quot;</span>);</span><br><span class="line">                    <span class="comment">// 测试锁重入</span></span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 1 再次获取锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 1 释放锁&quot;</span>);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 1 再次释放锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁对象</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock2.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2 获取锁&quot;</span>);</span><br><span class="line">                    <span class="comment">// 测试锁重入</span></span><br><span class="line">                    lock2.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2 再次获取锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    lock2.release();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2 释放锁&quot;</span>);</span><br><span class="line">                    lock2.release();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2 再次释放锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分布式锁初始化</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework <span class="title function_">getCuratorFramework</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重试策略，初试时间 3 秒，重试 3 次</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//通过工厂创建 Curator</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> </span><br><span class="line">            CuratorFrameworkFactory.builder()</span><br><span class="line">            .connectString(connectString)</span><br><span class="line">            .connectionTimeoutMs(connectionTimeout)</span><br><span class="line">            .sessionTimeoutMs(sessionTimeout)</span><br><span class="line">            .retryPolicy(policy).build();</span><br><span class="line">        <span class="comment">//开启连接</span></span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;zookeeper 初始化完成...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单测试了一下可重入锁的实现</p></blockquote><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>继续学习：<a href="https://www.bilibili.com/video/BV1to4y1C7gw/?p=30&spm_id_from=pageDriver&vd_source=3acac9cf7f1674a7677cd0687f9b24c8">30_尚硅谷_zk_算法基础_拜占庭将军问题_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第七章</title>
      <link href="/2023/12/18/Redis/7.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2023/12/18/Redis/7.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>分布式锁是控制分布式系统间同步访问共享资源的一种方式，其可以保证共享资源在并发场景下的数据一致性。</p><p>工作原理：</p><p>为了达到同步访问的目的，规定，让这些线程在访问共享资源之前先要获取到一个令牌 token，只有具有令牌的线程才可以访问共享资源。这个令牌就是通过各种技术实现的分布式锁。而这个分布锁是一种“互斥资源”，即只有一个。只要有线程抢到了锁，那么其它线程只能等待，直到锁被释放或等待超时。</p><p>实现：像 Redis 中的 setnx，数据库中创建相同主键都可以达到目的，删除即可释放</p><h2 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Seckill</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate srt;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sk</span><span class="params">()</span>&#123;</span><br><span class="line">        String stock=srt.opsForValue().get(<span class="string">&quot;commodity&quot;</span>);</span><br><span class="line">        <span class="type">int</span> amount=stock==<span class="literal">null</span>?<span class="number">0</span>:Integer.parseInt(stock);</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            srt.opsForValue().set(<span class="string">&quot;commodity&quot;</span>,--amount+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;库存：&quot;</span>+amount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抱歉，您没抢到&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在商品秒杀背景下，一定会存在很多用户同时读取 Redis 缓存中的 commodity 这个 key，那么大家读取到的 value 很可能是相同的，均可购买，此时就会出现“超卖”</p><p>我们可以使用 synchronized () 上锁，但如果服务器不止一台，锁便会失效（每个服务器都会带一个锁）</p><p>此时我们便可以使用分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sk1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sk1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> srt.opsForValue().setIfAbsent(<span class="string">&quot;Lock&quot;</span>, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!lock)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没抢到锁&quot;</span>;</span><br><span class="line">        String stock=srt.opsForValue().get(<span class="string">&quot;commodity&quot;</span>);</span><br><span class="line">        <span class="type">int</span> amount=stock==<span class="literal">null</span>?<span class="number">0</span>:Integer.parseInt(stock);</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            srt.opsForValue().set(<span class="string">&quot;commodity&quot;</span>,--amount+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;库存：&quot;</span>+amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        srt.delete(<span class="string">&quot;Lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抱歉，您没抢到&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时又会产生新的问题：如果添加完锁后宕机，那么服务器会因为锁的存在永久阻塞</p><p>我们可以为锁添加过期时间，同时为了避免业务没执行完锁就过期导致最终误删其他请求的锁，我们可以为锁添加标识</p><p>为了实现这个效果，为每个申请锁的客户端随机生成一个 UUID，使用这个 UUID 作为该客户端标识，然后将该 UUID 作为该客户端申请到的锁的 value。在删除锁时，只有在发起当前删除操作的客户端的 UUID 与锁的 value 相同时才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sk2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sk2</span><span class="params">()</span>&#123;</span><br><span class="line">    String uuid= UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> srt.opsForValue().setIfAbsent(<span class="string">&quot;Lock&quot;</span>, uuid,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span>(!lock)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没抢到锁&quot;</span>;</span><br><span class="line">        String stock=srt.opsForValue().get(<span class="string">&quot;commodity&quot;</span>);</span><br><span class="line">        <span class="type">int</span> amount=stock==<span class="literal">null</span>?<span class="number">0</span>:Integer.parseInt(stock);</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            srt.opsForValue().set(<span class="string">&quot;commodity&quot;</span>,--amount+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;库存：&quot;</span>+amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(srt.opsForValue().get(<span class="string">&quot;Lock&quot;</span>).equals(uuid))</span><br><span class="line">            srt.delete(<span class="string">&quot;Lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抱歉，您没抢到&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但删除与判断操作不具备原子性，有可能判断成功时恰好key过期，也会导致误删，此时我们可以使用Lua脚本来实现原子性的操作</p><p>Redis 中提供了执行Lua脚本的命令 <strong>eval</strong>，eval 命令在 RedisTemplate 中没有对应的方法，我们需要使用 Jedis 客户端</p><p>eval 语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval script numkeys [key [key...]] [arg [arg...]]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172744.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172744.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d9e9181ba7826ad5b8013023fd4b30d9.png"></p><blockquote><p>Lua 中使用<code>redis.call</code>可以调用 redis 命令</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String redisHost;</span><br><span class="line"><span class="meta">@value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String redisPort;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    JedisPool jedisPool=<span class="keyword">new</span> <span class="title class_">JedisPool</span>(redisHost,redisPort);</span><br><span class="line">    <span class="keyword">try</span>(Jedis jedis=jedisPool.getResource())&#123;</span><br><span class="line">        String script=<span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] &quot;</span>+</span><br><span class="line">            <span class="string">&quot;then return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span>+</span><br><span class="line">            <span class="string">&quot;return 0 &quot;</span>+</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        Object eval=jedis.eval(script,Collections.singletonList(<span class="string">&quot;Lock&quot;</span>),Collections.singletonList(uuid));</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(eval.toString()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码仍然是存在问题的：请求 a 的锁过期，但其业务还未执行完毕；请求 b 申请到了锁，其也正在处理业务。如果此时两个请求都同时修改了共享的库存数据，那么就又会出现数据不一致的问题。</p><p>我们可以采用 “锁续约” 方式解决：在当前业务进程开始执行时，fork 出 一个子进程，用于启动一个定时任务。该定时任务的定时时间小于锁的过期时间，其会定时查看处理当前请求的业务进程的锁是否已被删除。</p><h2 id="Redisson-可重入锁"><a href="#Redisson-可重入锁" class="headerlink" title="Redisson 可重入锁"></a>Redisson 可重入锁</h2><p>Redisson 内部使用 Lua 脚本实现了对可重入锁的添加、重入、续约（续命）、释放。Redisson 需要用户为锁指定一个 key，但无需为锁指定过期时间，因为它有默认过期时间(也可指定)。由于该锁具有“可重入”功能，所以 Redisson 会为该锁生成一个计数器，记录一个线程重入锁的次数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加一个由单 Redis 节点构建的 Redisson 的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String redisHost;</span><br><span class="line"><span class="meta">@value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String redisPort;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Redisson <span class="title function_">redisson</span><span class="params">()</span>&#123;</span><br><span class="line">    Config config=<span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    config.useSingleServer()</span><br><span class="line">        .setAddress(redisHost+<span class="string">&quot;:&quot;</span>+redisPort)</span><br><span class="line">        .setDataBase(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (Redission) Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/sk3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sk3</span><span class="params">()</span>&#123;</span><br><span class="line">    RLock rLock=redisson.getLock(<span class="string">&quot;Lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> rLock.tryLock();</span><br><span class="line">        <span class="keyword">if</span>(!lock)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没抢到锁&quot;</span>;</span><br><span class="line">        String stock=srt.opsForValue().get(<span class="string">&quot;commodity&quot;</span>);</span><br><span class="line">        <span class="type">int</span> amount=stock==<span class="literal">null</span>?<span class="number">0</span>:Integer.parseInt(stock);</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            srt.opsForValue().set(<span class="string">&quot;commodity&quot;</span>,--amount+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;库存：&quot;</span>+amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抱歉，您没抢到&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Redis 单机情况下，以上代码是没有问题的。但如果是在 Redis 主从集群中，那么其还存在锁丢失问题：master响应了应用服务器，但在同步前宕机，新master中没有key会再释放一个请求造成并发问题</p><p>因为主从集群丢失了一次锁申请，该问题称为主从集群的锁丢失问题。</p><h2 id="Redisson-红锁"><a href="#Redisson-红锁" class="headerlink" title="Redisson 红锁"></a>Redisson 红锁</h2><p>Redisson 红锁可以防止主从集群锁丢失问题。Redisson 红锁要求，必须要构建出至少三个 Redis 主从集群。若一个请求要申请锁，必须向所有主从集群中提交 key 写入请求，只有当大多数集群锁写入成功后，该锁才算申请成功。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172752.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172752.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="da32ce04a44155b619f02568d88918e9.png"></p><p>无论前面使用的是哪种锁，都是将所有请求通过锁实现串行化。而串行化在高并发场景下势必会引发性能问题。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>无论前面使用的是哪种锁，它们解决并发问题的思路都是相同的，那就将所有请求通过锁实现串行化。而串行化在高并发场景下势必会引发性能问题。</p><p>例如秒杀商品1000件，分成10份，分别为 sk:01，sk:02，sk:03 … sk:0008:10。 这样的话，就需要 10 把锁来控制所有请求的并发。</p><h2 id="Redisson-详解"><a href="#Redisson-详解" class="headerlink" title="Redisson 详解"></a>Redisson 详解</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。</p><p>Redisson 底层采用的是 Netty 框架。Redisson 官网：<a href="https://redisson.org/">https://redisson.org/</a></p><p>在生产中，对于 Redisson 使用最多的场景就是其分布式锁 RLock。</p><p>为了避免锁到期但业务逻辑没有执行完毕而引发的多个线程同时访问共享资源的情况发生，Redisson 内部为锁提供了一个监控锁的看门狗 watch dog，其会在锁到期前不断延长锁的到期时间，直到锁被主动释放。即会自动完成“锁续命”。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>Redisson 的分布式锁 RLock 是一种可重入锁。当一个线程获取到锁之后，这个线程可以再次获取本对象上的锁，而其他的线程不可以。</p><ul><li>JDK 中的 ReentrantLock 是可重入锁，其是通过 AQS(抽象队列同步器)实现的锁机制</li><li>JDK 中的 ReentrantLock 是可重入锁，其是通过 AQS(抽象队列同步器)实现的锁机制</li></ul><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>当有多个线程同时申请锁时，这些线程会进入到一个 FIFO 队列，只有队首元素才会获取到锁，其它元素等待。只有当锁被释放后，才会再将锁分配给当前的队首元素。</p><p>Redisson 的可重入锁 RLock 默认是一种非公平锁，但也支持可重入公平锁 FailLock。</p><h3 id="联锁"><a href="#联锁" class="headerlink" title="联锁"></a>联锁</h3><p>Redisson 分布式锁可以实现联锁 MultiLock。当一个线程需要同时处理多个共享资源时，可使用联锁。即一次性申请多个锁，同时锁定多个共享资源。联锁可预防死锁。相当于对共享资源的申请实现了原子性：要么都申请到，只要缺少一个资源，则将申请到的所有资源全部释放。其是 OS 底层原理中 AND 型信号量机制的典型应用。</p><h3 id="红锁"><a href="#红锁" class="headerlink" title="红锁"></a>红锁</h3><p>Redisson 分布式锁可以实现红锁 RedLock。红锁由多个锁构成，只有当这些锁中的大部分锁申请成功时，红锁才申请成功。红锁一般用于解决 Redis 主从集群锁丢失问题。</p><p>红锁与联锁的区别是，红锁实现的是对一个共享资源的同步访问控制，而联锁实现的是多个共享资源的同步访问控制。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>通过 Redisson 可以获取到读写锁 RReadWriteLock。通过 RReadWriteLock 实例可分别获取到读锁 RedissonReadLock 与写锁 RedissonWriteLock。读锁与写锁分别是实现了 RLock 的可重入锁。</p><p>一个共享资源，在没有写锁的情况下，允许同时添加多个读锁。只要添加了写锁，任何读锁与写锁都不能再次添加。即读锁是共享锁，写锁为排他锁。</p><p>这个和操作系统知识关联较大</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>通过Redisson可以获取到信号量RSemaphore。RSemaphore的常用场景有两种：无论谁添加的锁，任何其它线程都可以解锁，就可以使用 RSemaphore。另外，当一个线程需要一次申请多个资源时，可使用 RSemaphore。RSemaphore 是信号量机制的典型应用。</p><p>和操作系统知识关联较大</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172831.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172831.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d251cb4dd1c55f1a135fef16ff3ee728.png"></p><h3 id="可过期信号量"><a href="#可过期信号量" class="headerlink" title="可过期信号量"></a>可过期信号量</h3><p>通过 Redisson 可以获取到可过期信号量 PermitExpirableSemaphore。该信号量是在 RSemaphore 基础上，为每个信号增加了一个过期时间，且每个信号都可以通过独立的 ID 来辨识。释放时也只能通过提交该 ID 才能释放。</p><p>与 RSemaphore 不同：一个线程每次只能申请一个信号量</p><p>该信号量为互斥信号量时，其就等同于可重入锁。或者说，可重入锁就相当于信号量为 1 的可过期信号量。</p><p>可过期信号量与可重入锁的区别：</p><ul><li>可重入锁：相当于用户每次只能申请 1 个信号量，且只有一个用户可以申请成功</li><li>可过期信号量：用户每次只能申请 1 个信号量，但可以有多个用户申请成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172852.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172852.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="17e83f62847f9eeb8510b81ea932e907.png"></p><h3 id="分布式闭锁"><a href="#分布式闭锁" class="headerlink" title="分布式闭锁"></a>分布式闭锁</h3><p>通过 Redisson 可以获取到分布式闭锁 RCountDownLatch，其与 JDK 的 JUC 中的闭锁 CountDownLatch 原理相同，用法类似。其常用于一个或者多个线程的执行必须在其它某些任务执行完毕的场景。</p><p>闭锁中定义了一个计数器和一个阻塞队列。阻塞队列中存放着待执行的线程。每当一个并行任务执行完毕，计数器就减 1。当计数器递减到 0 时就会唤醒阻塞队列的所有线程。</p><p>通常使用 Barrier 队列解决该问题，而 Barrier 队列通常使用 Zookeeper 实现</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172919.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172919.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="137bbecb7c0004c331b7878d1554cb74.png"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第六章</title>
      <link href="/2023/12/18/Redis/6.Lua%20%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/12/18/Redis/6.Lua%20%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lua 是一个由标准 C 语言开发的、开源的、可扩展的、轻量级的、弱类型的、解释型脚本语言。官网：<a href="https://www.lua.org/">The Programming Language Lua</a></p><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><p>CentOS7 中自带 Lua ：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171944.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171944.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="df968885da161258d077acdba147663e.png"></p><p>使用高版本的Lua需要安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#解压Lua源码</span><br><span class="line">tar -zxvf lua-5.4.4.tar.gz -C /opt/apps/</span><br><span class="line">#进入Lua的解压目录准备编译环境</span><br><span class="line">yum -y install gcc gcc-c++</span><br><span class="line">#编译</span><br><span class="line">make linux test</span><br><span class="line">#安装</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>重启后便能使用新版本的Lua</p><blockquote><p>lua -v 可以查看Lua版本</p></blockquote><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>Lua 为用户提供了两种交互模式：命令行模式与脚本文件模式。</p><h4 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h4><p>在任意目录下使用 lua 命令进入 lua 命令行模式，在其中输入语句后回车即可运行显示出结果。使用 Ctrl + C 退出模式。</p><p>lua 对语句后的分号要求不是强制性的，有没有都行。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171950.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171950.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6e4784bd08dae341f68b32bf771e9839.png"></p><h4 id="脚本文件模式："><a href="#脚本文件模式：" class="headerlink" title="脚本文件模式："></a>脚本文件模式：</h4><p>该模式是先要编写脚本文件，然后再使用 lua 命令来运行文件。</p><p>创建 hello.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello lua&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行：<code>lua hello.lua</code></p><p>运行方式二：</p><p>在脚本文件第一行增加<code>#!/usr/bin/lua</code>，表示当前文件将使用 lua  命令运行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/lua</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello lua&quot;</span>);</span><br></pre></td></tr></table></figure><p>修改文件执行权限即可运行，类似 shell 脚本</p><h2 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h2><p>在 Windows 系统中 Lua 的运行环境。最常用的为 SciTE。</p><p>SciTE 是一款 Lua 脚本测试编辑器，提供 Lua 的编辑运行环境。官方下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases">Releases · rjpcomputing&#x2F;luaforwindows · GitHub</a></p><h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>Lua 的行注释为两个连续的减号，段注释以 –[[ 开头，以 –]] 结尾。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Lua 中有 8 种类型，分别为：nil、boolean、number、string、userdata、function、thread  和 table。通过 type()函数可以查看一个数据的类型</p><table><thead><tr><th align="center">数据类型</th><th>描述</th></tr></thead><tbody><tr><td align="center">nil</td><td>只有值 nil 属于该类，表示一个无效值，与 Java 中的 null 类似。但在条件表达式中相当于 false。</td></tr><tr><td align="center">boolean</td><td>包含两个值：false 和 true。</td></tr><tr><td align="center">number</td><td>表示双精度类型的实浮点数。</td></tr><tr><td align="center">string</td><td>字符串，由一对双引号或单引号括起来。当一个字符串包含多行时，可以在第一行中以[[开头，在最后一行中以]]结尾，那么在[[与]]括起来的这多行内容就是一个字符串。换行符为字符串”\n”。</td></tr><tr><td align="center">table</td><td>类似于 Java 中的数组，但比数组的功能更强大，更灵活。</td></tr><tr><td align="center">function</td><td>由 C 或 Lua 编写的函数。</td></tr><tr><td align="center">thread</td><td>协同线程，是协同函数的执行体，即正在执行的协同函数。</td></tr><tr><td align="center">userdata</td><td>一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据存储到 Lua 变量中调用。</td></tr></tbody></table><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>程序设计语言中的标识符主要包含保留字、变量、常量、方法名、函数名、类名等。Lua 的标识符由字母、数字与下划线组成，但不能以数字开头。Lua 是大小写敏感的。</p><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>Lua 常见的保留字共有 22 个。除了这 22 个外，Lua 中还定义了很多的内置全局变量，这些内置全局变量的一个共同特征是，以下划线开头后跟全大写字母。我们在定义自己的标识符时不能与这些保留字、内置全局变量重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">andbreakdoelse</span><br><span class="line">elseifendfalsefor</span><br><span class="line">functionifinlocal</span><br><span class="line">nil notorrepeat</span><br><span class="line">returnthentrueuntil</span><br><span class="line">while goto</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Lua 是弱类型语言，变量无需类型声明即可直接使用。</p><p>变量分为全局变量与局部变量。Lua 中的变量默认都是全局变量，即使声明在语句块或函数里。全局变量一旦声明，在当前文件中的任何地方都可访问。</p><p>局部变量 local 相当于 Java 中的 private 变量，只能在声明的语句块中 使用。</p><p>Lua 是动态类型语言，变量的类型可以随时改变，无需声明。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th align="center">操作符</th><th>描述</th></tr></thead><tbody><tr><td align="center">+</td><td>加法</td></tr><tr><td align="center">-</td><td>减法</td></tr><tr><td align="center">*</td><td>乘法</td></tr><tr><td align="center">&#x2F;</td><td>除法</td></tr><tr><td align="center">%</td><td>取余</td></tr><tr><td align="center">^</td><td>乘幂</td></tr><tr><td align="center">-</td><td>负号</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td>整除运算（&gt;&#x3D;lua5.3）</td></tr></tbody></table><blockquote><p><code>5/2=2.5; 5//2=2</code></p></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="center">操作符</th><th>描述</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td>等于</td></tr><tr><td align="center">~&#x3D;</td><td>不等于</td></tr><tr><td align="center">&gt;</td><td>大于</td></tr><tr><td align="center">&lt;</td><td>小于</td></tr><tr><td align="center">&gt;&#x3D;</td><td>大于等于</td></tr><tr><td align="center">&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Lua 系统将 false 与 nil 作为假，将 true 与非 nil 作为真，即使是 0 也是真。</p><table><thead><tr><th align="center">操作符</th><th>描述</th></tr></thead><tbody><tr><td align="center">and</td><td>逻辑与</td></tr><tr><td align="center">or</td><td>逻辑或</td></tr><tr><td align="center">not</td><td>逻辑非</td></tr></tbody></table><h3 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h3><table><thead><tr><th align="center">操作符</th><th>描述</th></tr></thead><tbody><tr><td align="center">..(两个点)</td><td>字符串连接符</td></tr><tr><td align="center">#</td><td>返回字符串或表的长度</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Lua 中函数的定义是以 function 开头，后跟函数名与参数列表，以 end 结尾。其可以没有返回值，也可以一次返回多个值。</p><ol><li>固定参函数</li></ol><p>Lua 中的函数在调用时不要求实参的个数必须与函数中形参的个数同。如果实参个数少于形参个数，则系统自动使用 nil 填充；如果实参个数多于形参个数，多出的将被系统自动忽略。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/ae95dfa12faa0c1b97beb371cd9b2209.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/ae95dfa12faa0c1b97beb371cd9b2209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ae95dfa12faa0c1b97beb371cd9b2209.png"></p><ol start="2"><li>可变参函数</li></ol><p>在函数定义时不给出具体形参的个数，而是使用三个连续的点号。在函数调用时就可以向该函数传递任意个数的参数，函数可以全部接收。</p><ol start="3"><li>可返回多个值</li></ol><p>Lua 中的函数一次可以返回多个值，但需要有多个变量来同时接收。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171959.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171959.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="033a1faed42736b9ce1ff706c12666d6.png"></p><ol start="4"><li>函数作为参数</li></ol><p>Lua 的函数中，允许函数作为参数。而作为参数的函数，可以是已经定义好的普通函数，也可以是匿名函数。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>Lua 提供了 if…then 用于表示条件判断，其中 if 的判断条件可以是任意表达式。</p><p>Lua 中的 if 语句的判断条件可以使用小括号括起来，也可以不使用。</p><p>Lua 中提供了专门的关键字 elseif 来做 if 嵌套语句。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172007.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e154464edc36890d2567ddf82ea37132.png"></p><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>Lua 提供了四种循环控制语句：while…do 循环、repeat…until 循环、数值 for 循环，及泛型 for 循环。同时，Lua 还提供了 break 与 goto 两种循环流程控制语句。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/9d1ed5ffda6f4f5436aad7d640630744.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/9d1ed5ffda6f4f5436aad7d640630744.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9d1ed5ffda6f4f5436aad7d640630744.png"></p><p>其中 for 循环只参用于循环变量为数值型的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其语法格式为：</span><br><span class="line">for var=exp1, exp2, exp3 do</span><br><span class="line"> 循环体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>var 为指定的循环变量，exp1 为循环起始值，exp2 为循环结束值，exp3 为循环步长。 步长默认为 1，可省略。</p><ul><li>泛型 for</li></ul><p>泛型 for 用于遍历 table 中的所有值，其需要与 Lua 的迭代器联合使用。</p><ul><li>break</li></ul><p>break 语句可以提前终止循环，只能用于循环之中。</p><ul><li>goto</li></ul><p>goto 语句可以将执行流程无条件地跳转到指定的标记语句处开始执行</p><p>语句标记使用一对双冒号括起来，置于语句前面。goto 语句可以使用在循环之外。 注意，Lua5.1 中不支持双冒号的语句标记。</p><p>该语法不建议使用</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172051.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172051.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="31fd63711e58bad4873f8415f27bc347.png"></p><h1 id="语法进阶"><a href="#语法进阶" class="headerlink" title="语法进阶"></a>语法进阶</h1><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用 table 可以定义一维、二维、多维数组。Lua 中的数组索引是从 1 开始的，且无需声明数组长度，可以随时增加元素。当然，同一数组中的元素可以是任意类型。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172058.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172058.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4abc6878d630643c734767174f5bb9d0.png"></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>使用 table 也可以定义出类似 map 的 key-value 数据结构。其可以定义 table 时直接指定 key-value，也可单独指定 key-value。而访问时，一般都是通过 table 的 key 直接访问，也可以数组索引方式来访问，此时的 key 即为索引。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172130.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172130.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4bed0658e87155a719862ec9c79241bc.png"></p><h3 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h3><p>Lua 允许将数组与 key-value 混合在同一个 table 中进行定义。key-value 不会占用数组的数字索引值。</p><h2 id="table-操作函数"><a href="#table-操作函数" class="headerlink" title="table 操作函数"></a>table 操作函数</h2><p>Lua 中提供了对 table 进行操作的函数。</p><ul><li>table.concat()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.concat (table [, sep [, start [, end]]])</span><br></pre></td></tr></table></figure><p>该函数用于将指定的 table 数组元素进行字符串连接。连接从 start 索引位置到 end 索引位置的所有数组元素, 元素间使用指定的分隔符 sep 隔开。如果 table 是一个混合结构，那么仅是连接数组元素。</p><ul><li>table.unpack()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.unpack (table [, i [, j]])</span><br></pre></td></tr></table></figure><p>该函数返回指定 table 的数组中的从第 i 个元素到第 j 个元素值。i 与 j 是可选的，默认 i 为 1，j 为数组的最后一个元素。Lua5.1 不支持该函数。</p><ul><li>table.pack()</li></ul><p>该函数的参数是一个可变参，其可将指定的参数打包为一个 table 返回。这个返回的 table 中具有一个属性 n，用于表示该 table 包含的元素个数。Lua5.1 不支持该函数。</p><ul><li>table.maxn()</li></ul><p><code>table.maxn(table)</code></p><p>该函数返回指定 table 的数组中的最大索引值，即数组包含元素的个数。</p><ul><li>table.insert()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.insert (table, [pos,] value)</span><br></pre></td></tr></table></figure><p>该函数用于在指定 table 的数组部分指定位置 pos 插入值为 value 的一个元素。其后的元素会被后移。pos 参数可选，默认为数组部分末尾。</p><ul><li>table.remove ()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.remove (table [, pos])</span><br></pre></td></tr></table></figure><p>该函数用于删除并返回指定 table 中数组部分位于 pos 位置的元素。其后的元素会被前移。pos 参数可选，默认删除数组中的最后一个元素。</p><ul><li>table.sort()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.sort(table [,fun(a,b)])</span><br></pre></td></tr></table></figure><p>该函数用于对指定的 table 的数组元素进行升序排序，也可按照指定函数 fun(a,b) 中指定的规则进行排序。fun(a,b)是一个用于比较 a 与 b 的函数，a 与 b 分别代表数组中的两个相邻元素。</p><ul><li>如果 arr 中的元素既有字符串又有数值型，那么对其进行排序会报错。</li><li>如果数组中多个元素相同，则其相同的多个元素的排序结果不确定</li><li>如果数组元素中包含 nil，则排序会报错。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Lua 提供了两个迭代器 pairs(table)与 ipairs(table)。这两个迭代器通常会应用于泛型 for 循环中，用于遍历指定的 table。</p><ul><li>ipairs(table)：仅会迭代指定 table 中的数组元素。</li><li>pairs(table)：会迭代整个 table 元素，无论是数组元素，还是 key-value。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172148.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172148.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2b125b87dc279ed3c0effc0539065a54.png"></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是Lua中特有的一种数据结构。从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p><p>模块文件主要由 table 组成。在 table 中添加相应的变量、函数，最后文件返回该 table 即可。如果其它文件中需要使用该模块，只需通过 require 将该模块导入即可。</p><ol><li>定义模块</li></ol><p>模块是一个 lua 文件，其中会包含一个 table。一般情况下该文件名与该 table 名称相同，但其并不是必须的。</p><ol start="2"><li>使用模块</li></ol><p>require(“文件路径”)，其中文件名是不能写.lua 扩展名的。该函数可以将指定的 lua 文件静态导入（合并为一个文件）。该函数的使用可 以省略小括号，写为 require “文件路径”。</p><p>require()函数是有返回值的，返回的就是模块文件最后 return 的 table。可以使用一个变量接收该 table 值作为模块的别名，就可以使用别名来访问模块了。</p><h3 id="元表与元方法"><a href="#元表与元方法" class="headerlink" title="元表与元方法"></a>元表与元方法</h3><p>元表，即 Lua 中普通 table 的元数据表，而元方法则是元表中定义的普通表的默认行为。Lua 中的每个普通 table 都可为其定义一个元表，用于扩展该普通 table 的行为功能。</p><p>元表中有两个重要函数：</p><ul><li>setmetatable(table,metatable)：将 metatable 指定为普通表 table 的元表。</li><li>getmetatable(table)：获取指定普通表 table 的元表。</li></ul><h4 id="元方法"><a href="#元方法" class="headerlink" title="元方法"></a>元方法</h4><ul><li>_ _index</li></ul><p>当用户在对 table 进行读取访问时，如果访问的数组索引或 key 不存在，那么系统就会<br>自动调用元表的_ _index 元方法。该重写的方法可以是一个函数，也可以是另一个表。如果重写的_ _index 元方法是函数，且有返回值，则直接返回；如果没有返回值，则返回 nil。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172154.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172154.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f76bdc8c6197b4c7c61eabc143739129.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172156.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172156.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7fe41de0916ede6dde6cfe53d48a50e9.png"></p><ul><li>_ _newindex</li></ul><p>当用户为 table 中一个不存在的索引或 key 赋值时，就会自动调用元表的_ _newindex 元方法。该重写的方法可以是一个函数，也可以是另一个表。如果重写的_ _newindex 元方法是函数，且有返回值，则直接返回；如果没有返回值，则返回 nil。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172215.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5be037635f0f0580fe1dcfe7d3f9f1a6.png"></p><ul><li>运算符元方法</li></ul><p>如果要为一个表扩展加号(+)、减号(-)、等于(&#x3D;&#x3D;)、小于(&lt;)等运算功能，则可重写相应的元方法。</p><table><thead><tr><th align="center">元方法</th><th>说明</th><th align="center">元方法</th><th>说明</th></tr></thead><tbody><tr><td align="center">__add</td><td>加法，+</td><td align="center">__band</td><td>按位与，&amp;</td></tr><tr><td align="center">__sub</td><td>减法，-</td><td align="center">__bor</td><td>按位或，|</td></tr><tr><td align="center">__mul</td><td>乘法，*</td><td align="center">__bxor</td><td>按位异或，~</td></tr><tr><td align="center">__div</td><td>除法，&#x2F;</td><td align="center">__bnot</td><td>按位非，~</td></tr><tr><td align="center">__mod</td><td>取模，%</td><td align="center">__shl</td><td>按位左移，&lt;&lt;</td></tr><tr><td align="center">__pow</td><td>次幂，^</td><td align="center">__shr</td><td>按位右移，&gt;&gt;</td></tr><tr><td align="center">__unm</td><td>取反，-</td><td align="center">__eq</td><td>等于，&#x3D;&#x3D;</td></tr><tr><td align="center">__idiv</td><td>取整除法，&#x2F;&#x2F;</td><td align="center">__lt</td><td>小于，&lt;</td></tr><tr><td align="center">__concat</td><td>字符串连接，..</td><td align="center">__le</td><td>小于等于，&lt;&#x3D;</td></tr><tr><td align="center">__len</td><td>字符串长度，#</td><td align="center"></td><td></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172225.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172225.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="184f26dd60b20c81c2bd592c069f497c.png"></p><ul><li>_ _tostring</li></ul><p>直接输出一个 table，其输出的内容为类型与 table 的存放地址。如果想让其输出 table 中的内容，可重写_ _tostring 元方法。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172234.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172234.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="de3c8ec34e1cbcfa4a0e025aa6f35f22.png"></p><ul><li>__call</li></ul><p>当将一个 table 以函数形式来使用时，系统会自动调用重写的_ _call 元方法。该用法主要是可以简化对 table 的相关操作，将对 table 的操作与函数直接相结合。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172253.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172253.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c1b9cbb5c1531e1eeb971753a1954dea.png"></p><ul><li>元表单独定义</li></ul><p>为了便于管理与复用，可以将元素单独定义为一个文件。该文件中仅可定义一个元表，且一般文件名与元表名称相同。</p><p>若一个文件要使用其它文件中定义的元表，只需使用 require “元表文件名”即可将元表导入使用。 如果用户想扩展该元表，则可在用户自己文件中重写其相应功能的元方法。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Lua 中没有类的概念，但通过 table、function 与元表可以模拟和构造出具有类这样功能的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172309.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a159c884c79f08ec89fd1d580ad5ea19.png"></p><p>Lua 中使用 table、function 与元表可以定义出类：使用一个表作为基础类，使用一个 function 作为该基础类的 new()方法。在该 new()方法中创建一个空表，再为该空表指定一个 元表。该元表重写_ _index 元方法，且将基础表指定为重写的_ _index 元方法。由于 new() 中的表是空表，所以用户访问的所有 key 都会从基础类（表）中查找。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172436.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e6fa697c8c77856967133623746b492b.png"></p><h2 id="协同线程与协同函数"><a href="#协同线程与协同函数" class="headerlink" title="协同线程与协同函数"></a>协同线程与协同函数</h2><h4 id="协同线程"><a href="#协同线程" class="headerlink" title="协同线程"></a>协同线程</h4><p>Lua 中有一种特殊的线程，称为 coroutine，协同线程，简称协程。其可以在运行时暂停执行，然后转去执行其它线程，然后还可返回再继续执行没有执行完毕的内容。</p><p>协同线程也称为协作多线程，在 Lua 中表示独立的执行线程。任意时刻只会有一个协程执行，而不会出现多个协程同时执行的情况。协同线程的类型为 thread，其启动、暂停、重启等，都需要通过函数来控制。</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">create(function)</td><td>创建一个协同线程实例，即返回的是 thread 类型。参数是一个 function。其需要通过 resume()来启动协同线程的执行</td></tr><tr><td align="center">resume(thread, …)</td><td>启动指定的协同线程的执行，使其从开始处或前面挂起处开始执行。可以向 create()的内置函数传递相应的参数。如果内置函数具有返回值，resume()会全部接收并返回。</td></tr><tr><td align="center">running()</td><td>返回正在运行的协同线程实例，即 thread 类型值</td></tr><tr><td align="center">yield()</td><td>挂起协同线程，并将协同线程设置为挂起状态。resume()可从挂起处重启被挂起的协同线程</td></tr><tr><td align="center">status(thread)</td><td>查看协同线程的状态。状态有三种：运行态 running，挂起态 suspended，消亡态 dead</td></tr><tr><td align="center">close()</td><td>关闭协同线程</td></tr><tr><td align="center">wrap(function)</td><td>创建一个协同函数，返回的是 function 类型。一旦调用该函数就会创建并执行一个协同线程实例</td></tr></tbody></table><h4 id="协同函数"><a href="#协同函数" class="headerlink" title="协同函数"></a>协同函数</h4><p>协同线程可以单独创建执行，也可以通过协同函数的调用启动执行。使用 coroutine 的 wrap() 函数创建的就是协同函数，其类型为 function。</p><p>由于协同函数的本质就是函数，所以协同函数的调用方式就是标准的函数调用方式。只不过，协同函数的调用会启动其内置的协同线程。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172506.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172506.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="62013d3f8bd177e0868c4f6abf4a4024.png"></p><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>Lua 中提供了大量对文件进行 IO 操作的函数。静态函数是指通过 io.xxx()方式对文件进行操作的函数，而实例函数则是通过 Lua 中面向对象方式操作的函数。</p><h3 id="常用静态函数"><a href="#常用静态函数" class="headerlink" title="常用静态函数"></a>常用静态函数</h3><ol><li>io.open()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.open (filename [, mode])</span><br></pre></td></tr></table></figure><p>以指定模式打开指定文件，返回要打开文件的句柄(对象)。其中模式 mode 有三种，但同时还可配合两个符号使用：</p><ul><li>r：只读，默认模式</li><li>w：只写，写入内容会覆盖文件原有内容</li><li>a：只写，以追加方式写入内容</li><li>+：增加符，在 r+、w+、a+均变为了读写</li><li>b：二进制表示符。如果要操作的文件为二进制文件，则需要变为 rb、wb、ab。</li></ul><p>2 .io.input()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.input (file)</span><br></pre></td></tr></table></figure><p>指定要读取的文件。</p><ol start="3"><li>io.output()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.output()</span><br></pre></td></tr></table></figure><p>指定要写入的文件。</p><ol start="4"><li>io.read()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.read([format])</span><br></pre></td></tr></table></figure><p>以指定格式读取 io.input()中指定的输入文件。其中 format 格式有：</p><ul><li>*l：从当前位置的下一个位置开始读取整个行，默认格式</li><li>*n：读取下一个数字，其将作为浮点数或整数</li><li>*a：从当前位置的下一个位置开始读取整个文件</li><li>number：这是一个数字，表示要读取的字符的个数</li></ul><ol start="5"><li>io.write()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.write(data)</span><br></pre></td></tr></table></figure><p>将指定的数据 data 写入到 io.output()中指定的输出文件。</p><p>实例：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172534.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216172534.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1bb5861331d4dbb4e6bfbd09760988b6.png"></p><h3 id="常用实例函数"><a href="#常用实例函数" class="headerlink" title="常用实例函数"></a>常用实例函数</h3><ol><li>file:read()</li></ol><p>这里的 file 使用的是 io.open()函数返回的 file，其实际就是 Lua 中的一个对象。其用法与 io.read()的相同。</p><ol start="2"><li>file:write()</li></ol><p>用法与 io.write()的相同。</p><ol start="3"><li>file:seek()</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:seek ([whence [, offset]])</span><br></pre></td></tr></table></figure><p>该函数用于获取或设置文件读写指针的当前位置。位置从 1 开始计数，除文件最后一行外，每行都有行结束符，其会占两个字符位置。位置 0 表示文件第一个位置的前面位置。</p><p>当 seek()为无参时会返回读写指针的当前位置。参数 whence 的值有三种，表示将指针定位的不同位置。而 offset 则表示相对于 whence 指定位置的偏移量，offset 的默认值为 0，为正表示向后偏移，为负表示向前偏移。</p><ul><li>set：表示将指针定位到文件开头处，即 0 位置处</li><li>cur：表示指针保持当前位置不变，默认值</li><li>end：表示将指针定位到文件结尾处</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第五章</title>
      <link href="/2023/12/18/Redis/5.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
      <url>/2023/12/18/Redis/5.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-分布式系统"><a href="#Redis-分布式系统" class="headerlink" title="Redis 分布式系统"></a>Redis 分布式系统</h1><p>Redis 分布式系统，官方称为 Redis Cluster，Redis 集群，其是 Redis 3.0 开始推出的分布式解决方案。其可以很好地解决不同 Redis 节点存放不同数据，并将用户请求方便地路由到不同 Redis 的问题。</p><h2 id="数据分区算法"><a href="#数据分区算法" class="headerlink" title="数据分区算法"></a>数据分区算法</h2><p>分布式数据库系统会根据不同的数据分区算法，将数据分散存储到不同的数据库服务器节点上，每个节点管理着整个数据集合中的一个子集。</p><p>常见的数据分区规则有两大类：顺序分区与哈希分区。</p><h3 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h3><p>顺序分区规则可以将数据按照某种顺序平均分配到不同的节点。不同的顺序方式，产生了不同的分区算法。例如，轮询分区算法、时间片轮转分区算法、数据块分区算法、业务主题分区算法等。</p><ul><li>轮询分区算法</li></ul><p>每产生一个数据，就依次分配到不同的节点。该算法适合于数据问题不确定的场景。其分配的结果是，在数据总量非常庞大的情况下，每个节点中数据是很平均的。但生产者与数据节点间的连接要长时间保持。</p><ul><li>时间片轮转分区算法</li></ul><p>将某个固定长度时间内的数据分配到一个节点，时间片结束后切换节点。该算法可能会出现节点数据不平均的情况（每个时间片内产生的数据量可能是不同的）。但生产者与节点间的连接使用完毕后就会立即释放。</p><ul><li>数据块分区算法</li></ul><p>在整体数据总量确定的情况下，根据各个节点的存储能力，可以将连接的某一整块数据分配到某一节点。</p><ul><li>业务主题分区算法</li></ul><p>数据可根据不同的业务主题，分配到不同的节点。</p><h3 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h3><p>哈希分区规则是充分利用数据的哈希值来完成分配，对数据哈希值的不同使用方式产生 了不同的哈希分区算法。几种常见的哈希分区算法：</p><ul><li>节点取模分区算法</li></ul><p>该算法的前提是，每个节点都已分配好了一个唯一序号，对于 N 个节点的分布式系统，其序号范围为[0, N-1]。然后选取数据本身或可以代表数据特征的数据的一部分作为 key，计算 hash(key)与节点数量 N 的模，该计算结果即为该数据的存储节点的序号。</p><p>该算法最大的优点是简单；其存在较严重的不足。如果分布式系统扩容或缩容，已 经存储过的数据需要根据新的节点数量 N 进行数据迁移。生产中扩容一般采用翻倍扩容方式，以减少扩容时数据迁移的比例。</p><ul><li>一致性哈希分区算法</li></ul><p>一致性 hash 算法通过一个叫作一致性 hash 环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点重合。环中间的整数按逆&#x2F;顺时针分布，故这个环的整数分布范围是[0, 2^32 -1]。</p><p>要为数据分配其要存储的节点。该数据对象的 hash(o) 按照逆&#x2F;顺时针方向距离哪 个节点的 hash(m)最近，就将该数据存储在哪个节点。</p><p>该算法的最大优点是，节点的扩容与缩容，仅对按照逆&#x2F;顺时针方向距离该节点最近的节点有影响，对其它节点无影响。</p><p>但当节点数量较少时，非常容易形成数据倾斜问题，且节点变化影响的节点数量占比较大， 即影响的数据量较大。</p><ul><li>虚拟槽分区算法</li></ul><p>该算法首先虚拟出一个固定数量的整数集合，该集合中的每个整数称为一个 slot 槽。这个槽的数量一般是远远大于节点数量的。然后再将所有 slot 槽平均映射到各个节点之上。</p><p>Redis 分布式系统中共虚拟了 16384 个 slot 槽，其范围为[0, 16383]。数据只与 slot 槽有关系，与节点没有直接关系。数据只通过其 key 的 hash(key)映射到 slot 槽：slot &#x3D; hash(key) % slotNums。这也是该算法的一个优点，解耦了数据与节点</p><p>Redis 计算槽点的公式为：slot &#x3D; CRC16(key) &amp;16383；CRC16()是一种带有校验功能的、具有良好分散功能的、特殊的 hash 算法函数。</p><blockquote><p>如果 b 是 2 的整数次幂，要计算 a % b，那么 a % b &#x3D; a &amp; (b-1)。</p></blockquote><h2 id="分布式系统搭建"><a href="#分布式系统搭建" class="headerlink" title="分布式系统搭建"></a>分布式系统搭建</h2><p>系统架构：6个节点，一个 master 配备一个 slave，master 与 slave 的配对关系，在系统搭建成功后会自动分配。</p><p>修改 redis.conf</p><ul><li>dir</li></ul><p>指定工作目录，持久化文件、节点配置文件将来都会在工作目录中自动生成。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/63238d5cff6e96ab51179eeb8cbff3c1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/63238d5cff6e96ab51179eeb8cbff3c1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="63238d5cff6e96ab51179eeb8cbff3c1.png"></p><ul><li>cluster-enabled</li></ul><p>该属性用于开启 Redis 的集群模式。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/07c27129bbb8f37c283b19bfa010e516.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/07c27129bbb8f37c283b19bfa010e516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="07c27129bbb8f37c283b19bfa010e516.png"></p><ul><li>cluster-config-file</li></ul><p>该属性用于指定“集群节点”的配置文件。该文件会在第一次节点启动时自动生成，其生成的路径是在 dir 属性指定的工作目录中。在集群节点信息发生变化后（如节点下线、故障转移等），节点会自动将集群状态信息保存到该配置文件中。</p><ul><li>cluster-node-timeout</li></ul><p>用于指定“集群节点”间通信的超时时间阈值，单位毫秒。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171559.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171559.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a84f93032a79ccaf5579e05b50b43e65.png"></p><p>修改 redis6380.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line">appendfilename appendonly6380.aof</span><br><span class="line">replica-priority 90</span><br><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line"></span><br><span class="line"># logfile access6380.log</span><br></pre></td></tr></table></figure><p>目录中有7个文件</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171605.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="502404198bb0add3695701f00bd22bcc.png"></p><h3 id="系统启动与关闭："><a href="#系统启动与关闭：" class="headerlink" title="系统启动与关闭："></a>系统启动与关闭：</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171613.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7a515cab5c4b7dba86090bd3d9753cad.png"></p><p>我们在启动所有节点后，会自动生成nodes文件</p><h5 id="创建系统"><a href="#创建系统" class="headerlink" title="创建系统"></a>创建系统</h5><p>此时6个节点仍是独立的 redis，通过 <strong>redis-cli –cluster create</strong> 命令可将 6 个节点创建成一个分布式系统。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171619.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171619.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f5356debd3912c6b9e8f63eb4877705f.png"></p><p>–cluster replicas 1 指定每个 master 会带有一个 slave 作为副本。</p><blockquote><p>这里不能使用 127.0.0.1</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171623.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171623.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fd273db6e37f38bc939e0f9570cd8e77.png"></p><h5 id="测试系统"><a href="#测试系统" class="headerlink" title="测试系统"></a>测试系统</h5><p>通过 <strong>cluster nodes</strong> 命令可以查看到系统中各节点的关系及连接情况。只要能看到每个节点给出 connected，就说明分布式系统已经成功搭建。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171635.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d164e98aa231f8a787b2b9a5489438e9.png"></p><blockquote><p>-c：表示这是要连接一个“集群”，而非是一个节点。</p></blockquote><p>关闭系统只需将各个节点 <strong>shutdown</strong> 即可</p><h2 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h2><h3 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171638.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171638.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c0b01293ea2dba42e3265953f77c2ab3.png"></p><p>写入操作和普通 Redis 节点相同，但使用批量写入需要指定统一的 group，让 grop 作为计算 slot 的唯一值</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171644.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="444ef31f738260fc72094a54946b8248.png"></p><ul><li>查询 Key 的 slot：cluster keyslot key</li><li>查询 slot 中 key 的数量：cluster countkeysinslot slot</li><li>查询 slot 中的 key：cluster getkeysinslot slot count</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171649.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171649.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c193da4d4ecb70e1e27661c00c6e93d0.png"></p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>分布式系统中的某个 master 如果出现宕机，那么其相应的 slave 就会自动晋升为 master。 如果原 master 又重新启动了，那么原 master 会自动变为新 master 的 slave。</p><h4 id="全覆盖需求"><a href="#全覆盖需求" class="headerlink" title="全覆盖需求"></a>全覆盖需求</h4><p>如果某 slot 范围对应节点的 master 与 slave 全部宕机，那么整个分布式系统是否还可以对外提供读服务，就取决于属性 cluster-require-full-coverage 的设置。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171654.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171654.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="16feb19c14892a56b7e8b6442ac9f8b3.png"></p><p>yes：默认值。要求所有 slot 节点必须全覆盖的情况下系统才能运行；no：slot 节点不全的情况下系统也可以提供查询服务。</p><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>动态扩容添加 master 节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c --cluster add-node 127.0.0.1:6386 127.0.0.1:6380</span><br></pre></td></tr></table></figure><p>通过命令 <code>redis-cli --cluster add-node &#123;newHost&#125;:&#123;newPort&#125; &#123;existHost&#125;:&#123;existPort&#125;</code>可以将新 的节点添加到系统中。其中<code>&#123;newHost&#125;:&#123;newPort&#125;</code>是新添加节点的地址，<code>&#123;existHost&#125;:&#123;existPort&#125;</code> 是原系统中的任意节点地址。</p><p>添加成功后，通过 redis-cli -c -p 6386 cluster nodes 命令可以看到其它 master 节点都分配有 slot，只有新添加的 master 还没有相应的 slot。</p><h4 id="分配-slot"><a href="#分配-slot" class="headerlink" title="分配 slot"></a>分配 slot</h4><p>为新的 master 分配的 slot 来自于其它节点，总 slot 数量并不会改变。所以 slot 分配过 程本质是一个 slot 的移动过程。</p><p>通过 <code>redis-cli –c --cluster reshard &#123;existIP&#125;:&#123;existPort&#125;</code>命令可开启 slot 分配流程。其中地址<code>&#123;existIP&#125;:&#123;existPort&#125;</code>为分布式系统中的任意节点地址。</p><h4 id="添加-slave-节点"><a href="#添加-slave-节点" class="headerlink" title="添加 slave 节点"></a>添加 slave 节点</h4><p>通过 <code>redis-cli --cluster add-node &#123;newHost&#125;:&#123;newPort&#125; &#123;existHost&#125;:&#123;existPort&#125; --cluster-slave  --cluster-master-id masterID</code> 命令可将新添加的节点直接添加为指定 master 的 slave。</p><h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><p>删除 slave 节点</p><p>对于 slave 节点，可以直接通过 <code>redis-cli --cluster del-node &lt;delHost&gt;:&lt;delPort&gt; delNodeID</code> 命令删除。</p><h4 id="移出-master-的-slot"><a href="#移出-master-的-slot" class="headerlink" title="移出 master 的 slot"></a>移出 master 的 slot</h4><p>在删除一个 master 之前，必须要保证该 master 上没有分配有 slot。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c --cluster reshard ip:port</span><br></pre></td></tr></table></figure><blockquote><p>仅能指定一个接收节点</p></blockquote><p>在移出 slot 后，我们可以像删除 slave 节点一样删除 master。</p><h3 id="分布式系统的限制"><a href="#分布式系统的限制" class="headerlink" title="分布式系统的限制"></a>分布式系统的限制</h3><ul><li>仅支持 0 号数据库</li><li>批量 key 操作支持有限</li><li>分区仅限于 key</li><li>事务支持有限</li><li>不支持分级管理</li></ul><h1 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h1><h3 id="Jedis-客户端"><a href="#Jedis-客户端" class="headerlink" title="Jedis 客户端"></a>Jedis 客户端</h3><p>Jedis 是一个基于 java 的 Redis 客户端连接工具，旨在提升性能与易用性。其 github 上的官网地址为：<a href="https://github.com/redis/jedis%E3%80%82">https://github.com/redis/jedis。</a></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Jedis 提供了非常丰富的操作 Redis 的方法，且方法名几乎与 Redis 命令相同。在每次使用时直接创建 Jedis 实例即可，Jedis 底层实际会创建一个到指定 Redis 服务器的 Socket 连接。</p><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记得关防火墙，不然连接不上</p></blockquote><h3 id="使用-JedisPool"><a href="#使用-JedisPool" class="headerlink" title="使用 JedisPool"></a>使用 JedisPool</h3><p>非常频繁地创建和销毁 Jedis 实例，虽然节省了系统资源与网络带宽，但创建和销毁 Socket 连接是比较耗时的，会大大降低系统性能。此时可以使用 Jedis 连接池来解决该问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JedisPool jp=<span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jp.getResource();</span><br><span class="line">    jedis.sadd(<span class="string">&quot;cities&quot;</span>,<span class="string">&quot;fs&quot;</span>,<span class="string">&quot;sc&quot;</span>,<span class="string">&quot;sz&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; cities = jedis.smembers(<span class="string">&quot;cities&quot;</span>);</span><br><span class="line">    System.out.println(cities);</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JedisPooled"><a href="#使用-JedisPooled" class="headerlink" title="使用 JedisPooled"></a>使用 JedisPooled</h3><p>每次关闭资源比较麻烦，JedisPooled 可以自动释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JedisPooled jpd=<span class="keyword">new</span> <span class="title class_">JedisPooled</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Set&lt;String&gt; cities = jpd.smembers(<span class="string">&quot;cities&quot;</span>);</span><br><span class="line">    System.out.println(cities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接-Sentinel-高可用集群"><a href="#连接-Sentinel-高可用集群" class="headerlink" title="连接 Sentinel 高可用集群"></a>连接 Sentinel 高可用集群</h3><p>对于 Sentinel 高可用集群的连接，直接使用 JedisSentinelPool 即可。在该客户端只需注册所有 Sentinel 节点及其监控的 Master 的名称即可，无需出现 master-slave 的任何地址信息。其采用的也是 JedisPool，使用完毕的 Jedis 也需要通过 close()方法将其返回给连接池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JedisSentinelPool jsp;</span><br><span class="line">&#123;</span><br><span class="line">    Set&lt;String&gt; sentinel=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    sentinel.add(<span class="string">&quot;192.168.64.100:26380&quot;</span>);</span><br><span class="line">    sentinel.add(<span class="string">&quot;192.168.64.100:26381&quot;</span>);</span><br><span class="line">    sentinel.add(<span class="string">&quot;192.168.64.100:26382&quot;</span>);</span><br><span class="line">    jsp=<span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,sentinel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jsp.getResource();</span><br><span class="line">    jedis.hset(<span class="string">&quot;emp&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;emp&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里代码没什么问题，但运行时容易报错：1. 连接不上；2. 连接的是slave不能写入</p></blockquote><h3 id="连接分布式系统"><a href="#连接分布式系统" class="headerlink" title="连接分布式系统"></a>连接分布式系统</h3><p>对于 Redis 的分布式系统的连接，直接使用 JedisCluster 即可。其底层采用的也是 Jedis 连接池技术。</p><p>对于 JedisCluster 常用的构造器有两个。一个是只需集群中的任意一个节点，但该构造器存在一个风险：其指定的这个节点在连接之前恰好宕机，那么该客户端将无法连接上集群。所以， 推荐将集群中所有节点全部罗列出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JedisCluster jc;</span><br><span class="line">&#123;</span><br><span class="line">    Set&lt;HostAndPort&gt; cluster=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6380</span>));</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6381</span>));</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6382</span>));</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6383</span>));</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6384</span>));</span><br><span class="line">    cluster.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6385</span>));</span><br><span class="line">    jc=<span class="keyword">new</span> <span class="title class_">JedisCluster</span>(cluster);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    jc.rpush(<span class="string">&quot;hobby&quot;</span>,<span class="string">&quot;music&quot;</span>,<span class="string">&quot;game&quot;</span>,<span class="string">&quot;dance&quot;</span>);</span><br><span class="line">    List&lt;String&gt; hobby = jc.lrange(<span class="string">&quot;hobby&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(hobby);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作事务"><a href="#操作事务" class="headerlink" title="操作事务"></a>操作事务</h3><p>Jedis 提供了 multi()、watch()、unwatch()方法来对应 Redis 中的 multi、watch、unwatch 命令。Jedis的 multi()方法返回一个 Transaction 对象，其 exec()与 discard() 方法用于执行和取消事务的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.64.100&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        multi.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        multi.incrBy(<span class="string">&quot;name&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        multi.exec();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        multi.discard();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s,%s&quot;</span>,jedis.get(<span class="string">&quot;name&quot;</span>),jedis.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为修改过的，即 Redis 运行时抛出的异常不会影响 Java 代码的执行。</p><h2 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h2><p>Spring Boot 中可以直接使用 Jedis 实现对 Redis 的操作，但一般使用 Redis 操作模板 RedisTemplate 类的实例来操作 Redis。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里以一个精简的金融产品交易平台为例示范：</p><p>我们跳过 ssm 结构直接构建 ssrm 工程</p><h3 id="添加依赖："><a href="#添加依赖：" class="headerlink" title="添加依赖："></a>添加依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL 连接驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis 模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件："><a href="#修改配置文件：" class="headerlink" title="修改配置文件："></a>修改配置文件：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="comment"># 连接 redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.64</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 开启 redis 缓存</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">cache-names:</span> <span class="string">product</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line"><span class="comment"># 整合 mybatis</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.redis.demo3.pojo</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="string">on</span></span><br><span class="line"><span class="comment"># SpringBoot 日志设置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">level-%-5level-%msg%n</span></span><br><span class="line"><span class="comment"># 指定不同的日志级别，显示sql语句</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">    <span class="attr">com.redis.demo3.mapper:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>由于要将查询的实体类对象缓存到 Redis，Redis 要求实体类必须序列化。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171717.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171717.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e242ced47944b7ef2f8856417cc7792e.png"></p><h3 id="redis缓存的使用"><a href="#redis缓存的使用" class="headerlink" title="redis缓存的使用"></a>redis缓存的使用</h3><h4 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h4><p>用于开启当前应用的缓存功能。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171722.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1c2fc93b6d011d52dfae16e2201ac6fa.png"></p><p>在 ServiceImpl 中开启缓存减轻数据库压力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper pm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Object,Object&gt; rt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;product&quot;,key=&quot;&#x27;product_all&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.getAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;product&quot;,key=&quot;&#x27;product_&#x27;+#name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.getByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        BoundValueOperations&lt;Object, Object&gt; bvo = rt.boundValueOps(<span class="string">&quot;raised&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bvo.get();</span><br><span class="line">        <span class="type">Double</span> <span class="variable">raised</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            raised = pm.getRaised(sdf.format(date));</span><br><span class="line">            bvo.set(raised, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raised;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(value=&quot;product&quot;,allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.insert(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中 RedisTemplate 必须指定泛型，否则会报错</p><p>BoundValueOperations就是一个绑定key的对象，我们可以通过这个对象来进行与key相关的操作。</p></blockquote><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>用于指定将查询结果使用指定的 key 缓存到指定缓存空间。如果再有对该 查询数据的访问，则会先从缓存中查看。</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>用于实现 value 指定缓存空间中缓存数据的清空。allEntries 为 true 指定清空该缓存空间所有数据。如果不想清空所有，则需通过 key 属性指定要清理的 key 数据。</p><h2 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当用户访问的数据既不在缓存也不在数据库中时，就会导致每个用户查询都会“穿透”缓存“直抵”数据库。这种情况就称为缓存穿透。</p><p>当高并发的访问请求到达时，缓存穿透不仅增加了响应时间，而且还会引发对 DBMS 的高并发查询，这种高并发查询很可能会导致 DBMS 的崩溃。</p><p>缓存穿透产生的主要原因有两个：一是在数据库中没有相应的查询结果，二是查询结果为空时，不对查询结果进行缓存。</p><p>解决方案：</p><ul><li>对非法请求进行限制</li><li>对结果为空的查询给出默认值</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>对于某一个缓存，在高并发情况下若其访问量特别巨大，当该缓存的有效时限到达时，可能会出现大量的访问都要重建该缓存，即这些访问请求发现缓存中没有该数据，则立即到 DBMS 中进行查询，那么这就有可能会引发对 DBMS 的高并发查询，从而接导致 DBMS 的崩溃。这种情况称为缓存击穿，而该缓存数据称为热点数据。 </p><p>解决方案，较典型的是使用“双重检测锁”机制。</p><p>优化交易额的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Double <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">    BoundValueOperations&lt;Object, Object&gt; bvo = rt.boundValueOps(<span class="string">&quot;raised&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">raised</span> <span class="operator">=</span> bvo.get();</span><br><span class="line">    <span class="keyword">if</span> (raised == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            raised=bvo.get();</span><br><span class="line">            <span class="keyword">if</span>(raised==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">                <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                raised = pm.getRaised(sdf.format(date));</span><br><span class="line">                bvo.set(raised, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Double.parseDouble(raised+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>对于缓存中的数据，很多都是有过期时间的。若大量缓存的过期时间在同一很短的时间段内几乎同时到达，那么在高并发访问场景下就可能会引发对 DBMS 的高并发查询，而这将可能直接导致 DBMS 的崩溃。这种情况称为缓存雪崩。</p><p>最好的解决方案就是预防，即提前规划好缓存的过期时间。如果 DBMS 采用的是分布式部署，则将热点数据均匀分布在不同数据库节点中，将可能到来的访问负载均衡开来。</p><h3 id="数据库缓存双写不一致"><a href="#数据库缓存双写不一致" class="headerlink" title="数据库缓存双写不一致"></a>数据库缓存双写不一致</h3><p>以上三种情况都是针对<strong>高并发读场景</strong>中可能会出现的问题，而数据库缓存双写不一致问题，则是在<strong>高并发写场景</strong>下可能会出现的问题。</p><h4 id="“修改-DB-更新缓存”场景"><a href="#“修改-DB-更新缓存”场景" class="headerlink" title="“修改 DB 更新缓存”场景"></a>“修改 DB 更新缓存”场景</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171733.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171733.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c8bbccda699ecbc1a4994ee355832cda.png"></p><h4 id="“修改-DB-删除缓存”场景"><a href="#“修改-DB-删除缓存”场景" class="headerlink" title="“修改 DB 删除缓存”场景"></a>“修改 DB 删除缓存”场景</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171740.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171740.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7829ea02d03a0038d9baf709cc0c7e90.png"></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><h5 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h5><p>延迟双删方案是专门针对于“修改 DB 删除缓存”场景的解决方案。但该方案并不能彻底解决数据不一致的状况，其只可能降低发生数据不一致的概率。</p><p>两次删除中间的间隔时长，要大于一次缓存写操作的时长。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171749.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="981d8e2f351371168d84a50621d55d4c.png"></p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>以上两种场景中，只所以会出现数据库与缓存中数据不一致，主要是因为对请求的处理出现了并行。只要将请求写入到一个统一的队列，只有处理完一个请求后才可处理下一个请求，即使系统对用户请求的处理串行化，就可以完全解决数据不一致的问题。</p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>使用队列的串行化虽然可以解决数据库与缓存中数据不一致，但系统失去了并发性，降低了性能。使用分布式锁可以在不影响并发性的前提下，协调各处理线程间的关系，使数据库与缓存中的数据达成一致性。</p><p>只需要对数据库中的这个共享数据的访问通过分布式锁来协调对其的操作访问即可。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第四章</title>
      <link href="/2023/12/16/Redis/4.Redis%20%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
      <url>/2023/12/16/Redis/4.Redis%20%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-主从集群"><a href="#Redis-主从集群" class="headerlink" title="Redis 主从集群"></a>Redis 主从集群</h1><p>为了避免 Redis 的单点故障问题，我们可以搭建一个 Redis 集群，将数据备份到集群中的其它节点上。</p><p>Redis 的主从集群是一个“一主多从”的读写分离集群。对于数据库集群，写操作压力一般都较小，压力大多数来自于读操作请求，所以集群中的 Master 节点负责处理客户端的读写请求，而 Slave 节点仅能处理客户端的读请求。</p><h2 id="主从集群搭建"><a href="#主从集群搭建" class="headerlink" title="主从集群搭建"></a>主从集群搭建</h2><h3 id="伪集群搭建与配置"><a href="#伪集群搭建与配置" class="headerlink" title="伪集群搭建与配置"></a>伪集群搭建与配置</h3><p>在采用单线程 IO 模型时，为了提高处理器的利用率，一般会在一个主机中安装多台 Redis， 构建一个 Redis 主从伪集群。</p><ol><li>复制 redis.conf，用于设置每个 Redis 节点的公共属性。修改：</li></ol><ul><li>masterauth</li></ul><p>如果需要设置置密码验证属性 requirepass，每个主机的密码都要设置为相同的。且要设置两个值完全相同的属性：requirepass 与 masterauth。其中 requirepass 用于指定当前主机的访问密码，而 masterauth 用于指定当前 slave 访问 master 时向 master 提交的访问密码，用于让 master 验证自己身份是否合法。</p><ul><li>repl-disable-tcp-nodelay</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171038.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171038.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="150052854a7ce448021caae348d9b771.png"></p><p>该属性用于设置是否禁用 TCP 特性 tcp-nodelay。设为 yes 则禁用 tcp-nodelay，此时 master 与 slave 间的通信会产生延迟，但使用的 TCP 包数量会较少，占用的网络带宽会较小。设置为 no，则网络延迟会变小，但使用的 TCP 包数量会较多，相应占用的网络带宽会大。</p><blockquote><p>tcp-nodelay：为了充分复用网络带宽，TCP 总是希望发送尽可能大的数据块。为了达到该目的，TCP 中使用了名为 Nagle 的算法。</p><p>Nagle 算法的工作原理：网络在接收到要发送的数据后，并不直接发送，而是等待着数据量足够大（由 TCP 网络特性决定）时再一次性发送出去。这样，网络上传输的有效数据比例就得到了大大提升，无效数据传递量极大减少，于是就节省了网络带宽，缓解了网络压力。</p><p>tcp-nodelay 则是 TCP 协议中 Nagle 算法的开头。</p></blockquote><ol start="2"><li>创建 slave 的配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid #设置进程id</span><br><span class="line">port 6380 #设置端口号</span><br><span class="line">dbfilename dump6380.rdb #设置持久化文件名</span><br><span class="line">appendfilename appendonly6380.aof # 设置增量文件名</span><br><span class="line">replica-priority 90 #设置选举优先级，默认100，值越小优先级越高</span><br><span class="line"></span><br><span class="line"># logfile access6380.log #指定日志文件</span><br></pre></td></tr></table></figure><p>另外两个文件类似，不在赘述</p><p>启动 redis</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171042.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0489022eac57defba2121b6dac27d27c.png"></p><h4 id="设置主从关系："><a href="#设置主从关系：" class="headerlink" title="设置主从关系："></a>设置主从关系：</h4><ul><li><strong>slaveof</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171052.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b768f3d15040acdcf6b8bc89f515a31e.png"></p><h4 id="查看状态信息："><a href="#查看状态信息：" class="headerlink" title="查看状态信息："></a>查看状态信息：</h4><ul><li><strong>info replication</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171055.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fb501b034af9219356069518fb5fb3a7.png"></p><h3 id="分级管理"><a href="#分级管理" class="headerlink" title="分级管理"></a>分级管理</h3><p>Redis 主从集群中的 Slave 较多时，它们的数据同步过程会对 Master 形成较大的性能压力。此时可以对这些 Slave 进行分级管理。</p><p>只需要让低级别 Slave 指定其 slaveof 的主机为其上一级 Slave 即可。上一级 Slave 的状态仍为 Slave，只不过其是更上一级的 Slave。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171059.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="427938264eba60056c1bab450c6eab69.png"></p><p>当然，此时 Master 的 Slave 只有 6381 一个主机。</p><h3 id="容灾冷处理"><a href="#容灾冷处理" class="headerlink" title="容灾冷处理"></a>容灾冷处理</h3><p>在 Master&#x2F;Slave 的 Redis 集群中，若 Master 出现宕机，有两种处理方式，一种是通过手工角色调整，使 Slave 晋升为 Master 的冷处理；一种是使用哨兵模式，实现 Redis 集群的高可用 HA，即热处理。</p><p>无论 Master 是否宕机，Slave 都可通过 <strong>slaveof no one</strong> 将自己由 Slave 晋升为 Master。如果其原本有下一级的 Slave，那么其就直接变为了这些 Slave 的 Master 了。而原来的 Master 也会失去这个原来的 Slave。</p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><h3 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h3><p>当一个 slave 节点接收到类似 slaveof 127.0.0.1 6380 的指令后直至其可以从 master 持续复制数据，大体经历了如下几个过程：</p><ol><li>保存 master 地址</li><li>建立连接</li></ol><p>slave 中维护着一个定时任务，该定时任务会尝试着与该 master 建立 socket 连接。如果连接无法建立，则其会不断定时重试，直到连接成功或接收到 slaveof no one 指令。</p><ol start="3"><li>slave 发送 ping 命令</li></ol><p>连接建立成功后，slave 会发送 ping 命令进行首次通信。如果 slave 没有收到 master 的 回复，则 slave 会主动断开连接，下次的定时任务会重新尝试连接。</p><ol start="4"><li>对 slave 身份验证</li></ol><p>master 收到了 slave 的 ping 命令，并不会立即回复，而是先进行身份验证。如果验证失败，则会发送消息拒绝连接；如果验证成功，则向 slave 发送连接成功响应。</p><ol start="5"><li>master 持久化</li></ol><p>首次通信成功后，slave 会向 master 发送数据同步请求。当 master 接收到请求后，会 fork 出一个子进程，让子进程以异步方式立即进行持久化。</p><ol start="6"><li>数据发送</li></ol><p>持久化完毕后 master 会再 fork 出一个子进程，让该子进程以异步方式将数据发送给 slave。slave 会将接收到的数据不断写入到本地的持久化文件中。</p><p>在 slave 数据同步过程中，master 的主进程仍在不断地接受着客户端的写操作，且不仅将新的数据写入到了 master 内存，同时也写入到了同步缓存。当 master 的持久化文件中的数据发送完毕后，master 会再将同步缓存中新的数据发送给 slave，由 slave 将其写入到本地持久化文件中。数据同步完成。</p><ol start="7"><li>slave 恢复内存数据</li></ol><p>当 slave 与 master 的数据同步完成后，slave 就会读取本地的持久化文件，将其恢复到本地内存，然后就可以对外提供读服务了。</p><ol start="8"><li>持续增量复制</li></ol><p>在 slave 对外提供服务过程中，master 会持续不断的将新的数据以增量方式发送给 slave，以保证主从数据的一致性。</p><h3 id="数据同步演变过程"><a href="#数据同步演变过程" class="headerlink" title="数据同步演变过程"></a>数据同步演变过程</h3><h4 id="sync-同步"><a href="#sync-同步" class="headerlink" title="sync 同步"></a>sync 同步</h4><p>Redis 2.8 版本之前，首次通信成功后，slave 会向 master 发送 sync 数据同步请求。然后 master 就会将其所有数据全部发送给 slave，由 slave 保存到其本地的持久化文件中。这个过程称为全量复制。</p><p>由于全量复制过程非常耗时，期间出现网络抖动的概率很高。而中断后的从头开始不仅需要消耗大量的系统资源、网络带宽，而且可能会出现长时间无法完成全量复制的情况。</p><h4 id="psync-同步"><a href="#psync-同步" class="headerlink" title="psync 同步"></a>psync 同步</h4><p>Redis 2.8 版本之后，全量复制采用了 psync（Partial Sync，不完全同步）同步策略。当全量复制过程出现由于网络抖动而导致复制过程中断时，当重新连接成功后，复制过程可以“断点续传”。</p><p>为了实现 psync，整个系统做了三个大的变化：</p><ol><li>复制偏移量</li></ol><p>系统为每个要传送数据进行了编号，该编号从 0 开始，每个字节一个编号。该编号称为复制偏移量。参与复制的主从节点都会维护该复制偏移量。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171114.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171114.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="709f8e98c2b2d17c882e1eff7a1ef476.png"></p><p>master 每发送过一个字节数据后就会进行累计。统计信息通过 info replication 的 master_repl_offset 可查看到。同时，slave 会定时向 master 上报其自身已完成的复制偏移量给 master，所以 master 也会保存 slave 的复制偏移量 offset。</p><p>slave在接收到master的数据后，也会累计接收到的偏移量。统计信息通过info replication 的 slave_repl_offset 可查看到。</p><ol start="2"><li>主节点复制 ID</li></ol><p>当 master 启动后就会动态生成一个长度为 40 位的 16 进制字符串作为当前 master 的复制 ID，该 ID 是在进行数据同步时 slave 识别 master 使用的。通过 info replication 的 master_replid 属性可查看到该 ID。</p><ol start="3"><li>复制积压缓冲区</li></ol><p>当 master 有连接的 slave 时，在 master 中就会创建并维护一个队列 backlog，默认大小为 1MB，该队列称为复制积压缓冲区。master 接收到了写操作数据不仅会写入到 master 主 存，写入到 master 中为每个 slave 配置的发送缓存，而且还会写入到复制积压缓冲区。其作用就是用于保存最近操作的数据，以备“断点续传”时做数据补偿，防止数据丢失。</p><h5 id="psync-同步过程"><a href="#psync-同步过程" class="headerlink" title="psync 同步过程"></a>psync 同步过程</h5><p>psync 是一个由 slave 提交的命令，其格式为 psync &lt;master_replid&gt; &lt;repl_offset&gt;，表示当前 slave 要从指定的 master 中的 repl_offset+1 处开始复制。repl_offset 表示当前 slave 已经 完成复制的数据的 offset。该命令保证了“断点续传”的实现。</p><p>在第一次开始复制时，slave 并不知道 master 的动态 ID，并且一定是从头开始复制，所以其提交的 psync 命令为 PSYNC ? -1。</p><p>此时 master 可能有两种响应：</p><ul><li>FULLRESYNC &lt;master_replid&gt; &lt;repl_offset&gt;：告知 slave 当前 master 的动态 ID 及可以开始全量复制了，这里的 repl_offset 一般为 0</li><li>ERR：告知 slave，当前 master 的版本低于 Redis 2.8，不支持 psyn，你可以开始全量复制了</li></ul><p>如果复制过程中断后 slave 与 master 成功连接，则 slave 再次提交 psyn 命令。此时的 psyn 命令的 repl_offset 参数为其前面已经完成复制的数据的偏移量。</p><p>master 相应：CONTINUE；告知 slave 可以按照你提交的 repl_offset 后面位置开始“续传”了</p><h5 id="psync-存在的问题"><a href="#psync-存在的问题" class="headerlink" title="psync 存在的问题"></a>psync 存在的问题</h5><ul><li>在 psync 数据同步过程中，若 slave 重启，在 slave 内存中保存的 master 的动态 ID 与续传 offset 都会消失，“断点续传”将无法进行，从而只能进行全量复制，导致资源浪费。</li><li>在 psync 数据同步过程中，master 宕机后 slave 会发生“易主”，从而导致 slave 需要从新 master 进行全量复制，形成资源浪费。</li></ul><h5 id="psync-同步的改进"><a href="#psync-同步的改进" class="headerlink" title="psync 同步的改进"></a>psync 同步的改进</h5><p>Redis 4.0 对 psync 进行了改进，提出了“同源增量同步”策略。</p><ol><li>解决 slave 重启问题</li></ol><p>针对“slave 重启时 master 动态 ID 丢失问题”，改进后的 psync 将 master 的动态 ID 直接写入到了 slave 的持久化文件中。</p><p>slave 重启后直接从本地持久化文件中读取 master 的动态 ID，然后向 master 提交获取复制偏移量的请求。master 会根据提交请求的 slave 地址，查找到保存在 master 中的复制偏移量</p><ol start="2"><li>解决 slave 易主问题</li></ol><p>如果 slave 发送 PSYNC &lt;原 master_replid&gt; &lt;repl_offset&gt; 命令，新master能够识别出该slave要从原master复制数据，而自己的数据也都是从该master复制来的。那么新 master 就会明白，其与该 slave“师出同门”，应该接收其“断点续传”同步请求。</p><h6 id="无盘操作"><a href="#无盘操作" class="headerlink" title="无盘操作"></a>无盘操作</h6><p>Redis 6.0 对同步过程又进行了改进，提出了“无盘全量同步”与“无盘加载”策略，避免了耗时的 IO 操作。</p><ul><li>无盘全量同步：master 的主进程 fork 出的子进程直接将内存中的数据发送给 slave，无需经过磁盘。</li><li>无盘加载：slave 在接收到 master 发送来的数据后不需要将其写入到磁盘文件，而是直接写入到内存，这样 slave 就可快速完成数据恢复。</li></ul><h6 id="共享复制积压缓冲区"><a href="#共享复制积压缓冲区" class="headerlink" title="共享复制积压缓冲区"></a>共享复制积压缓冲区</h6><p>Redis 7.0 版本对复制积压缓冲区进行了改进，让各个 slave 的发送缓冲区共享复制积压缓冲区。这使得复制积压缓冲区的作用，除了可以保障数据的安全性外，还作为所有 slave 的发送缓冲区，充分利用了复制积压缓冲区。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>对于 Master 宕机后的冷处理方式是无法实现高可用的。Redis 从 2.6 版本开始提供了高可用的解决方案—— Sentinel 哨兵机制。在集群中再引入一个节点，该节点充当 Sentinel 哨兵，用于监视 Master 的运行状态，并在 Master 宕机后自动指定一个 Slave 作为新的 Master。 整个过程无需人工参与，完全由哨兵自动完成。</p><p>为了解决 Sentinel 的单点问题，又要为 Sentinel 创建一个集群，即 Sentinel 哨兵集群。</p><p>Sentinel 哨兵工作原理：</p><p>每个 Sentinel 都会定时会向 Master 发送心跳，如果 Master 在有效时间内向它们都进行了响应，则说明 Master 是“活着的”。如果 Sentinel 中有 quorum 个哨兵没有收到响应，那么就认为 Master 已经宕机，然后会有一个 Sentinel 做 Failover 故障转移。即将原来的某一个 Slave 晋升为 Master。</p><h3 id="哨兵机制实现"><a href="#哨兵机制实现" class="headerlink" title="哨兵机制实现"></a>哨兵机制实现</h3><ol><li>复制 sentinel.conf</li><li>修改 sentinel.conf</li></ol><ul><li>sentinel monitor</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171125.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171125.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="448a85e8c2549a94e6f8b1a0a02a6834.png"></p><p>该配置用于指定 Sentinel 要监控的 master，为 master 起了一个名字。同时指定 Sentinel 集群中决定该master“客观下线状态”判断的法定 sentinel 数量&lt;quorum&gt;。&lt;quorum&gt;的另一个用途与sentinel 的 Leader 选举有关。要求中至少要有 max(quorum, sentinelNum&#x2F;2+1)个 sentinel 参与，选举才能进行。</p><p>这里将该配置注释掉，因为要在后面的其它配置文件中设置，如果不注释就会出现配置冲突。</p><ul><li>sentinel auth-pass</li></ul><p>如果 Redis 主从集群中的主机设置了访问密码，那么该属性就需要指定 master 的主机名与访问密码。以方便 sentinel 监控 master。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171130.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171130.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1039dffe4d72a19e948432d51921e2ed.png"></p><ol start="3"><li>新建sentinel配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include sentinel.conf</span><br><span class="line">pidfile /var/run/sentinel_26380.pid</span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor mymaster 192.168.64.100 6380 2</span><br><span class="line"></span><br><span class="line"># logfile access26380.log</span><br></pre></td></tr></table></figure><p>另外两个文件类似，不再赘述</p><h4 id="Redis-高可用集群的启动"><a href="#Redis-高可用集群的启动" class="headerlink" title="Redis 高可用集群的启动"></a>Redis 高可用集群的启动</h4><ol><li>启动并关联 Redis 集群</li><li>启动 Sentinel 集群</li></ol><p>在&#x2F;usr&#x2F;local&#x2F;bin 目录下有一个命令 redis-sentinel 用于启动 Sentinel。</p><blockquote><p>redis-sentinel 命令是 redis-server 命令的软链接</p></blockquote><p>方式一：使用 redis-sentinel 命令：redis-sentinel sentinel26380.conf</p><p>方式二，使用 redis-server 命令：redis-server sentinel26380.conf –sentinel</p><ol start="3"><li>查看 Sentinel 信息</li></ol><p>运行中的 Sentinel 就是一个特殊 Redis，其也可以通过客户端连接，然后通过 <strong>info sentinel</strong> 来查看当前连接的 Sentinel 的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171203.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171203.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6f5e5ff4cea251afb04c54e2e9cf1678.png"></p><ol start="4"><li>查看 sentinel 配置文件</li></ol><p>打开任意 sentinel 的配置文件，发现其配置内容中新增加了很多配置。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171139.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171139.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="79ba5bc7f2e91bdc2825553e847b7e57.png"></p><h4 id="Sentinel-优化配置"><a href="#Sentinel-优化配置" class="headerlink" title="Sentinel 优化配置"></a>Sentinel 优化配置</h4><p>在公共的 sentinel.conf 文件中，还可以通过修改一些其它属性的值来达到对 Sentinel 的配置优化。</p><ul><li>sentinel down-after-milliseconds</li></ul><p>每个 Sentinel 会通过定期发送 ping 命令来判断 master、slave 及其它 Sentinel 是否存活。如果 Sentinel 在该属性指定的时间内没有收到它们的响应，那么该 Sentinel 就会主观认为该主机宕机。默认为 30 秒。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171210.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171210.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c157fbd1e2b78afeb8d80ab9cbeee7af.png"></p><ul><li>sentinel parallel-syncs</li></ul><p>该属性用于指定在故障转移期间，即老的 master 出现问题，新的 master 刚晋升后，允许多少个 slave 同时从新 master 进行数据同步。默认值为 1 表示所有 slave 逐个从新 master 进行数据同步。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171215.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="99295bb612b2da7b9606eb5d62932928.png"></p><ul><li>sentinel failover-timeout</li></ul><p>指定故障转移的超时时间，默认时间为 3 分钟。该超时时间的用途：</p><ol><li>第一次故障转移失败，在同一个 master 上进行第二次故障转移尝试的时间为该 failover-timeout 的两倍</li><li>新 master 晋升完毕，slave 从老 master 强制转到新 master 进行数据同步的时间阈值。(当超时了就不会再逐个同步)</li><li>取消正在进行的故障转换所需的时间阈值。</li><li>新 master 晋升完毕，所有 replicas 的配置文件更新为新 master 的时间阈值。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171223.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171223.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0ec15eebd2f7e9f820eb47c0d9ed37a2.png"></p><ul><li>sentinel deny-scripts-reconfig</li></ul><p>指定是否可以通过命令 sentinel set 动态修改 notification-script 与 client-reconfig-script 两个脚本。默认是不能的。这两个脚本如果允许动态修改，可能会引发安全问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171229.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171229.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d0c0fe2b05551c095e409d5e1497bbed.png"></p><ul><li>动态修改配置</li></ul><p>通过 redis-cli 连接上 Sentinel 后，通过 sentinel set 命令可动态修改配置信息。</p><p>sentinel set 命令支持的参数：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171236.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171236.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e9e8b6a30d1032c92a0f6cce5297658c.png"></p><h3 id="哨兵机制原理"><a href="#哨兵机制原理" class="headerlink" title="哨兵机制原理"></a>哨兵机制原理</h3><h4 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h4><p>Sentinel 维护着三个定时任务以监测 Redis 节点及其它 Sentinel 节点的状态。</p><ul><li>info 任务</li></ul><p>每个 Sentinel 节点每 10 秒就会向 Redis 集群中的每个节点发送 info 命令，以获得最新的 Redis 拓扑结构。</p><ul><li>心跳任务</li></ul><p>每个Sentinel节点每1秒就会向所有Redis节点及其它Sentinel节点发送一条ping命令，以检测这些节点的存活状态。该任务是判断节点在线状态的重要依据。</p><ul><li>发布&#x2F;订阅任务</li></ul><p>每个 Sentinel 节点在启动时都会向所有 Redis 节点订阅_ _sentinel_ _:hello 主题的信息， 当 Redis 节点中该主题的信息发生了变化，就会立即通知到所有订阅者。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171303.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216171303.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="12ccf46201ea219f46bb7efe243bb972.png"></p><p>Sentinel 节点每 2 秒就会向每个 Redis 节点发布一条_ _sentinel_ _:hello 主题的信息，该信息是当前 Sentinel 对每个 Redis 节点在线状态的判断结果及当前 Sentinel 节点信息。</p><p>当 Sentinel 节点接收到_ _sentinel_ _:hello 主题信息后，就会读取并解析这些信息，然后主要完成以下三项工作：</p><ol><li>如果发现有新的 Sentinel 节点加入，则记录下新加入 Sentinel 节点信息，并与其建立连接。</li><li>如果发现有 Sentinel Leader 选举的选票信息，则执行 Leader 选举过程。</li><li>汇总其它 Sentinel 节点对当前 Redis 节点在线状态的判断结果，作为 Redis 节点客观下线的判断依据。</li></ol><h4 id="Redis-节点下线判断"><a href="#Redis-节点下线判断" class="headerlink" title="Redis 节点下线判断"></a>Redis 节点下线判断</h4><ul><li>主观下线</li></ul><p>每个 Sentinel 节点每秒会向每个 Redis 节点发送 ping 心跳检测，如果 Sentinel 在 down-after-milliseconds 时间内没有收到某 Redis 节点的回复，则 Sentinel 节点就会对该 Redis 节点做出“下线状态”的判断</p><ul><li>客观下线</li></ul><p>当 Sentinel 主观下线的节点是 master 时，该 Sentinel 节点会向每个其它 Sentinel 节点发送 sentinel is-master-down-by-addr 命令，以询问其对 master 在线状态的判断结果。这些 Sentinel 节点在收到命令后会向这个发问 Sentinel 节点响应 0（在线）或 1（下线）。当 Sentinel 收到超过 quorum 个下线判断后，就会对 master 做出客观下线判断。</p><h4 id="Sentinel-Leader-选举"><a href="#Sentinel-Leader-选举" class="headerlink" title="Sentinel Leader 选举"></a>Sentinel Leader 选举</h4><p>当 Sentinel 节点对 master 做出客观下线判断后会由 Sentinel Leader 来完成后续的故障转移。Sentinel 集群的 Leader 选举是通过 Raft 算法实现的。</p><p>大致思路：</p><p>每个选举参与者都具有当选 Leader 的资格，当其完成了“客观下线”判断后，就会立即推选自己做 Leader，然后将自己的提案发送给所有参与者。其它参与者在收到提案后，只要自己手中的选票没有投出去，其就会立即通过该提案并将同意结果反馈给提案者，后续再过来的提案会由于该参与者没有了选票而被拒绝。当提案者收到了同意反馈数量大于等于 max(quorum，sentinelNum&#x2F;2+1)时，该提案者当选 Leader。</p><p>说明：Sentinel Leader 选举会在次故障转移发生之前进行。在网络没有问题的前提下，谁先做出了“客观下线”的判断，谁就更容易当选Leader。故障转移结束后 Leader 就不再存在。</p><h4 id="master-选择算法"><a href="#master-选择算法" class="headerlink" title="master 选择算法"></a>master 选择算法</h4><p>在进行故障转移时，Sentinel Leader 需要从所有 Redis 的 Slave 节点中选择出新的 Master。</p><ol><li>过滤掉所有主观下线的，或心跳没有响应 Sentinel 的，或 replica-priority 值为 0 的 Redis 节点</li><li>在剩余 Redis 节点中选择出 replica-priority 最小的的节点列表。如果只有一个节点，则直接返回</li><li>从优先级相同的节点列表中选择复制偏移量最大的节点。如果只有一个节点，则直接返回</li><li>从复制偏移值量相同的节点列表中选择动态 ID 最小的节点返回</li></ol><h4 id="故障转移过程"><a href="#故障转移过程" class="headerlink" title="故障转移过程"></a>故障转移过程</h4><p>Sentinel Leader 负责整个故障转移过程：</p><ol><li>根据 master 选择算法选择出一个 slave 节点作为新的 master</li><li>向新 master 节点发送 slaveof no one 指令，使其晋升为 master</li><li>向新 master 发送 info replication 指令，获取到 master 的动态 ID</li><li>向其余 Redis 节点发送消息，以告知它们新 master 的动态 ID</li><li>向其余 Redis 节点发送 slaveof 指令，使它们成为新 master 的 slave</li><li>从所有 slave 节点中每次选择出 parallel-syncs 个 slave 从新 master 同步数 据，直至所有 slave 全部同步完毕</li><li>故障转移完毕</li></ol><h4 id="节点上线"><a href="#节点上线" class="headerlink" title="节点上线"></a>节点上线</h4><ul><li>原 Redis 节点上线</li></ul><p>只要是原 Redis 集群中的节点上线，只需启动 Redis 即可。因为每个 Sentinel 中都保存有原来其监控的所有 Redis 节点列表， Sentinel 会定时查看这些 Redis 节点是否恢复。如果查看到其已经恢复，则会命其从当前 master 进行数据同步。如果是原 master 上线，在新 master 晋升后 Sentinel Leader 会立即先将原 master 节点更新为 slave，然后才会定时查看其是否恢复。</p><ul><li>新 Redis 节点上线</li></ul><p>如果需要在 Redis 集群中添加一个新的节点，则上线操作只能手工完成。即添加者在添加之前必须知道当前 master 是谁，然后在新节点启动后运行 slaveof 命令加入集群。</p><ul><li>Sentinel 节点上线</li></ul><p>添加 Sentinel 节点需要手工完成。即在添加之前必须知道当前 master 是谁，然后在配置文件中修改 sentinel monitor 属性，指定要监控的 master。</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP 定理的内容是：对于分布式系统，网络环境相对是不可控的，出现网络分区是不可避免的，因此系统必须具备分区容错性。但系统不能同时保证一致性与可用性。即要么 CP，要么 AP。</p><ul><li>一致性（C）：</li></ul><p>分布式系统中多个主机之间是否能够保持数据一致的特性。即，当系统数 据发生更新操作后，各个主机中的数据仍然处于一致的状态。</p><ul><li>可用性（A）：</li></ul><p>系统提供的服务必须一直处于可用的状态，即对于用户的每一个请求，系统总是可以在有限的时间内对用户做出响应。</p><ul><li>分区容错性（P）：</li></ul><p>分布式系统在遇到任何网络分区故障时，仍能够保证对外提供满足一致性和可用性的服务。</p><blockquote><p>分布式系统中，节点之间必然会有不同，比如网络、服务器等等，所以在分布式系统中分区容错性必然存在</p></blockquote><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写，BASE 是对 CAP 中一致性和可用性权衡的结果</p><p>BASE 理论的核心思想是：即使无法做到强一致性，但每个系统都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><ul><li>基本可用</li></ul><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p><ul><li>软状态</li></ul><p>软状态，是指允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统主机间进行数据同步的过程存在一定延时。</p><ul><li>最终一致性</li></ul><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</p><p>CAP 应用：</p><ol><li>Zookeeper</li></ol><p>Zookeeper 遵循的是 CP 模式，当 Leader 节点中的数据发生了变化后，在 Follower 还没有同步完成之前，整个 Zookeeper集群是不对外提供服务的。</p><ol start="2"><li>Consul</li></ol><p>Consul 遵循的是 CP 模式</p><ol start="3"><li>Redis</li></ol><p>Redis 遵循的是 AP 模式</p><ol start="4"><li>Eureka</li></ol><p>Eureka 遵循的是 AP 模式</p><ol start="5"><li>Nacos</li></ol><p>Nacos 在做注册中心时，默认是 AP 的。但其也支持 CP 模式，但需要用户提交请求进行转换。</p><h2 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h2><p>Raft 算法是一种通过对日志复制管理来达到集群节点一致性的算法。这个日志复制管理发生在集群节点中的 Leader 与 Followers 之间。Raft 通过选举出的 Leader 节点负责管理日志复制过程，以实现各个节点间数据的一致性。</p><p>在 Raft 中，节点有三种角色：</p><ul><li>Leader：唯一负责处理客户端写请求的节点；同时负责日志复制工作</li><li>Candidate：Leader 选举的候选人，其可能会成为 Leader。是一个选举中的过程角色</li><li>Follower：可以处理客户端读请求；负责同步来自于 Leader 的日志；当接收到其它 Cadidate 的投票请求后可以进行投票；当发现 Leader 挂了，其会转变为 Candidate 发起 Leader 选举</li></ul><h3 id="leader-选举"><a href="#leader-选举" class="headerlink" title="leader 选举"></a>leader 选举</h3><ol><li>选举</li></ol><p>若 follower 在心跳超时范围内没有接收到来自于 leader 的心跳，则认为 leader 挂了。此时其首先本地 term 增一。然后 follower 会完成以下步骤：</p><ul><li>若接收到了其它 candidate 的投票请求，则会将选票投出</li><li>由 follower 转变为 candidate</li><li>若之前尚未投票，则向自己投一票</li><li>向其它节点发出投票请求，然后等待响应</li></ul><ol start="2"><li>投票</li></ol><p>follower 在接收到投票请求后，其会根据以下情况来判断是否投票：</p><ul><li>发来投票请求的 candidate 的 term 不能小于我的 term</li><li>在当前 term 内，我的选票还没有投出去</li><li>若接收到多个 candidate 的请求，采取 first-come-first-served 方式投票</li></ul><ol start="3"><li>等待响应</li></ol><p>当一个 Candidate 发出投票请求后会等待其它节点的响应结果。</p><ul><li>收到过半选票，成为新的 leader。然后会将消息广播给所有其它节点，消息中包含 term 值</li><li>接收到别的 candidate 发来的新 leader 通知，比较新 leader 的 term 并不比自己的 term 小，则转变为 follower</li><li>一段时间内没有收到过半选票，也没有收到新 leader 通知，则重新发出选举</li></ul><ol start="4"><li>选举时机</li></ol><p>可能会出现较多 candidate 票数相同的情况，即无法选举出 Leader。</p><p>为了防止这种情况的发生，Raft 算法采用了 randomized election timeouts 策略。其会为这些 Follower 随机分配一个选举发起时间 election timeout，这个 timeout 在 150-300ms 范围内。只有到达了 election timeout 时间的 Follower 才能转变为 candidate， 否则等待。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>正常运行期间， Leader 通过日志复制管理实现集群中各节点数据的同步。</p><p>Raft 算法一致性的实现，是基于日志复制状态机的。状态机的最大特征是，不同 Server 中的状态机若当前状态相同，然后接受了相同的输入，则一定会得到相同的输出。</p><h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>当 leader 接收到 client 的写操作请求后，大体会经历以下流程：</p><ul><li>leader 在接收到 client 的写操作请求后，leader 会将数据与 term 封装为一个 box，并随着下一次心跳发送给所有 followers，以征求大家对该 box 的意见。同时在本地将数据封 装为日志</li><li>follower 在接收到来自 leader 的 box 后首先会比较该 box 的 term 与本地记录的曾接受过的 box 的最大 term，只要不比自己的小就接受该 box，并向 leader 回复同意。同时会将 该 box 中的数据封装为日志。</li><li>当 leader 接收到过半同意响应后，会将日志 commit 到自己的状态机，状态机会输出一个结果，同时日志状态变为了 committed</li><li>同时 leader 还会通知所有 follower 将日志 commit 到它们本地的状态机，日志状态变为了 committed</li><li>在 commit 通知发出的同时，leader 也会向 client 发出成功处理的响应</li></ul><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>在多机房部署中，由于网络连接问题，很容易形成多个分区。而多分区的形成，很容易产生脑裂，从而导致数据不一致。</p><p>三机房部署的容灾能力最强，下面以三机房部署为例进行分析</p><p>1. </p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/247a6c5585c613f749024b58fefa4d3d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/247a6c5585c613f749024b58fefa4d3d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="247a6c5585c613f749024b58fefa4d3d.png" ><p>B 机房中的主机感知不到 Leader 的存在，所以 B 机房中的主机会发起新一轮的 Leader 选举。由于 B 机房与 C 机房是相连的，虽然 C 机房中的 Follower 能够感 知到 A 机房中的 Leader，但由于其接收到了更大 term 的投票请求，所以 C 机房的 Follower 也就放弃了 A 机房中的 Leader，参与了新 Leader 的选举。</p><p>若新 Leader 出现在 B 机房，A 机房感知不到新 Leader 的诞生，不会转为follower，形成脑裂。此时 A 机房 Leader 处理的写操作请求无法获取到过半响应，所以无法完成写操作。若新 Leader 出现在 C 机房，A 机房中的 Leader 会自动下线。</p><p>2. </p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d631f10ecca6818b6c4282c620f39108.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d631f10ecca6818b6c4282c620f39108.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d631f10ecca6818b6c4282c620f39108.png" ><p>不会形成脑裂</p><p>3. </p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/197ceb97649f1a83a21a9a55162d5efb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/197ceb97649f1a83a21a9a55162d5efb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="197ceb97649f1a83a21a9a55162d5efb.png" ><p>B 无法选举出新的 Leader，无法提供任何服务</p><p>4. </p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/df2452663c93db94c26df3f274a2ee1d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/df2452663c93db94c26df3f274a2ee1d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="df2452663c93db94c26df3f274a2ee1d.png"></p><p>对于集群的运作不产生影响</p><ol start="5"><li>A、B、C 全部断开</li></ol><p>A 机房无法处理写操作请求，但可以对外提供读服务。B、C 无法提供服务</p><h3 id="Leader-宕机处理"><a href="#Leader-宕机处理" class="headerlink" title="Leader 宕机处理"></a>Leader 宕机处理</h3><ol><li>请求到达前宕机</li></ol><p>对集群数据的一致性没有任何影响。</p><ol start="2"><li>未开始同步数据前宕机</li></ol><p>接受到的数据丢失</p><ol start="3"><li>同步完部分后宕机</li></ol><p>client 发送写操作请求给 Leader，Leader 接收完数据后向所有 Follower 发送数据。在部分 Follower 接收到数据后 Leader 挂了。</p><ul><li>若 Leader 产生于已完成数据接收的 Follower，其会继续将前面接收到的写操作请求转换为日志，并写入到本地状态机，并向所有 Flollower 发出询问。在获取过半同意响应后会向所有 Followers 发送 commit 指令，同时向 client 进行响应。</li><li>若 Leader 产生于尚未完成数据接收的 Follower，那么原来已完成接收的 Follower 则会放弃曾接收到的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第三章</title>
      <link href="/2023/12/16/Redis/3.Redis%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/12/16/Redis/3.Redis%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>Redis 具有持久化功能，其会按照设置以<strong>快照</strong>或<strong>操作日志</strong>的形式将数据持久化到磁盘。根据持久化使用技术的不同，Redis 的持久化分为两种：<strong>RDB</strong> 与 <strong>AOF</strong>。</p><p>Redis 持久化也称为钝化，不同的持久化技术对数据的状态描述信息是不同的，生成的持久化文件也是不同的。但它们的作用都是相同的：避免数据意外丢失。</p><p>当系统重新启动时，自动加载持久化文件，并根据文件中数据库状态描述信息将数据恢复到内存中，这个数据恢复过程也称为激活。这个钝化与激活的过程就是 Redis 持久化的基本原理。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140422.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140422.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7f43d998232c996c3e19a6d0f09d999c.png"></p><p>RDB 是默认持久化方式，Redis 允许 RDB 与 AOF 两种持久化技术同时开启，但AOF 持久化技术的优先级要更高，系统会使用 AOF 方式做持久化。同样的，两种技术同时开启状态，系统启动时若两种持久化文件同时存在，则优先加载 AOF 持久化文件。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>RDB：Redis DataBase，指将内存中某一时刻的数据快照全量写入到指定的 rdb 文件的持久化技术。</p><p>RDB 持久化的执行有三种方式：</p><ol><li>手动 save 命令</li></ol><p>通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。save 命令在执行期间会阻塞 redis-server 进程，直至持久化过程完毕。而在 redis-server 进程阻塞期间，Redis 不能处理任何读写请求，无法对外提供服务。</p><ol start="2"><li>手动 <strong>bgsave</strong> 命令</li></ol><p>通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。bgsave 命令会使服务器进程 redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程中，不会阻塞 redis-server 进程对客户端读写请求的处理。</p><ol start="3"><li>自动条件触发。</li></ol><p>自动条件触发的本质仍是 bgsave 命令的执行。只不过是用户通过在配置文件中做相应 的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。</p><ul><li><strong>lastsave</strong></li></ul><p>通过 lastsave 命令可以查看最近一次执行持久化的时间，其返回的是一个 Unix 时间戳。</p><h3 id="RDB-优化配置"><a href="#RDB-优化配置" class="headerlink" title="RDB 优化配置"></a>RDB 优化配置</h3><p>RDB 相关的配置在 redis.conf 文件的 SNAPSHOTTING 部分。</p><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>该配置用于设置快照的自动保存触发条件。该触发条件是在指 定时间段内发生了指定次数的写操作。</p><p>默认情况下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 3600 1   # 在 3600 秒(1 小时)内发生 1 次写操作</span><br><span class="line">save 300 100  # 在 300 秒(5 分钟)内发生 100 次写操作</span><br><span class="line">save 60 10000 # 在 60 秒(1 分钟)内发生 1 万次写操作</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140432.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140432.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="cc6afc1ae93bc20e219e5ac4ce2cca73.png"></p><h4 id="stop-write-on-bgsave-error"><a href="#stop-write-on-bgsave-error" class="headerlink" title="stop-write-on-bgsave-error"></a>stop-write-on-bgsave-error</h4><p>默认情况下，如果 RDB 快照已启用（至少一个保存点），且最近的 bgsave 命令失败，Redis 将停止接受写入。这样设置是为了让用户意识到数据没有正确地保存到磁盘上。如果 bgsave 命令又可以正常工作了，Redis 将自动允许再次写入。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140433.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140433.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a77c033e13bf68d9c5e81fa18f7f28c8.png"></p><h4 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a>rdbcompression</h4><p>当进行持久化时启用 LZF 压缩字符串对象。虽然压缩 RDB 文件会消耗系统资源，降低性能，但可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140442.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e9b8660fb720cb475b5413c5ac60c735.png"></p><h4 id="rdbchecksum"><a href="#rdbchecksum" class="headerlink" title="rdbchecksum"></a>rdbchecksum</h4><p>从 RDB5 开始，RDB 文件的 CRC64 校验和就被放置在了文件末尾。这使格式更能抵抗 RDB 文件的损坏，但在保存和加载 RDB 文件时，性能会受到影响（约 10%），因此可以设置为 no 禁用校验和以获得最大性能。在禁用校验和的情况下创建的 RDB 文件的校验和为零，这将告诉加载代码跳过校验检查。默认开启校验功能。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140449.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140449.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="872ef1e235f879d54096e56d385a217a.png"></p><h4 id="sanitize-dump-payload"><a href="#sanitize-dump-payload" class="headerlink" title="sanitize-dump-payload"></a>sanitize-dump-payload</h4><p>该配置用于设置在加载 RDB 文件或进行持久化时是否开启对 zipList、listPack 等数据的全面安全检测。该检测可以降低命令处理时发生系统崩溃的可能。其可设置的值有三种选择：</p><ul><li>no：不检测</li><li>yes：总是检测</li><li>clients：只有当客户端连接时检测。排除了加载 RDB 文件与进行持久化时的检测。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140519.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140519.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4dec2c6e545f22c09b4a4d3b5b24972a.png"></p><p>默认值本应该是 clients，但其会影响 Redis 集群的工作，所以默认值为 no</p><h4 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a>dbfilename</h4><p>指定 RDB 文件的默认名称，默认为 dump.rdb。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140459.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140459.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1692468e1e5c776015d555a35d8a4fdd.png"></p><h4 id="rdb-del-sync-files"><a href="#rdb-del-sync-files" class="headerlink" title="rdb-del-sync-files"></a>rdb-del-sync-files</h4><p>主从复制时，是否删除用于同步的从机上的 RDB 文件。默认是 no，不删除。只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140507.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140507.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a0d9a75f9e97df7d25ec37cdd58858c2.png"></p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>指定 RDB 与 AOF 文件的生成目录。默认为 Redis 安装根目录。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140529.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140529.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0a3ec54b0bb326cb081f0bbd22ca687c.png"></p><h3 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140535.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140535.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4eac0d868410cb5bee138627ab339947.png"></p><ol><li>SOF</li></ol><p>SOF 是一个常量，一个字符串 REDIS，仅包含这五个字符，其长度为 5。用于标识 RDB 文件的开始，以便在加载 RDB 文件时可以迅速判断出文件是否是 RDB 文件。</p><ol start="2"><li>rdb_version</li></ol><p>这是一个整数，长度为 4 字节，表示 RDB 文件的版本号。</p><ol start="3"><li>EOF</li></ol><p>EOF 是一个常量，占 1 个字节，用于标识 RDB 数据的结束，校验和的开始。</p><ol start="4"><li>check_sum</li></ol><p>校验和 check_sum 用于判断 RDB 文件中的内容是否出现数据异常。其采用的是 CRC 校验算法。这种验证算法是数据损坏校验，即使损坏也有可能通过检验。</p><ol start="5"><li>databases</li></ol><p>databases 部分是 RDB 文件中最重要的数据部分，其可以包含任意多个非空数据库。而每个 database 又是由三部分构成：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140546.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f241f8c481d5d89c3c0aa068fddc9bd0.png"></p><ul><li>SODB：是一个常量，占 1 个字节，用于标识一个数据库的开始。</li><li>db_number：数据库编号。</li><li>key_value_pairs：当前数据库中的键值对数据。</li></ul><p>每个 key_value_pairs 又由很多个用于描述键值对的数据构成。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140549.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140549.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6fd7ca8cd1e3be46ff926bf31af3c869.png"></p><ul><li>VALUE_TYPE：是一个常量，占 1 个字节，用于标识该键值对中 value 的类型。</li><li>EXPIRETIME_UNIT：是一个常量，占 1 个字节，用于标识过期时间的单位是秒还是毫秒。</li><li>time：当前 key-value 的过期时间。</li></ul><h3 id="RDB-持久化过程"><a href="#RDB-持久化过程" class="headerlink" title="RDB 持久化过程"></a>RDB 持久化过程</h3><p>在进行 bgsave 持久化时，redis-server 进程会 fork 出一个 bgsave 子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server 进程不会阻塞，其会继续接收并处理用户的读写请求。</p><p>bgsave 子进程的详细工作原理：</p><p>子进程可以继承父进程的所有资源，则 bgsave 子进程有权读取到 redis-server 进程写入到内存中的用户数据，bgsave 子进程在持久化时首先会将内存中的全量数据 copy 到磁盘中的一个 RDB 临时文件，copy 结束后，再将该文件 rename 为 dump.rdb，替换掉原来的同名文件。</p><p>在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据 copy 到 RDB 临时文件。这个副本的生成是基于 Linux 系统的写时复制技术 （Copy-On-Write）实现的。</p><blockquote><p>写时复制技术是 Linux 系统的一种进程管理技术。</p><p>原本在 Unix 系统中，当一个主进程通过 fork()系统调用创建子进程后，内核进程会复制主进 程的整个内存空间中的数据，然后分配给子进程。这种方式存在的问题有以下几点：</p><ol><li><p>过程非常耗时</p></li><li><p>过程降低了系统性能</p></li><li><p>如果主进程修改了其内存数据，子进程副本中的数据是没有修改的。即出现了数据冗余， 而冗余数据最大的问题是数据一致性无法保证。</p></li></ol><p>现代的 Linux 则采用了更为有效的方式：写时复制。子进程会继承父进程的所有资源，其中就包括主进程的内存空间。即子进程与父进程共享内存。只要内存被共享，那么该内存就是只读的（写保护的）。而写时复制则是在任何一方需要写入数据到共享内存时都会出现异常， 此时内核进程就会将需要写入的数据 copy 出一个副本写入到另外一块非共享内存区域。</p></blockquote><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>AOF，Append Only File，是指 Redis 将每一次的写操作都以日志的形式记录到一个 AOF 文件中的持久化技术。当需要恢复内存数据时，将这些写操作重新执行一次，便会恢复到之前的内存数据状态。</p><h3 id="AOF-基础配置"><a href="#AOF-基础配置" class="headerlink" title="AOF 基础配置"></a>AOF 基础配置</h3><p>AOF持久化默认是关闭的，我们可以通过修改配置文件中的 appendonly 属性，或执行以下代码开启：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140556.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140556.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bd41b60376d50c29a9f2b18e3d394e04.png"></p><h4 id="文件名配置"><a href="#文件名配置" class="headerlink" title="文件名配置"></a>文件名配置</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140614.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140614.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="137469f6c9567d11e789dca1007246e6.png"></p><p>Redis 7 在这里发生了重大变化。以前版本只会生成一个 appendonly.aof 文件，现在具有了三类文件：</p><ul><li>基本文件：可以是 RDB 格式也可以是 AOF 格式。其存放的内容是由 RDB 转为 AOF 时内存的快照数据。该文件可以有多个。</li><li>增量文件：以操作日志形式记录转为 AOF 后的写入操作。该文件可以有多个。</li><li>清单文件：用于维护 AOF 文件的创建顺序，保障激活时的应用顺序。该文件只有一个。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140607.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140607.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3d0cf6396f3b6415e11a3ea6e4b394fe.png"></p><h4 id="AOF-文件目录配置"><a href="#AOF-文件目录配置" class="headerlink" title="AOF 文件目录配置"></a>AOF 文件目录配置</h4><p>为了方便管理，可以专门为 AOF 持久化文件指定存放目录。目录名由 appenddirname 属性指定，存放在 redis.conf 配置文件的 dir 属性指定的目录，默认为 Redis 安装目录。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140645.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140645.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6e6de5f3993879e751611a057f801799.png"></p><h4 id="混合式持久化开启"><a href="#混合式持久化开启" class="headerlink" title="混合式持久化开启"></a>混合式持久化开启</h4><p>基本文件可以是 RDF 格式也可以是 AOF 格式。通过 aof-use-rdb-preamble 属性可以选择。其默认值为 yes，即默认 AOF 持久化的基本文件为 rdb 格式文件，也就是默认采用混合式持久化。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140655.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140655.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ea6a238d14cf67e9332893aae7b6515c.png"></p><h3 id="AOF-文件格式"><a href="#AOF-文件格式" class="headerlink" title="AOF 文件格式"></a>AOF 文件格式</h3><p>AOF 文件包含三类文件：基本文件、增量文件与清单文件。其中基本文件一般为 rdb 格式，不再赘述</p><h4 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a>Redis 协议</h4><p>增量文件扩展名为.aof，采用 AOF 格式。</p><p>AOF 格式其实就是 Redis 通讯协议格式，AOF 持久化文件的本质就是基于 Redis 通讯协议的文本，将命令以纯文本的方式写入到文件中。</p><p>Redis 协议规定，Redis 文本是以行来划分，每行以 \r\n 行结束。每一行都有一个消息头， 以表示消息类型。消息头由六种不同的符号表示，其意义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(+) 表示一个正确的状态信息</span><br><span class="line">(-) 表示一个错误信息</span><br><span class="line">(*) 表示消息体总共有多少行，不包括当前行</span><br><span class="line">($) 表示下一行消息数据的长度，不包括换行符长度\r\n</span><br><span class="line">(空) 表示一个消息数据</span><br><span class="line">(:) 表示返回一个数值</span><br></pre></td></tr></table></figure><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>清单文件：appendonly.aof.manifest</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140701.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140701.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="14baab60ad4e00f929c83edb760d2aa3.png"></p><p>该文件首先会按照 seq 序号列举出所有基本文件，基本文件 type 类型为 b，然后再按照 seq 序号再列举出所有增量文件，增量文件 type 类型为 i。对于 Redis 启动时的数据恢复，也会按照该文件由上到下依次加载它们中的数据。</p><h3 id="Rewrite-机制"><a href="#Rewrite-机制" class="headerlink" title="Rewrite 机制"></a>Rewrite 机制</h3><p>随着使用时间的推移，AOF 文件会越来越大。为了防止 AOF 文件由于太大而占用大量的磁盘空间，降低性能，Redis 引入了 Rewrite 机制来对 AOF 文件进行压缩。</p><p>所谓 Rewrite 其实就是对 AOF 文件进行重写整理。当 Rewrite 开启后，主进程 redis-server 创建出一个子进程 bgrewriteaof，由该子进程完成 rewrite 过程。其首先对现有 aof 文件进行 rewrite 计算，将计算结果写入到一个临时文件，写入完毕后，再 rename 该临时文件为原 aof 文件名，覆盖原有文件。</p><p>rewrite 计算也称为 rewrite 策略。rewrite 计算遵循以下策略：</p><ul><li>读操作命令不写入文件</li><li>无效命令不写入文件</li><li>过期数据不写入文件</li><li>多条命令合并写入文件</li></ul><h4 id="开启rewrite"><a href="#开启rewrite" class="headerlink" title="开启rewrite"></a>开启rewrite</h4><p>手动开启：<strong>bgrewriteaof</strong> </p><p>Rewrite 过程的执行有两种方式。一种是通过 bgrewriteaof 命令手动开启，一种是通过设置条件自动开启。</p><p>bgrewriteaof 命令会使主进程 redis-server 创建出一个子进程，由该子进程完成 rewrite 过程。而在 rewrite 期间，redis-server 仍可以对外提供读写服务。</p><p>自动开启：</p><p>由于 Rewrite 过程是一个计算过程，需要消耗大量系统资源，会降低系统性能。所以，Rewrite 过程并不是随时随地任意开启的，而是通过设置一些条件，当满足条件后才会启动，以降低对性能的影响。</p><p>配置文件中对于 Rewrite 自动启动条件的设置：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216141159.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216141159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="322ce86abd9d38a4a03f73d85315b8aa.png"></p><ul><li>auto-aof-rewrite-percentage：开启 rewrite 的增大比例，默认 100%。指定为 0，表示禁用自动 rewrite。</li></ul><blockquote><p>当文件大小翻了一倍执行 Rewrite </p></blockquote><ul><li>auto-aof-rewrite-min-size：开启 rewrite 的 AOF 文件最小值，默认 64M。该值的设置主要是为了防止小 AOF 文件被 rewrite，从而导致性能下降。</li></ul><p>自动重写 AOF 文件。当 AOF 日志文件大小增长到指定的百分比时，Redis 主进程 redis-server 会 fork 出一个子进程 bgrewriteaof 来完成 rewrite 过程。</p><p>工作原理如下：Redis 会记住最新 rewrite 后的 AOF 文件大小作为基本大小，如果从主机启动后就没有发生过重写，则基本大小就使用启动时 AOF 的大小。当 AOF 文件大于基本大小的配置文件中指定的百分比阈值，且当前 AOF 文件大 于配置文件中指定的最小阈值，则会触发 rewrite。</p><h3 id="AOF-优化配置"><a href="#AOF-优化配置" class="headerlink" title="AOF 优化配置"></a>AOF 优化配置</h3><h4 id="appendfsync"><a href="#appendfsync" class="headerlink" title="appendfsync"></a>appendfsync</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/a8e01ed4c50adfd014e12d4e07934266.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/a8e01ed4c50adfd014e12d4e07934266.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a8e01ed4c50adfd014e12d4e07934266.png"></p><p>当客户端提交写操作命令后，该命令就会写入到 aof_buf 中，而 aof_buf 中的数据持久化到磁盘 AOF 文件的过程称为数据同步。</p><p>此选项用于修改数据同步策略：</p><ul><li>always：写操作命令写入 aof_buf 后会立即调用 fsync()系统函数，将其追加到 AOF 文件。该策略效率较低，但最安全，最多丢失一条数据</li><li>no：将 aof_buf 中数据同步磁盘的操作交由操作系统负责。Linux 系统默认同步周期为 30 秒。效率最高。</li><li>everysec：默认策略。写操作命令写入 aof_buf 后并不直接调用 fsync()，而是每秒调用一次 fsync()系统函数来完成同步。该策略兼顾到了性能与安全</li></ul><h4 id="no-appendfsync-on-rewrite"><a href="#no-appendfsync-on-rewrite" class="headerlink" title="no-appendfsync-on-rewrite"></a>no-appendfsync-on-rewrite</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140728.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140728.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e5aa553bd654fd5af4b337b09c3eb961.png"></p><p>该属性用于指定当 AOF fsync 策略设置为 always 或 everysec，且主进程创建了子进程正在执行 bgsave 或 bgrewriteaof 时，主进程是否不调用 fsync()来做数据同步。设置为 no，主进程会调用 fsync()做同步。而 yes 则不会调用 fsync() 做数据同步。</p><p>如果在需要同步的数据量非常大时调用 fsync()，会阻塞主进程对外提供服务，即会存在延迟问题。如果不调用 fsync()，则 AOF fsync 策略相当于设置为了 no，可能会存在 30 秒数据丢失的风险。</p><h4 id="aof-rewrite-incremental-fsync"><a href="#aof-rewrite-incremental-fsync" class="headerlink" title="aof-rewrite-incremental-fsync"></a>aof-rewrite-incremental-fsync</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140749.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231216140749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5de4787af096291fc24a960b8480867a.png"></p><p>当 bgrewriteaof 在执行过程也是先将 rewrite 计算的结果写入到了 aof_rewrite_buf 缓存中，然后当缓存中数据达到一定量后就会调用 fsync() 进行刷盘操作，将数据写 入到临时文件。该属性用于控制 fsync()每次刷盘的数据量最大不超过 4MB。这样可以避免由 于单次刷盘量过大而引发长时间阻塞。</p><h4 id="aof-load-truncated"><a href="#aof-load-truncated" class="headerlink" title="aof-load-truncated"></a>aof-load-truncated</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bb68df51a2b6904ad2890b9d269f8647.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bb68df51a2b6904ad2890b9d269f8647.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bb68df51a2b6904ad2890b9d269f8647.png"></p><p>该属性用于指定当 AOF 文件的最后一条数据不完整时 Redis 能否启动</p><p>yes：AOF 文件最后不完整的数据直接截断删除，不影响 Redis 的启动。no：不可以被截断删除，Redis 无法启动。</p><blockquote><p>当损坏的数据不是最后一条时也不能启动</p><p>我们可以使用 AOF 修复工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#检测文件</span><br><span class="line">redis-check-aof appendonly.aof.1.incr.aof</span><br><span class="line">#修复</span><br><span class="line">redis-check-aof --fix appendonly.aof.1.incr.aof</span><br></pre></td></tr></table></figure><p>其实就是把错误数据及以后的数据全部截断</p></blockquote><h4 id="aof-timestamp-enabeld"><a href="#aof-timestamp-enabeld" class="headerlink" title="aof-timestamp-enabeld"></a>aof-timestamp-enabeld</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/49cbf160fb3b0e64248a06bf229d70a5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/49cbf160fb3b0e64248a06bf229d70a5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="49cbf160fb3b0e64248a06bf229d70a5.png"></p><p>该属性设置为 yes 则会开启在 AOF 文件中增加时间戳的显示功能，可方便按照时间对数据进行恢复。但该方式可能会与 AOF 解析器不兼容，所以默认值为 no，不开启。</p><h3 id="AOF-持久化过程"><a href="#AOF-持久化过程" class="headerlink" title="AOF 持久化过程"></a>AOF 持久化过程</h3><ol><li>Redis 接收到的写操作命令并不是直接追加到磁盘的 AOF 文件的，而是将每一条写命令按照 redis 通讯协议格式暂时添加到 AOF 缓冲区 aof_buf。</li><li>根据设置的数据同步策略，当同步条件满足时，再将缓冲区中的数据一次性写入磁盘的 AOF 文件，以减少磁盘 IO 次数，提高性能。</li><li>当磁盘的 AOF 文件大小达到了 rewrite 条件时，redis-server 主进程会 fork 出一个子进程 bgrewriteaof，由该子进程完成 rewrite 过程。</li><li>子进程 bgrewriteaof 首先对该磁盘 AOF 文件进行 rewrite 计算，将计算结果写入到一个临时文件，全部写入完毕后，再 rename 该临时文件为磁盘文件的原名称，覆盖原文件。</li><li>如果在 rewrite 过程中又有写操作命令追加，那么这些数据会暂时写入 aof_rewrite_buf 缓冲区。等将全部 rewrite 计算结果写入临时文件后，会先将 aof_rewrite_buf 缓冲区中的数据写入临时文件，然后再 rename 为磁盘文件的原名称，覆盖原文件。</li></ol><h2 id="RDB-与-AOF-对比"><a href="#RDB-与-AOF-对比" class="headerlink" title="RDB 与 AOF 对比"></a>RDB 与 AOF 对比</h2><p>RDB 优势：RDB 文件较小；数据恢复较快</p><p>不足：数据安全性较差；写时复制会降低性能；RDB 文件可读性较差</p><p>AOF 优势：数据安全性高；AOF 文件可读性强</p><p>不足：AOF 文件较大；写操作会影响性能；数据恢复较慢</p><h3 id="持久化技术选型："><a href="#持久化技术选型：" class="headerlink" title="持久化技术选型："></a>持久化技术选型：</h3><ul><li>官方推荐使用 RDB 与 AOF 混合式持久化。</li><li>若对数据安全性要求不高，则推荐使用纯 RDB 持久化方式。</li><li>不推荐使用纯 AOF 持久化方式。</li><li>若 Redis 仅用于缓存，则无需使用任何持久化技术。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存组件</title>
      <link href="/2023/11/20/%E6%A1%86%E6%9E%B6/8.%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/11/20/%E6%A1%86%E6%9E%B6/8.%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>高并发在开发中属于一个核心话题，其中有一个极为重要的技术项，那就是缓存。</p><p>缓存可以减少数据库数据的查询压力，但缓存是一个庞大的话题，并不是说在整个的项目之中整一个内存或者是分布式的缓存就可以解决的问题。</p><p>和ORM框架（MyBatis等）之中的缓存相比：</p><ol><li>ORM框架几乎都支持缓存操作，但这些缓存都是在数据层上的缓存，键（key）通常是查询的SQL语句以及参数的组合，而值（value）是查询结果返回的Java对象，粒度比较粗。</li><li>而本文介绍的缓存更多的是业务层面上的缓存，用法更加灵活</li></ol><p>和Redis的缓存相比：</p><ol><li>Caffeine是单机版本的缓存组件，而Redis将数据放在其它服务器上，属于分布式的缓存组件</li><li>本地缓存多用来存储一些固定不变的热点数据，或精度要求不是很高的数据，例如视频弹幕等；而分布式缓存多用来存储会发生变化的热点数据，例如用户每日签到的日期记录。</li></ol><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>官网：<a href="https://github.com/ben-manes/caffeine">caffeine</a></p><p>Caffeine 是一个用于 Java 的高性能缓存库，它提供了灵活、高性能的缓存实现。</p><p>核心的两大顶级接口：<code>Cache</code>和<code>AsyncCache</code>，分别定义了同步缓存和异步缓存。</p><p>在Caffeine官方文档的代码示例中，我们可以了解到在组件中应该使用Caffeine工具类来获取Cache接口的对象实例。</p><p>简单测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">2</span>)<span class="comment">// 设置最大容量</span></span><br><span class="line">        .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)<span class="comment">// 设置过期时间</span></span><br><span class="line">        .build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);<span class="comment">// 添加缓存项</span></span><br><span class="line">    log.info(<span class="string">&quot;过期前，&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// 15</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">// 5s超时</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后，&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有缓存数据都是保存在内存中的，为了防止内存溢出导致应用程序崩溃，所以所有的缓存组件都提供了缓存数据的清理</p></blockquote><p>为了避免出现空指针的情况，组件提供了数据失效梳理的控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    log.info(<span class="string">&quot;过期前，&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">// 5s超时</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后数据失效处理，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test1&quot;</span>, (k) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 数据处理。。。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a>LoadingCache</h3><p><code>LoadingCache</code>是Cache的一个子接口，可以在声明缓存时搭配默认的缓存刷新方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LoadingCache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).build((k) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;LoadingCache数据加载。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    log.info(<span class="string">&quot;过期前，&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">// 5s超时</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后数据失效处理，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test1&quot;</span>, (k) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 数据处理。。。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;));<span class="comment">// 18；这里直接调用的是Cache接口的get方法，没有打印日志。</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后数据失效处理，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test2&quot;</span>));<span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：版本为2.9.3；在较低版本中，需要先调用<code>getAll()</code>方法才能正常刷新数据</p></blockquote><h3 id="AsyncLoadingCache"><a href="#AsyncLoadingCache" class="headerlink" title="AsyncLoadingCache"></a>AsyncLoadingCache</h3><p>异步数据加载操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;线程名&#123;&#125;&quot;</span>, Thread.currentThread().getName());<span class="comment">// main</span></span><br><span class="line">    AsyncLoadingCache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).buildAsync(<span class="keyword">new</span> <span class="title class_">AsyncCacheLoader</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@NonNull</span> CompletableFuture&lt;Integer&gt; <span class="title function_">asyncLoad</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> Executor executor)</span> &#123;</span><br><span class="line">            CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;线程名&#123;&#125;&quot;</span>, Thread.currentThread().getName());<span class="comment">// 异步ForkJoinPool</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">180</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> completableFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充数据有所不同</span></span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, CompletableFuture.completedFuture(<span class="number">15</span>));</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, CompletableFuture.completedFuture(<span class="number">18</span>));</span><br><span class="line">    log.info(<span class="string">&quot;过期前，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test1&quot;</span>).get());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">// 5s超时</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后数据失效处理，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test1&quot;</span>, (k) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;线程名&#123;&#125;&quot;</span>, Thread.currentThread().getName());<span class="comment">// 异步ForkJoinPool</span></span><br><span class="line">        <span class="comment">// 数据处理。。。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;).get());<span class="comment">// 18；这里直接调用的是Cache接口的get方法，没有打印日志。</span></span><br><span class="line">    log.info(<span class="string">&quot;过期后数据失效处理，&#123;&#125;&quot;</span>, cache.get(<span class="string">&quot;test2&quot;</span>).get());<span class="comment">// 180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p><code>Caffeine</code>和<code>SpringBoot</code>的版本之间是有对应关系的，好在<code>spring-boot-dependencies</code>包中指定了<code>Caffeine</code>的版本，不需要我们再去找兼容版本。</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;version&gt;3.1.6&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoursesInterceptor myInterceptor;</span><br><span class="line">    <span class="comment">// 发现这个自定义的线程池没有关闭日志</span></span><br><span class="line"><span class="comment">/*    @Bean</span></span><br><span class="line"><span class="comment">    public ThreadPoolExecutor myExecutor() &#123;</span></span><br><span class="line"><span class="comment">        log.info(&quot;自定义线程池创建&quot;);</span></span><br><span class="line"><span class="comment">        return new ThreadPoolExecutor(3, 6, 120, TimeUnit.SECONDS,</span></span><br><span class="line"><span class="comment">                new ArrayBlockingQueue&lt;&gt;(10),</span></span><br><span class="line"><span class="comment">                new ThreadFactory() &#123;</span></span><br><span class="line"><span class="comment">                    private int count;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    @Override</span></span><br><span class="line"><span class="comment">                    public Thread newThread(Runnable r) &#123;</span></span><br><span class="line"><span class="comment">                        Thread thread = new Thread(r);</span></span><br><span class="line"><span class="comment">                        thread.setName(&quot;myThreadPool-&quot; + count++);</span></span><br><span class="line"><span class="comment">                        return thread;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;,</span></span><br><span class="line"><span class="comment">                new ThreadPoolExecutor.AbortPolicy());</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Spring框架提供的一个线程池实现：ThreadPoolTaskExecutor;但还是没有关闭日志</span></span><br><span class="line"><span class="comment">     * 不放心可以使用<span class="doctag">@PreDestroy</span>在方法中进行关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">myExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        pool.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        pool.setMaxPoolSize(<span class="number">6</span>);</span><br><span class="line">        pool.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        pool.setKeepAliveSeconds(<span class="number">120</span>);</span><br><span class="line">        pool.setThreadNamePrefix(<span class="string">&quot;myThreadPool-&quot;</span>);</span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义缓存"><a href="#定义缓存" class="headerlink" title="定义缓存"></a>定义缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCacheUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoursesMapper coursesMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor myExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, List&lt;Courses&gt;&gt; courseCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, List&lt;Courses&gt;&gt; courseCache2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsyncLoadingCache&lt;Object, List&lt;Courses&gt;&gt; asyncCourseCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsyncLoadingCache&lt;Object, List&lt;Courses&gt;&gt; asyncCourseCache2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innit</span><span class="params">()</span> &#123;</span><br><span class="line">        courseCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">2</span>)</span><br><span class="line">                .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(k -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;===========缓存更新============&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">return</span> coursesMapper.selectList(Wrappers.lambdaQuery(Courses.class).in(Courses::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// CacheLoader 使用自己的线程池刷新数据；当不指定线程池时，Spring会帮我们创建 HikariPool</span></span><br><span class="line">        asyncCourseCache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).executor(myExecutor).buildAsync(k -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;===========异步缓存1更新============&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> coursesMapper.selectList(Wrappers.lambdaQuery(Courses.class).in(Courses::getId, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        courseCache2 = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">2</span>)</span><br><span class="line">                .expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(k -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;===========cache2缓存更新============&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> coursesMapper.selectList(Wrappers.lambdaQuery(Courses.class).in(Courses::getId, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要在构造器中使用自己创建的线程池刷新数据，可以使用下面的写法，这种方式也适用于构造器中初始化</span></span><br><span class="line">        <span class="comment">/*asyncCourseCache2 = Caffeine.newBuilder().maximumSize(2).expireAfterAccess(3L, TimeUnit.SECONDS).buildAsync(k -&gt; &#123;</span></span><br><span class="line"><span class="comment">            ListenableFutureTask&lt;List&lt;Courses&gt;&gt; futureTask = new ListenableFutureTask&lt;&gt;(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">                log.info(&quot;===========异步缓存2更新============&quot;);</span></span><br><span class="line"><span class="comment">                return coursesMapper.selectList(Wrappers.lambdaQuery(Courses.class).in(Courses::getId, 12));</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">            myExecutor.execute(futureTask);</span></span><br><span class="line"><span class="comment">            return futureTask.get();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AsyncCacheLoader 使用自己的线程池刷新数据</span></span><br><span class="line">        asyncCourseCache2 = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).buildAsync(<span class="keyword">new</span> <span class="title class_">AsyncCacheLoader</span>&lt;Object, List&lt;Courses&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@NonNull</span> CompletableFuture&lt;List&lt;Courses&gt;&gt; <span class="title function_">asyncLoad</span><span class="params">(<span class="meta">@NonNull</span> Object o, <span class="meta">@NonNull</span> Executor executor)</span> &#123;</span><br><span class="line">                CompletableFuture&lt;List&lt;Courses&gt;&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> coursesMapper.selectList(Wrappers.lambdaQuery(Courses.class).in(Courses::getId, <span class="number">15</span>));</span><br><span class="line">                &#125;, myExecutor);</span><br><span class="line">                <span class="keyword">return</span> completableFuture;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然也可以申明为final的，在构造器中初始化，这样就不需要@Data注解了</p><p>当不需要指定线程池时，刷新缓存的方法都是可以在构造器中声明的，毕竟构造器的执行在注入属性之前。</p></blockquote><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyCacheUtils myCacheUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * ? &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTest1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;Courses&gt; courses = myCacheUtils.getCourseCache().get(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    log.error(<span class="string">&quot;获取到缓存1的数据长度&#123;&#125;&quot;</span>, courses.size());</span><br><span class="line">    List&lt;Courses&gt; haha = myCacheUtils.getAsyncCourseCache().get(<span class="string">&quot;haha&quot;</span>).get();</span><br><span class="line">    log.error(<span class="string">&quot;获取到异步缓存1的数据长度&#123;&#125;&quot;</span>, haha.size());</span><br><span class="line">    List&lt;Courses&gt; courses1 = myCacheUtils.getCourseCache2().get(<span class="string">&quot;courses&quot;</span>);</span><br><span class="line">    log.error(<span class="string">&quot;获取到缓存2的数据长度&#123;&#125;&quot;</span>, courses1.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * ? &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTest2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;Courses&gt; haha = myCacheUtils.getAsyncCourseCache().get(<span class="string">&quot;enen&quot;</span>).get();</span><br><span class="line">    log.error(<span class="string">&quot;获取到异步缓存1的数据长度&#123;&#125;&quot;</span>, haha.size());</span><br><span class="line">    List&lt;Courses&gt; courses1 = myCacheUtils.getCourseCache2().get(<span class="string">&quot;courses&quot;</span>);</span><br><span class="line">    log.error(<span class="string">&quot;获取到缓存2的数据长度&#123;&#125;&quot;</span>, courses1.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * ? &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTest3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;Courses&gt; xixi = myCacheUtils.getAsyncCourseCache2().get(<span class="string">&quot;xixi&quot;</span>).get();</span><br><span class="line">    log.error(<span class="string">&quot;获取到异步缓存2的数据长度&#123;&#125;&quot;</span>, xixi.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不要纠结于键的值，当缓存中没有这个键或者这个键的值为空时，缓存就会执行“兜底方案”。</p><p>打印日志的线程是在主线程上的，而缓存1的刷新方案会阻塞线程，所以部分的日志会扎堆打印到控制台。</p><h2 id="缓存数据驱逐策略"><a href="#缓存数据驱逐策略" class="headerlink" title="缓存数据驱逐策略"></a>缓存数据驱逐策略</h2><p>JVM的GC一般我们不会手动调用，为了防止内存溢出，Caffeine为我们提供了一些驱逐策略。</p><h3 id="容量驱逐策略"><a href="#容量驱逐策略" class="headerlink" title="容量驱逐策略"></a>容量驱逐策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));</span><br><span class="line">    cache.put(<span class="string">&quot;test3&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));<span class="comment">// 18</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test3&quot;</span>));<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权重驱逐策略"><a href="#权重驱逐策略" class="headerlink" title="权重驱逐策略"></a>权重驱逐策略</h3><p>注意：权重和容量驱逐策略存在冲突，不能同时设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumWeight(<span class="number">100</span>).weigher((k, v) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 自定义键值比较规则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">51</span>;</span><br><span class="line">    &#125;).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));<span class="comment">// 18</span></span><br><span class="line">    cache.put(<span class="string">&quot;test3&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));<span class="comment">// 18</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test3&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    cache.put(<span class="string">&quot;test4&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));<span class="comment">// 18</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test3&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test4&quot;</span>));<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当历史权重的积累大于设定值后，便不能继续添加数据。</p></blockquote><p>当极短时间内同时插入数据，会出现覆盖的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumWeight(<span class="number">100</span>).weigher((k, v) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 自定义键值比较规则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">51</span>;</span><br><span class="line">    &#125;).expireAfterAccess(<span class="number">3L</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test3&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test4&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>));<span class="comment">// 15</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test3&quot;</span>));<span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test4&quot;</span>));<span class="comment">// 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间驱逐策略"><a href="#时间驱逐策略" class="headerlink" title="时间驱逐策略"></a>时间驱逐策略</h3><p>除了之前使用过的读之后开始计时，还可以设置写之后开始计时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">2</span>).expireAfterWrite(<span class="number">3L</span>, TimeUnit.SECONDS).build();</span><br></pre></td></tr></table></figure><h3 id="定制化驱逐策略"><a href="#定制化驱逐策略" class="headerlink" title="定制化驱逐策略"></a>定制化驱逐策略</h3><p>定制化的缓存驱逐策略可以通过Expiry接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().initialCapacity(<span class="number">2</span>).maximumSize(<span class="number">3</span>)</span><br><span class="line">        .expireAfter(<span class="keyword">new</span> <span class="title class_">Expiry</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterCreate</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> Integer integer, <span class="type">long</span> l)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;创建后失效计算key=&#123;&#125;&quot;</span>, s);</span><br><span class="line">                <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterUpdate</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> Integer integer, <span class="type">long</span> l, <span class="meta">@NonNegative</span> <span class="type">long</span> l1)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;更新后失效计算key=&#123;&#125;&quot;</span>, s);</span><br><span class="line">                <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterRead</span><span class="params">(<span class="meta">@NonNull</span> String s, <span class="meta">@NonNull</span> Integer integer, <span class="type">long</span> l, <span class="meta">@NonNegative</span> <span class="type">long</span> l1)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;读取后失效计算key=&#123;&#125;&quot;</span>, s);</span><br><span class="line">                <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test3&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    log.info(<span class="string">&quot;test1:&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>)); <span class="comment">// 15</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">&quot;test1:&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">&quot;test2:&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>)); <span class="comment">// 18</span></span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    log.info(<span class="string">&quot;test2:&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">&quot;test3:&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test3&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，Expiry是支持函数式的接口。</p><p>只要满足设置的任何一个过期条件，数据就会自动过期。</p></blockquote><h3 id="JVM驱逐"><a href="#JVM驱逐" class="headerlink" title="JVM驱逐"></a>JVM驱逐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().initialCapacity(<span class="number">2</span>).maximumSize(<span class="number">3</span>)</span><br><span class="line">        .weakKeys()     <span class="comment">// 弱引用的key</span></span><br><span class="line">        .weakValues()   <span class="comment">// 若应用的value</span></span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;test1&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">18</span>);</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(key)); <span class="comment">// 18</span></span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    Runtime.getRuntime().gc();<span class="comment">// 强制GC</span></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(key)); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识复习：Java中的四种引用关系</p><ul><li>强引用：垃圾回收器不会回收被强引用的对象</li><li>软引用：当内存不足时可能被回收</li><li>弱引用：随时可能被回收</li><li>虚引用：相当没有引用，无法通过引用获取对象的实例，主要用于对象被垃圾回收时收到系统通知</li></ul><blockquote><p>注意：异步缓存不支持这种GC的操作过程</p></blockquote><h2 id="缓存数据删除与监听"><a href="#缓存数据删除与监听" class="headerlink" title="缓存数据删除与监听"></a>缓存数据删除与监听</h2><p>对于缓存数据的删除有两种方式：</p><ol><li>基于自动驱逐策略的方式实现</li><li>使用<code>invalidate()</code>方法手工删除</li></ol><p>在进行组件设计的时候，一般都会提供数据的回调操作，Caffeine组件中也提供了一个删除监听的操作，删除数据之前可以执行一些操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().initialCapacity(<span class="number">2</span>).maximumSize(<span class="number">3</span>)</span><br><span class="line">        .removalListener(<span class="keyword">new</span> <span class="title class_">RemovalListener</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(<span class="meta">@Nullable</span> String s, <span class="meta">@Nullable</span> Integer integer, <span class="meta">@NonNull</span> RemovalCause removalCause)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;数据&#123;&#125;被删除，原因是&#123;&#125;&quot;</span>, s, removalCause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>)); <span class="comment">// 18</span></span><br><span class="line">    cache.invalidate(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, cache.getIfPresent(<span class="string">&quot;test1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CacheStats"><a href="#CacheStats" class="headerlink" title="CacheStats"></a>CacheStats</h2><p>Caffeine开发组件有一个最为重要的特点是自带有数据的统计功能，例如：缓存查询的次数，查询成功次数，查询失败次数。</p><p>默认情况下没有开启此数据的统计信息。 如果想获取到统计数据，则需要使用到Caffeine开发类提供的处理方法。</p><p>Caffeine内部使用了一个StatsCounter的接口来实现数据信息的记录，ConcurrentStatsCouter是其实现类。</p><p>上面的接口仅仅是开启了数据统计的处理支持，但是如果想最终获取到这些统计的信息，还需要另一个方法的支持。</p><p>以下的操作结构图介绍了这些方法之间的联系：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231112171040.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231112171040.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d973144c53e5cb2f64a67aef0365f121.png"></p><h3 id="获取缓存的操作数据"><a href="#获取缓存的操作数据" class="headerlink" title="获取缓存的操作数据"></a>获取缓存的操作数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Cache&lt;String, Integer&gt; cache = Caffeine.newBuilder().initialCapacity(<span class="number">2</span>).maximumSize(<span class="number">3</span>)</span><br><span class="line">        .recordStats()</span><br><span class="line">        .removalListener(<span class="keyword">new</span> <span class="title class_">RemovalListener</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(<span class="meta">@Nullable</span> String s, <span class="meta">@Nullable</span> Integer integer, <span class="meta">@NonNull</span> RemovalCause removalCause)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;数据&#123;&#125;被删除，原因是&#123;&#125;&quot;</span>, s, removalCause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line">    cache.put(<span class="string">&quot;test1&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    cache.put(<span class="string">&quot;test2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;test3&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (String k : strings) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获取&#123;&#125;:&#123;&#125;&quot;</span>, k, cache.getIfPresent(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="type">CacheStats</span> <span class="variable">stats</span> <span class="operator">=</span> cache.stats();</span><br><span class="line">    log.info(<span class="string">&quot;缓存请求次数:&#123;&#125;&quot;</span>, stats.requestCount()); <span class="comment">// 300</span></span><br><span class="line">    log.info(<span class="string">&quot;缓存命中次数:&#123;&#125;&quot;</span>, stats.hitCount()); <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存驱逐算法"><a href="#缓存驱逐算法" class="headerlink" title="缓存驱逐算法"></a>缓存驱逐算法</h3><p>考虑数据的缓存，实际上有两点最为核心的话题：一个是缓存数据的命中率，另一个就是缓存的驱逐。</p><p>驱逐又有两点核心：一个是驱逐的算法，一个是驱逐的具体实现。</p><p>所有的缓存组件中都提供了三类缓存算法：FIFO、LRU、LFU(内部又拓展了<code>TinyLFU</code>和<code>W-TinyLFU</code>)</p><ol><li>FIFO(先进先出)</li></ol><p>这是一种早期使用的缓存算法，采用队列的形式实现缓存的存储，实现的核心依据在于：较早保存在缓存中的数据有可能不会再使用，一旦缓存中的容量不足时，会通过一个指针进行队首数据的删除，以置换出新的存储空间，保存新增的缓存项。</p><p><strong>缺页率的问题</strong>：最早存储的缓存数据一直属于热点数据，但由于队列长度的限制，可能会将这个热点数据删除，造成缓存数据丢失的问题。</p><blockquote><p>容易出现缓存雪崩的情况。</p></blockquote><ol start="2"><li>LRU(最近最久未使用)</li></ol><p>该算法不再是依据保存时间进行数据项的清除，而是通过数据最后一次访问的时间戳来进行排查，当缓存空间已经满员时，会将最久没有访问的数据进行清除。LRU是一种常见的缓存算法，在Redis以及Memcached分布式缓存之中使用较多。</p><blockquote><p>突发性的稀疏流量表现较好，即短时间内较少量但集中请求</p></blockquote><ol start="3"><li>LFU(最近最少使用)</li></ol><p>当缓存满时，会删除最近访问计数为0的数据，如果此时缓存中保存的数据计数全部大于1，则不会删除缓存的数据，同时也不保存新的缓存数据。</p><p>以上缓存的驱逐算法都面临一个实际的问题：某个数据当时非热点，但在某一个时刻成为了热点数据。</p><h4 id="TinyLFU算法"><a href="#TinyLFU算法" class="headerlink" title="TinyLFU算法"></a>TinyLFU算法</h4><p>使用LFU算法可以在固定的一段时间内达到较高的命中率，但是在LFU算法中需要维持缓存记录的频率信息（每次访问都要更新），会存在额外的开销。</p><blockquote><p>并且由于频次的处理问题，越早保存的数据，记录的频次就会较高，即使不在是热点数据。这样就会导致新的缓存项永远无法保存的问题。</p></blockquote><p>TinyLFU为了解决缓存频率信息记录空间的问题，在算法中认为数据访问15次就可以作为一个热点数据存在，而后按照位的方式进行统计（一个long数据类型可以保存64位的数据，可以统计16个数据），这样避免了传统Map实现统计频次的操作，节约了数据的体积。</p><p>针对新数据无法追加缓存的问题，TinyLFU中采用了一种“保持新鲜”的机制，当整体的统计数据达到一个顶峰数值后，所有记录的频率统计除2，解决了新数据与旧数据的缓存频次的公平问题。</p><h4 id="W-TinyLFU算法"><a href="#W-TinyLFU算法" class="headerlink" title="W-TinyLFU算法"></a>W-TinyLFU算法</h4><p>LRU算法的实现较为简单，但正对突发性的稀疏流量表现较好，可以适应热点数据的更替，但可能会造成缓存污染的问题（冷数据访问量激增然后再度变冷的情况）。</p><p>在W-TinyLFU算法中，将整个缓存区域分为两块，一块是Window缓存区（大小为当前缓存内存的1%），另一块为主缓存区（大小为当前缓存内存的99%），而后在主缓存区中又分为Protected区（大小为80%）和Probation区。</p><p>Window区域用于放新增加的缓存数据，可以解决稀疏流量的缓存加载问题，当Window填满后，会将其中的候选数据保存在Probation区域内，当Probation区域也满员后，会通过TinyLFU过滤器进行比对，保留有价值的候选数据，而无价值的数据则直接驱逐。</p><h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><h2 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在进行缓存实现时，Spring会考虑三种缓存的实现方案：JDK内置的缓存实现（<strong>ConcurrentHashMap</strong>）、第三方的缓存组件（EHCache、<strong>Caffeine</strong>）、分布式的缓存实现（Memcached、<strong>Redis</strong>）。</p><p>ConcurrentHashMap是JUC之中最为重要的部分之一，它可以在保证更新安全的前提下，提供良好的数据获取性能。</p><p>SpringCache之中为了便于缓存结构的管理，在<code>org.springframework.cache</code>包中提供了两个核心的标准接口，分别是：Cache实现接口、CacheManager管理接口。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231117223545.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231117223545.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117223515224"></p><p>Cache接口规定了缓存数据的保存、增加、失效以及清空处理的操作功能，而要想获取到Cache接口的实例，那么就需要通过CacheManager接口方法完成，所有的Cache对象都在CacheManager之中保存。</p><p>在进行缓存实现的过程中，Spring是基于Cache接口提供的方法进行缓存操作的，所以不同的缓存组件如果要接入到Spring之中，需要提供Cache接口的具体实现类。考虑到缓存的管理问题，在Spring中又提供了CacheManager接口，所有可以在应用中使用的Cache类型全部在该接口之中进行配置。</p><p>Spring环境中Cache的默认实现类是ConcurrentMapCache，通过内置的ConcurrentHashMap属性实现缓存数据的存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Object&gt; store;</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>创建配置类注入Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">myCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleCacheManager</span> <span class="variable">simpleCacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCacheManager</span>();</span><br><span class="line">        Set&lt;Cache&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;filledList&quot;</span>));</span><br><span class="line">        simpleCacheManager.setCaches(set);</span><br><span class="line">        <span class="keyword">return</span> simpleCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不创建CacheManager的bean对象也能正常使用</p></blockquote><p>在service方法上标注@Cacheable注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;filledList&quot;, cacheManager = &quot;myCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CoursesVO&gt; <span class="title function_">filledList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Courses&gt; courses = mapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    List&lt;CoursesVO&gt; coursesVO = mapMapper.toVO(courses);</span><br><span class="line">    <span class="keyword">return</span> coursesVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意在接口的方法上使用@Cacheable注解是无效的</p></blockquote><p>测试调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = MapStructRun.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCacheTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoursesService coursesService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coursesService != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;CoursesVO&gt; coursesVOS = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                coursesVOS = coursesService.filledList();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;coursesVOS:&#123;&#125;&quot;</span>, coursesVOS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;coursesService is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只查询了一次数据库。</p><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><table><thead><tr><th align="center">属性</th><th align="center">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">String[]</td><td align="left">定义缓存名称，可以配置多个缓存名称</td></tr><tr><td align="center">cacheNames</td><td align="center">String[]</td><td align="left">与value属性相同</td></tr><tr><td align="center">key</td><td align="center">String</td><td align="left">定义缓存KEY</td></tr><tr><td align="center">keyGenerator</td><td align="center">String</td><td align="left">定义KEY生成器</td></tr><tr><td align="center">cacheManager</td><td align="center">String</td><td align="left">定义要使用的缓存管理器名称</td></tr><tr><td align="center">cacheResolver</td><td align="center">String</td><td align="left">定义缓存解析器</td></tr><tr><td align="center">condition</td><td align="center">String</td><td align="left">定义缓存应用条件，支持SpEL语法</td></tr><tr><td align="center">unless</td><td align="center">String</td><td align="left">定义缓存排除条件，支持SpEL语法</td></tr><tr><td align="center">sync</td><td align="center">boolean</td><td align="left">定义同步缓存，采用阻塞策略进行缓存更新</td></tr></tbody></table><p>condition和unless是两个核心的配置属性，需要使用到特定的SpEL语法标记：</p><table><thead><tr><th align="center">调用范围目标</th><th align="center">位置</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">当前调用的方法名称</td><td align="center">root对象</td><td align="left">#root.methodName</td></tr><tr><td align="center">当前执行的方法</td><td align="center">root对象</td><td align="left">#root.method.name</td></tr><tr><td align="center">当前执行的目标对象</td><td align="center">root对象</td><td align="left">#root.target</td></tr><tr><td align="center">当前执行目标对象所属类</td><td align="center">root对象</td><td align="left">#root.targetClass</td></tr><tr><td align="center">当前调用参数列表</td><td align="center">root对象</td><td align="left">#root.arg[0]</td></tr><tr><td align="center">当前方法调用使用的缓存列表</td><td align="center">root对象</td><td align="left">#root.caches[0].name</td></tr><tr><td align="center">当前调用方法参数</td><td align="center">执行上下文</td><td align="left">例如<code>get(Emp vo)</code>，则 #vo.name</td></tr><tr><td align="center">方法执行的返回值</td><td align="center">执行上下文</td><td align="left">#result（#result.属性 表示返回的对象属性）</td></tr></tbody></table><h2 id="整合Caffeine"><a href="#整合Caffeine" class="headerlink" title="整合Caffeine"></a>整合Caffeine</h2><p>修改配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">myCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line">    Caffeine&lt;Object, Object&gt; caffeine = Caffeine.newBuilder().initialCapacity(<span class="number">5</span>).maximumSize(<span class="number">10</span>)</span><br><span class="line">        .expireAfterAccess(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    cacheManager.setCaffeine(caffeine);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在一个问题：<code>CaffeineCacheManager</code>不能正确导入，尽管导入了对应的依赖，甚至都可以直达目录，但就是导不了文件。</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试后确实可以设置缓存的过期时间，因为是直接将方法的返回结果作为缓存值，不存在异步更新。</p><p>另一种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">myCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleCacheManager</span> <span class="variable">simpleCacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCacheManager</span>();</span><br><span class="line">    Set&lt;Cache&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">CaffeineCache</span>(<span class="string">&quot;MyCache&quot;</span>,Caffeine.newBuilder().initialCapacity(<span class="number">5</span>)</span><br><span class="line">                              .maximumSize(<span class="number">10</span>).expireAfterAccess(<span class="number">5</span>, TimeUnit.SECONDS).build()));</span><br><span class="line">    simpleCacheManager.setCaches(set);</span><br><span class="line">    <span class="keyword">return</span> simpleCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，作为Spring家族的一员，也可以通过配置文件的形式配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.124.101/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">initialCapacity=5,maximumSize=10,expireAfterAccess=5s</span></span><br></pre></td></tr></table></figure><h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>前面使用caffeine设置缓存的更新时间和业务的相关性不大。</p><p>SpringCache 中提供了数据的更新操作，而且这种更新操作与业务直接相关。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231117225442.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231117225442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ce38f38b5d91c3e2c8b5f599a15ae87e.png"></p><p>如上图所述，当我们执行更新操作时，返回的对象实例会直接作为新的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;filledById&quot;, key = &quot;#id&quot;, unless = &quot;#result==null&quot;, cacheManager = &quot;myCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CoursesVO <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Courses</span> <span class="variable">courses</span> <span class="operator">=</span> mapper.selectById(id);</span><br><span class="line">    <span class="keyword">return</span> mapMapper.toVO(courses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut(cacheNames = &#123;&quot;filledById&quot;&#125;, key = &quot;#id&quot;, cacheManager = &quot;myCacheManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CoursesVO <span class="title function_">update</span><span class="params">(CoursesVO coursesVO)</span> &#123;</span><br><span class="line">    mapper.updateById(mapMapper.toEntity(coursesVO));</span><br><span class="line">    <span class="keyword">return</span> mapMapper.toVO(mapper.selectById(coursesVO.getId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用@CacheConfig注解统一整个类中的cacheManager</p></blockquote><p>感觉这种方式有点鸡肋，一般更新不会再进行查询，这种方式有点类似将缓存的查询前置到上一次更新了。</p><blockquote><p>或者说前端直接将整个VO传过来，更新后可以直接返回VO。</p><p>不推荐使用，容易造成数据不一致的问题，比如之前查询所有课程列表的缓存就还是旧数据。</p></blockquote><h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p>删除缓存还是很实用的，比如当我们进行更新或删除，可以将对应的某些查询方法的缓存进行删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// @CachePut(cacheNames = &#123;&quot;filledById&quot;&#125;)</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &#123;&quot;filledById&quot;,&quot;filledList&quot;&#125;, key = &quot;#coursesVO.id&quot;, allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(CoursesVO coursesVO)</span> &#123;</span><br><span class="line">    mapper.updateById(mapMapper.toEntity(coursesVO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>allEntries &#x3D; true 表示删除指定缓存中的所有条目，不管key是何值。</p></blockquote><p>但是测试发现不能满足要求，filledById缓存只想删除指定id的数据，我们可以使用@Caching注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// @CachePut(cacheNames = &#123;&quot;filledById&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    evict = &#123;</span></span><br><span class="line"><span class="meta">        @CacheEvict(cacheNames = &quot;filledById&quot;, key = &quot;#coursesVO.id&quot;),</span></span><br><span class="line"><span class="meta">        @CacheEvict(cacheNames = &quot;filledList&quot;, allEntries = true)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(CoursesVO coursesVO)</span> &#123;</span><br><span class="line">    mapper.updateById(mapMapper.toEntity(coursesVO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建模板并配置对应的<code>CacheManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">myTemplate</span><span class="params">(<span class="meta">@Autowired</span> LettuceConnectionFactory factory)</span> &#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; myTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">    myTemplate.setConnectionFactory(factory);</span><br><span class="line">    myTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">    myTemplate.setValueSerializer(RedisSerializer.json());</span><br><span class="line">    myTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">    myTemplate.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">    <span class="keyword">return</span> myTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; myRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">myCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RedisCacheWriter</span> <span class="variable">redisCacheWriter</span> <span class="operator">=</span> RedisCacheWriter.nonLockingRedisCacheWriter(myRedisTemplate.getConnectionFactory());</span><br><span class="line">    <span class="type">RedisCacheConfiguration</span> <span class="variable">redisCacheConfiguration</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(myRedisTemplate.getValueSerializer()))</span><br><span class="line">        .entryTtl(Duration.ofSeconds(<span class="number">60</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>为什么要考虑Redis的序列化：</p><p>默认的序列化形式按顺序保存所有的<strong>非 static 非 transient</strong>字段。</p><p>但是，这样保存的数据中有许多并非实际有效的信息，比如集合框架中的modCount，它是用来检查是否发生了并发修改的；比如 ArrayList 中，可能内部数组实际长度是50，而已使用可能是15。如果把整个数组全部序列化，是很浪费的。所以序列化时候要考虑这个问题，只序列化有效的部分。</p><p>总的来说，默认的序列化一般存在以下缺点：</p><ol><li>消耗更多空间</li><li>消耗更多时间</li></ol><p>序列化的逻辑并不了解对象本身的逻辑，它只能沿着默认的途径去遍历。过多并不需要的数据也就意味着需要更多的遍历过程。</p><ol start="3"><li>可能造成栈溢出</li></ol><p>因为序列化和反序列化是一个方法调用。对于List 等，原来的添加是分批次添加的，也可能一个个添加。如果把它放在一个默认的序列化方法中，在一个方法中执行过多的遍历，可能引起栈溢出。</p><p><strong>建议</strong></p><p>无论是否默认的序列化方法，主动声明 serialVersionUID。</p><ol><li>避免因为 uid 问题导致的不兼容，当 uid不同时，反序列化会报异常失败。</li><li>性能有所提升：如果没有声明 uid ，jvm 会在序列化时，自动计算出一个 uid</li></ol><p>如果类发生了任何一点变化，可能uid 都会不同，导致反序列化时出错；所以，如果不声明 uid ，就会导致可能一个小小的无关的变动，都会导致序列化不兼容</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第二章</title>
      <link href="/2023/11/12/Redis/2.Redis%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/11/12/Redis/2.Redis%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h1><ul><li>心跳命令 ping</li></ul><p>输入 ping 会看到 PONG 响应，说明客户端与 Redis 的连接是正常的</p><ul><li>读写键值命令</li></ul><p>set key value 会将指定 key-value 写入到 DB。get key 则会读取指定 key 的 value 值</p><ul><li>DB 切换命令</li></ul><p>在概述中有介绍 Redis 数据库情况。我们可以通过 select db索引来切换DB</p><ul><li>查看 key 数量</li></ul><p>dbsize 命令可以查看当前数据库中 key 的数量。</p><ul><li>删除库中数据</li></ul><p>flushdb 命令仅仅删除的是当前数据库中的数据，不影响其它库。</p><p>flushall 命令可以删除所有库中的所有数据。</p><ul><li>退出客户端</li></ul><p>使用 exit 或 quit 命令均可退出 Redis 命令行客户端。</p><h1 id="2-key-操作命令"><a href="#2-key-操作命令" class="headerlink" title="2. key 操作命令"></a>2. key 操作命令</h1><p>Redis 中存储的数据整体是一个 Map，其 key 为 String 类型，而 value 则可以是 String、Hash 表、List、Set 等类型。</p><ul><li><strong>keys</strong></li></ul><p>格式：KEYS pattern</p><p>查找所有符合给定模式 pattern 的 key，pattern 为正则表达式。</p><p>KEYS 的速度非常快，但在一个大的数据库中使用它可能会阻塞当前服务器的服务。所以生产环境中一般不使用该命令，而使用 scan 命令代替。</p><ul><li><strong>exists</strong></li></ul><p>格式：EXISTS key ；检查给定 key 是否存在，若存在返回 1 ，否则返回 0</p><ul><li><strong>del</strong></li></ul><p>格式：DEL key [key …]</p><p>删除给定的一个或多个 key ，不存在的 key 会被忽略。会返回被删除 key 的数量。</p><ul><li><strong>rename</strong></li></ul><p>格式：RENAME key newkey；将 key 改名为 newkey。</p><p>说明：当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， RENAME 命令将覆盖旧值。改名成功时提示 OK ，失败时候返回一个错误。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203536.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203536.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5b8b0c9210a022ab0362b65e7abb728d.png"></p><ul><li><strong>move</strong></li></ul><p>格式：MOVE key db</p><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p><p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ， 或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。移动成功返回 1 ，失败 则返回 0 。</p><ul><li><strong>type</strong></li></ul><p>格式：TYPE key</p><p>返回 key 所储存的值的类型：none (key 不存在)、string (字符串)、list (列表)、set (集合)、zset (有序集)、hash (哈希表)</p><ul><li><strong>expire 与 pexpire</strong></li></ul><p>格式：EXPIRE key seconds</p><p>为给定 key 设置生存时间。当 key 过期时(生存时间为 0)，它会被自动删除。 expire 的时间单位为秒，pexpire 的时间单位为毫秒。在 Redis 中，带有生存时间的 key 被称为“易失的”(volatile)。</p><p>生存时间设置成功返回 1；若 key 不存在时返回 0 ；rename 操作不会改变 key 的生存时间。</p><ul><li><strong>ttl 与 pttl</strong></li></ul><p>格式：TTL key</p><p>TTL, time to live，返回给定 key 的剩余生存时间。其返回值存在三种可能：</p><ul><li><p>当 key 不存在时，返回 -2 。</p></li><li><p>当 key 存在但没有设置剩余生存时间时，返回 -1 。</p></li><li><p>返回 key 的剩余生存时间。ttl 命令返回的时间单位为秒，而 pttl 命令返回的时间单位为毫秒。</p></li><li><p><strong>persist</strong></p></li></ul><p>格式：PERSIST key</p><p>去除给定 key 的生存时间，将这个 key 从“易失的”转换成“持久的”。</p><p>当生存时间移除成功时，返回 1；若 key 不存在或 key 没有设置生存时间，则返回 0。</p><ul><li><strong>randomkey</strong></li></ul><p>格式：RANDOMKEY</p><p>从当前数据库中随机返回(不删除)一个 key。</p><p>当数据库不为空时，返回一个 key；当数据库为空时，返回 nil。常用来判断数据库是否为空</p><ul><li><strong>scan</strong></li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</span><br></pre></td></tr></table></figure><ul><li>cursor：本次迭代开始的游标。</li><li>pattern ：本次迭代要匹配的 key 的模式。</li><li>count ：本次迭代要从数据集里返回多少元素，默认值为 10 。</li><li>type：本次迭代要返回的 value 的类型，默认为所有类型。</li></ul><p>SCAN 命令是一个基于游标 cursor 的迭代器：SCAN 命令每次被调用之后，都会向用户返回返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标， 而第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时，服务器将开始一次新的迭代。如果新游标返回 0 表示迭代已结束。</p><p>说明：使用间断的、负数、超出范围或者其他非正常的游标来执行增量式迭代不会造成服务器崩溃。</p><p>当数据量很大时，count 的数量的指定可能会不起作用，Redis 会自动调整每次的遍历数目。由于 scan 命令每次执行都只会返回少量元素，所以该命令可以用于生产环境， 而不会出现像 KEYS 命令带来的服务器阻塞问题。</p><blockquote><p>scan可能返回少于count个元素（只剩下少于count个数的元素了），可能返回等于count个元素，也可能返回比count多一点。官方文档解释count参数just a hint，只是一个提示作用的参数。</p></blockquote><p>增量式迭代命令所使用的算法只保证在数据集的大小有界的情况下迭代才会停止，换句话说，如果被迭代数据集的大小不断地增长的话，增量式迭代命令可能永远也无法完成一次完整迭代。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203544.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203544.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9ed7aa7152e4c5de79408a0e76242676.png"></p><p>相关命令：</p><ul><li>hscan：Hash 型 Value 操作命令集合，用于遍历当前 db 中指定 Hash 表的所有 field-value 对。</li><li>sscan：Set 型 Value 操作命令集合，用于遍历当前 db 中指定 set 集合的所有元素</li><li>zscan：ZSet 型 Value 操作命令集合，用于遍历当前 db 中指定有序集合的所有元素（数值与元素值）</li></ul><h1 id="3-String-型-Value-操作命令"><a href="#3-String-型-Value-操作命令" class="headerlink" title="3. String 型 Value 操作命令"></a>3. String 型 Value 操作命令</h1><p>String 类型的 Value 中可以存放任意数据，包括数值型，甚至是二进制的图片、音频、视频、序列化对象等。一个 String 类型的 Value 最大是 512M 大小。</p><ul><li><strong>set</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：SET key value [EX seconds | PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><ol><li>EX seconds：为当前 key 设置过期时间，单位秒。等价于 SETEX 命令。</li><li>PX milliseconds：为当前 key 设置过期时间，单位毫秒。等价于 PSETEX 命令。</li><li>NX：指定的 key 不存在才会设置成功，用于添加指定的 key。等价于 SETNX 命令。</li><li>XX：指定的 key 必须存在才会设置成功，用于更新指定 key 的 value。</li></ol><p>如果 value 字符串中带有空格，则该字符串需要使用双引号或单引号引起来，否则会认为 set 命令的参数数量不正确，报错。</p><ul><li><strong>setex 与 psetex</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX/PSETEX key seconds value</span><br></pre></td></tr></table></figure><p>不仅为 key 指定了 value，还为其设置了生存时间。setex 的单位为秒，psetex 的单位为毫秒。</p><p>如果 key 已经存在， 则覆写旧值。SETEX 是一个原子性操作，关联值和设置生存时间两个动作会在同一时间内完成。</p><ul><li><strong>setnx</strong></li></ul><p>格式：SETNX key value</p><p>功能：SET if Not eXists，当且仅当 key 不存在时将 key 的值设为 value 。若给定的 key 已经存在，则 SETNX 不做任何动作。成功返回 1，否则返回 0。</p><ul><li><strong>getset</strong></li></ul><p>格式：GETSET key value</p><p>功能：将给定 key 的值设为 value ，并返回 key 的旧值。</p><blockquote><p>当 key 存在但不是字符串类型时，返回一个错误；当 key 不存在时，返回 nil 。</p></blockquote><ul><li><strong>mset 与 msetnx</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET/MSETNX key value [key value ...]</span><br></pre></td></tr></table></figure><p>同时设置一个或多个 key-value 对。</p><p>MSET 会用新值覆盖原来的旧值；MSETNX 命令只会在所有给定 key 都不存在的情况下进行设置操作。MSET&#x2F;MSETNX 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况不可能发生。</p><ul><li><strong>mget</strong></li></ul><p>格式：MGET key [key …]</p><p>返回所有(一个或多个)给定 key 的值。若其中某个 key 不存在，那么这个 key 返回特殊值 nil</p><ul><li><strong>append</strong></li></ul><p>格式：APPEND key value</p><p>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p><p>追加 value 之后，会返回 key 中字符串的长度。</p><ul><li><strong>incr 与 decr</strong></li></ul><p>格式：INCR key 或 DECR key</p><p>功能：increment，自动递增。将 key 中存储的数字值增一。decrement，自动递减。将 key 中存储的数字值减一。</p><p>如果 key 不存在，那么 key 的值会先被初始化为 0，然后再执行增一&#x2F;减一操作。如果值不能表示为数字，那么返回一个错误提示。如果执行正确，则返回增一&#x2F;减一后的值。</p><blockquote><p>可以输入负数，所以记住 incr 即可</p></blockquote><ul><li><strong>incrby 与 decrby</strong></li></ul><p>格式：INCRBY key increment 或 DECRBY key decrement</p><p>将 key 中存储的数字值增加&#x2F;减少指定的数值，这个数值只能是整数，可以是负 数，但不能是小数。</p><ul><li><strong>incrbyfloat</strong></li></ul><p>格式：INCRBYFLOAT key increment</p><p>功能：为 key 中所储存的值加上浮点数增量 increment 。</p><ul><li><strong>strlen</strong></li></ul><p>格式：STRLEN key</p><p>功能：返回 key 所储存的字符串值的长度。</p><p>当 key 储存的不是字符串值时，返回一个错误；当 key 不存在时，返回 0 。</p><ul><li><strong>getrange</strong></li></ul><p>格式：GETRANGE key start end</p><p>功能：返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定，包括 start 和 end 在内。</p><p>end 必须要比 start 大。支持负数偏移量，表示从字符串最后开始计数，-1 表示 最后一个字符，-2 表示倒数第二个，以此类推。</p><ul><li><strong>setrange</strong></li></ul><p>格式：SETRANGE key offset value</p><p>功能：用 value 参数替换给定 key 所储存的字符串值 str，从偏移量 offset 开始。</p><p>说明：当 offset 值大于 str 长度时，中间使用零字节\x00 填充，即 0000 0000 字节填充；对于不存在的 key 当作空串处理。</p><ul><li>位操作命令</li></ul><p>名称中包含 BIT 的命令，都是对二进制位的操作命令，例如，setbit、getbit、bitcount、 bittop、bitfield，这些命令不常用。</p><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ol><li>数据缓存</li></ol><p>Redis 作为数据缓存层，MySQL 作为数据存储层。应用服务器首先从 Redis 中获取数据，如果缓存层中没有，则从 MySQL 中获取后先存入缓存层再返回给应用服务器。</p><ol start="2"><li>计数器</li></ol><p>在 Redis 中写入一个 value 为数值型的 key 作为平台计数器、视频播放计数器等。每个有效客户端访问一次，或视频每播放一次，都是直接修改 Redis 中的计数器，然后再以异步 方式持久化到其它数据源中</p><ol start="3"><li>共享 Session</li></ol><p>对于一个分布式应用系统，如果将类似用户登录信息这样的 Session 数据保存在提供登录服务的服务器中，那么如果用户再次提交像收藏、支付等请求时可能会出现问题：在提供收藏、支付等服务的服务器中并没有该用户的 Session 数据，从而导致该用户需要重新登录。 对于用户来说，这是不能接受的。</p><p>此时，可以将系统中所有用户的 Session 数据全部保存到 Redis 中，用户在提交新的请求后，系统先从 Redis 中查找相应的 Session 数据，如果存在，则再进行相关操作，否则跳转到登录页面。这样就不会引发“重新登录”问题。</p><ol start="4"><li>限速器</li></ol><p>现在很多平台为了防止 DoS（Denial of Service，拒绝服务）攻击，一般都会限制一个 IP 不能在一秒内访问超过 n 次。而 Redis 可以结合 key 的过期时间与 incr 命令来完成限速功能，充当限速器。</p><blockquote><p>无法防止 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击。</p></blockquote><h1 id="4-Hash-型-Value-操作命令"><a href="#4-Hash-型-Value-操作命令" class="headerlink" title="4. Hash 型 Value 操作命令"></a>4. Hash 型 Value 操作命令</h1><p>Redis 存储数据的 Value 可以是一个 Hash 类型。Hash 类型也称为 Hash 表、字典等。 </p><p>Hash 表就是一个映射表 Map，也是由键-值对构成，为了与整体的 key 进行区分，这里的键称为 field，值称为 value。注意，Redis 的 Hash 表中的 field-value 对均为 String 类型。</p><ul><li><strong>hset</strong></li></ul><p>格式：HSET key field value</p><p>功能：将哈希表 key 中的域 field 的值设为 value 。</p><p>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。</p><ul><li><strong>hget</strong></li></ul><p>格式：HGET key field</p><p>功能：返回哈希表 key 中给定域 field 的值。</p><p>当给定域不存在或是给定 key 不存在时，返回 nil 。</p><ul><li>hmset</li></ul><p>格式：HMSET key field value [field value …]</p><p>功能：同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p>此命令会覆盖哈希表中已存在的域。如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。如果命令执行成功，返回 OK 。当 key 不是哈希表(hash)类型时，返回一个错误。</p><ul><li><strong>hmget</strong></li></ul><p>格式：HMGET key field [field …]</p><p>功能：按照给出顺序返回哈希表 key 中一个或多个域的值。</p><p>如果给定的域不存在于哈希表，那么返回一个 nil 值。因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><ul><li><strong>hgetall</strong></li></ul><p>格式：HGETALL key</p><p>功能：返回哈希表 key 中所有的域和值。</p><ul><li><strong>hsetnx</strong></li></ul><p>格式：HSETNX key field value</p><p>功能：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。</p><p>若域 field 已经存在，该操作无效。如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。</p><ul><li><strong>hdel</strong></li></ul><p>格式：HDEL key field [field …]</p><p>功能：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p><p>返回被成功移除的域的数量，不包括被忽略的域。</p><ul><li><strong>hexits</strong></li></ul><p>格式：HEXISTS key field</p><p>功能：查看哈希表 key 中给定域 field 是否存在。</p><p>如果哈希表含有给定域，返回 1 。如果不含有给定域，或 key 不存在，返回 0 。</p><ul><li><strong>hincrby 与 hincrbyfloat</strong></li></ul><p>格式：HINCRBY key field increment</p><p>功能：为哈希表 key 中的域 field 的值加上增量 increment 。hincrby 命令只能增加整数值，而 hincrbyfloat 可以增加小数值。</p><p>增量也可以为负数，相当于对给定域进行减法操作。如果 key 不存在，一个新 的哈希表被创建并执行 HINCRBY 命令。如果域 field 不存在，那么在执行命令前，域的值被初始化为 0。对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p><ul><li><strong>hkeys 与 hvals</strong></li></ul><p>格式：HKEYS key 或 HVALS key</p><p>功能：返回哈希表 key 中的所有域&#x2F;值。</p><p>当 key 不存在时，返回一个空表。</p><ul><li><strong>hlen</strong></li></ul><p>格式：HLEN key</p><p>功能：返回哈希表 key 中域的数量。</p><p>当 key 不存在时，返回 0 。</p><ul><li><strong>hstrlen</strong></li></ul><p>格式：HSTRLEN key field</p><p>功能：返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</p><p>如果给定的键或者域不存在， 那么命令返回 0 。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Hash 型 Value 非常适合存储对象数据。key 为对象名称，value 为描述对象属性的 Map，对对象属性的修改在 Redis 中就可直接完成。其不像 String 型 Value 存储对象，对象需要序列化，例如序列化为 JSON 串，对对象属性值的修改需要先反序列化为对象后再修改， 修改后再序列化为 JSON 串后写入到 Redis。</p><h1 id="5-List-型-Value-操作命令"><a href="#5-List-型-Value-操作命令" class="headerlink" title="5. List 型 Value 操作命令"></a>5. List 型 Value 操作命令</h1><p>Redis 存储数据的 Value 可以是一个 String 列表类型数据。即该列表中的每个元素均为 String 类型数据。列表中的数据会按照插入顺序进行排序。不过，该列表的底层实际是一个<strong>无头节点的双向链表</strong>，所以对列表表头与表尾的操作性能较高，但对中间元素的插入与删除的操作的性能相对较差。</p><ul><li><strong>lpush&#x2F;rpush</strong></li></ul><p>格式：LPUSH key value [value …] 或 RPUSH key value [value …]</p><p>功能：将一个或多个值 value 插入到列表 key 的表头&#x2F;表尾（表头在左表尾在右）</p><p>如果有多个 value 值，对于 lpush 来说，各个 value 会按从左到右的顺序依次插 入到表头；对于 rpush 来说，各个 value 会按从左到右的顺序依次插入到表尾。如果 key 不存在，一个空列表会被创建并执行操作。当 key 存在但不是列表类型时，返回一个 错误。执行成功时返回列表的长度。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203558.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7a6a05d723908f9262a1b0cfcaab5e5d.png"></p><ul><li><strong>llen</strong></li></ul><p>格式：LLEN key</p><p>功能：返回列表 key 的长度。</p><p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 。如果 key 不是列表 类型，返回一个错误。</p><ul><li><strong>lindex</strong></li></ul><p>格式：LINDEX key index</p><p>功能：返回列表 key 中，下标为 index 的元素。列表从 0 开始计数。</p><p>如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p><ul><li><strong>lset</strong></li></ul><p>格式：LSET key index value</p><p>功能：将列表 key 下标为 index 的元素的值设置为 value 。</p><ul><li><strong>lrange</strong></li></ul><p>格式：LRANGE key start stop</p><p>功能：返回列表 key 中指定区间[start, stop]内的元素，即包含两个端点。</p><p>List 的下标从 0 开始，即以 0 表示列表的第一个元素，以 -1 表示列表的最后一个元素，-2 表示列表的倒数第二个元素，以此类推。超出范围的下标值不会引起错误。如果 start 下标比列表的最大下标 还要大，那么 LRANGE 返回一个空列表。如果 stop 下标比最大下标还要大，Redis 将 stop 的值设置为最大下标。</p><ul><li><strong>lpushx 与 rpushx</strong></li></ul><p>格式：LPUSHX key value 或 RPUSHX key value</p><p>功能：将值 value 插入到列表 key 的表头&#x2F;表尾，当且仅当 key 存在并且是一个列表。</p><p>当 key 不存在时，命令什么也不做。若执行成功，则输出表的长度。</p><ul><li><strong>linsert</strong></li></ul><p>格式：LINSERT key BEFORE|AFTER pivot value</p><p>功能：将值 value 插入到列表 key 当中，位于元素 pivot 之前或之后。</p><p>当 pivot 元素不存在于列表中时，不执行任何操作，返回-1；当 key 不存在时，key 被视为空列表，不执行任何操作，返回 0；如果 key 不是列表类型，返回一个错误；如果命令执行成功，返回插入操作完成之后，列表的长度。</p><ul><li><strong>lpop &#x2F; rpop</strong></li></ul><p>格式：LPOP key [count] 或 RPOP key [count]</p><p>功能：从列表 key 的表头&#x2F;表尾移除 count 个元素，并返回移除的元素。count 默认值 1</p><p>当 key 不存在时，返回 nil</p><ul><li><strong>blpop &#x2F; brpop</strong></li></ul><p>格式：BLPOP key [key …] timeout 或 BRPOP key [key …] timeout</p><p>功能：BLPOP&#x2F;BRPOP 是列表的阻塞式(blocking)弹出命令。当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP&#x2F;BRPOP 命令阻塞，直到等待 timeout 超时或发现可弹出元素为止。当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。timeout 为阻塞时长， 单位为秒，其值若为 0，则表示只要没有可弹出元素，则一直阻塞。</p><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><ul><li><strong>rpoplpush</strong></li></ul><p>格式：RPOPLPUSH source destination</p><p>功能：在一个原子时间内，将列表 source 中的最后一个元素(尾元素)弹出返回给客户端。并将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</p><p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p><ul><li><strong>brpoplpush</strong></li></ul><p>格式：BRPOPLPUSH source destination timeout</p><p>功能：BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本，</p><ul><li><strong>lrem</strong></li></ul><p>格式：LREM key count value</p><p>功能：根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><ol><li>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</li><li>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的 绝对值。</li><li>count &#x3D; 0 : 移除表中所有与 value 相等的值。</li></ol><p>返回被移除元素的数量。当 key 不存在时， LREM 命令返回 0 ，因为不存在 的 key 被视作空表(empty list)。</p><ul><li><strong>ltrim</strong></li></ul><p>格式：LTRIM key start stop</p><p>功能：对一个列表进行裁剪(trim)，只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一 个元素，以 1 表示列表的第二个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。当 key 不是列表类型时，返回一个错误。如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要 大，或者 start &gt; stop ， LTRIM 返回一个空列表，因为 LTRIM 已经将整个列表清空。 如果 stop 下标比 end 下标还要大，Redis 将 stop 的值设置为 end 。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>Value 为 List 类型的应用场景很多，主要是通过构建不同的数据结构来实现相应的业务功能。</p><ol><li>栈</li></ol><p>通过 lpush + lpop 或 rpush + rpop 可以实现栈数据结构效果：先进后出。</p><ol start="2"><li>队列</li></ol><p>通过 lpush + rpop 或  rpush + lpop 可以实现队列数据结构效果：先进先出。</p><ol start="3"><li>阻塞式消息队列</li></ol><p>通过 lpush + brpop 可以实现阻塞式消息队列效果。作为消息生产者的客户端使用 lpush 从列表左侧插入数据，作为消息消费者的多个客户端使用 brpop 阻塞式“抢占”列表尾部数 据进行消费，保证了消费的负载均衡与高可用性。brpop 的 timeout 设置为 0，表示只要没有数据可弹出，就永久阻塞。</p><ol start="4"><li>动态有限集合</li></ol><p>通过 lpush + ltrim 或 rpush + ltrim 可以实现有限集合。通过 lpush 从列表左侧向列表中添加数据，通过 ltrim 保持集合的动态有限性。像企业的末位淘汰、学校的重点班等动态管理，都可通过这 种动态有限集合来实现。</p><h1 id="6-Set-型-Value-操作命令"><a href="#6-Set-型-Value-操作命令" class="headerlink" title="6. Set 型 Value 操作命令"></a>6. Set 型 Value 操作命令</h1><p>Redis 存储数据的 Value 可以是一个 Set 集合，且集合中的每一个元素均 String 类型。</p><p>Redis 中的 Set 集合与 Java 中的 Set 集合的实现相似</p><ul><li><strong>sadd</strong></li></ul><p>格式：SADD key member [member …]</p><p>功能：将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member  元素将被忽略。</p><p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。</p><ul><li><strong>smembers</strong></li></ul><p>格式：SMEMBERS key</p><p>功能：返回集合 key 中的所有成员。</p><p>不存在的 key 被视为空集合。若 key 中包含大量元素，则该命令可能会阻塞 Redis 服务。所以生产环境中一般不使用该命令，而使用 sscan 命令代替。</p><ul><li><strong>scard</strong></li></ul><p>格式：SCARD key</p><p>功能：返回 Set 集合的长度</p><p>当 key 不存在时，返回 0 。</p><ul><li><strong>sismember</strong></li></ul><p>格式：SISMEMBER key member</p><p>功能：判断 member 元素是否集合 key 的成员。</p><p>如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成 员，或 key 不存在，返回 0 。</p><ul><li><strong>smove</strong></li></ul><p>格式：SMOVE source destination member</p><p>功能：将 member 元素从 source 集合移动到 destination 集合。</p><p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去，返回 1。当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。当 source 或 destination 不是集合类型时，返回一个错误。</p><ul><li>srem</li></ul><p>格式：SREM key member [member …]</p><p>功能：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略，且返回成功移除的元素个数。</p><p>当 key 不是集合类型，返回一个错误。</p><ul><li><strong>srandmember</strong></li></ul><p>格式：SRANDMEMBER key [count]</p><p>功能：返回集合中的 count 个随机元素。count 默认值为 1。</p><p>若 count 为正数，且小于集合长度，那么返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合长度，那么返回整个集合。如果 count 为负数，那么返回一个包含 count 绝对值个元素的数组，但数组中的元素可能会出现重复。</p><ul><li><strong>spop</strong></li></ul><p>格式：SPOP key [count]</p><p>功能：移除并返回集合中的 count 个随机元素。count 必须为正数，且默认值为 1。</p><p>如果 count 大于等于集合长度，那么移除并返回整个集合。</p><ul><li><strong>sdiff &#x2F; sdiffstore</strong></li></ul><p>格式：SDIFF key [key …] 或 SDIFFSTORE destination key [key …]</p><p>功能：返回第一个集合与其它集合之间的差集。</p><p>这两个命令的不同之处在于，sdiffstore 不仅能够显示差集，还能将差集存储到指 定的集合 destination 中。如果 destination 集合已经存在，则将其覆盖。不存在的 key 被视为空集。</p><ul><li><strong>sinter &#x2F; sinterstore</strong></li></ul><p>格式：SINTER key [key …] 或 SINTERSTORE destination key [key …]</p><p>功能：返回多个集合间的交集。</p><ul><li><strong>sunion &#x2F; sunionstore</strong></li></ul><p>格式：SUNION key [key …] 或 SUNIONSTORE destination key [key …]</p><p>功能：返回多个集合间的并集。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>动态黑白名单</li></ol><p>例如某服务器中要设置用于访问控制的黑名单。如果直接将黑名单写入服务器的配置文件，那么存在的问题是，无法动态修改黑名单。此时可以将黑名单直接写入 Redis，只要有客户端来访问服务器，服务器在获取到客户端IP后先从 Redis的黑名单中查看是否存在该 IP，如果存在，则拒绝访问，否则访问通过。</p><ol start="2"><li>有限随机数</li></ol><p>有限随机数是指返回的随机数是基于某一集合范围内的随机数，例如抽奖、随机选人。 通过 spop 或 srandmember 可以实现从指定集合中随机选出元素。</p><ol start="3"><li>用户画像</li></ol><p>社交平台、电商平台等各种需要用户注册登录的平台，会根据用户提供的资料与用户使用习惯，为每个用户进行画像，即为每个用户定义很多可以反映该用户特征的标签，这些标签就可以使用 sadd 添加到该用户对应的集合中。这些标签具有无序、不重复特征。</p><p>同时平台还可以使用 sinter&#x2F;sinterstore 根据用户画像间的交集进行好友推荐、商品推荐、 客户推荐等。</p><h1 id="7-有序-Set-型-Value-操作命令"><a href="#7-有序-Set-型-Value-操作命令" class="headerlink" title="7. 有序 Set 型 Value 操作命令"></a>7. 有序 Set 型 Value 操作命令</h1><p>Redis 存储数据的 Value 可以是一个有序 Set，这个有序 Set 中的每个元素均 String 类型。有序 Set 与 Set 的不同之处是，有序 Set 中的每一个元素都有一个分值 score，Redis 会根据 score 的值对集合进行由小到大的排序。其与 Set 集合要求相同，元素不能重复，但元素的 score 可以重复。由于该类型的所有命令均是字母 z 开头，所以该 Set 也称为 ZSet。</p><ul><li><strong>zadd</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [[score member] [score member] ...]</span><br></pre></td></tr></table></figure><p>功能：将一个或多个 member 元素及其 score 值加入到有序集 key 中的适当位置。</p><p>score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。如果命令执行成功，则返回被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。 若写入的 member 值已经存在，但 score 值不同，则新的 score 值将覆盖老 score。</p><ul><li><strong>zrange 与 zrevrange</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>功能：返回有序集 key 中，指定区间内的成员。zrange 命令会按 score 值递增排序，zrevrange命令会按score递减排序。具有相同 score 值的成员按字典序&#x2F;逆字典序排列。可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回。</p><p>若 key 中指定范围内包含大量元素，则该命令可能会阻塞 Redis 服务。所以生产环 境中如果要查询有序集合中的所有元素，一般不使用该命令，而使用 zscan 命令代替。</p><ul><li><strong>zrangebyscore 与 zrevrangebyscore</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>功能：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增&#x2F;递减次序排列。具有相同 score 值的成员按字典序&#x2F;逆字典序排列。可选的 LIMIT 参数指定返回结果的数量及区间(就像 SQL 中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整 个有序集，此过程效率可能会较低。</p><p>min 和 max 的取值是正负无穷大的。默认情况下，区间的取值使用闭区间 (小 于等于或大于等于)，也可以通过给参数前增加左括号“(”来使用可选的开区间 (小于或 大于)。</p><ul><li><strong>zcard</strong></li></ul><p>格式：ZCARD key</p><p>功能：返回集合的长度</p><p>当 key 不存在时，返回 0</p><ul><li><strong>zcount</strong></li></ul><p>格式：ZCOUNT key min max</p><p>返回有序集 key 中，score 值在 min 和 max 之间(默认包括 score 值等于 min  或 max )的成员的数量。</p><ul><li><strong>zscore</strong></li></ul><p>格式：ZSCORE key member</p><p>功能：返回有序集 key 中，成员 member 的 score 值。</p><p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><ul><li><strong>zincrby</strong></li></ul><p>格式：ZINCRBY key increment member</p><p>功能：为有序集 key 的成员 member 的 score 值加上增量 increment 。increment 值可以是整数值或双精度浮点数。</p><p>可以通过传递一个负数值 increment ，让 score 减去相应的值。当 key 不存在， 或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key  increment member 。当 key 不是有序集类型时，返回一个错误。命令执行成功，则返回 member 成员的新 score 值。</p><ul><li><strong>zrank 与 zrevrank</strong></li></ul><p>格式：ZRANK key member 或 ZREVRANK key member</p><p>功能：返回有序集 key 中成员 member 的排名。zrank 命令会按 score 值递增排序， zrevrank 命令会按 score 递减排序。</p><p>score 值最小的成员排名为 0 。如果 member 不是有序集 key 的成员，返回 nil 。</p><ul><li><strong>zrem</strong></li></ul><p>格式：ZREM key member [member …]</p><p>功能：移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>当 key 存在但不是有序集类型时，返回一个错误。执行成功，则返回被成功移除的成员的数量，不包括被忽略的成员。</p><ul><li><strong>zremrangebyrank</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p>功能：移除有序集 key 中，指定排名(rank)区间内的所有成员。</p><p>排名区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。排名区间参数从 0 开始，即 0 表示排名第一的成员，以此类推。 也可以使用负数表示，-1 表示最后一个成员以此类推。命令执行成功，则返回被移除成员的数量。</p><ul><li><strong>zremrangebyscore</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p>功能：移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p><p>命令执行成功，则返回被移除成员的数量。min和max支持无穷大，“-inf”表示负无穷，“+inf”表示正无穷。</p><ul><li><strong>zrangebylex</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>功能：该命令仅适用于集合中所有成员都具有相同分值的情况。当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序。即这个命令返回给定集合中元素值介于 min 和 max 之间的成员。如果有序集合里面的成员带有不同的分值， 那么命令的执行结果与 zrange key 效果相同。</p><p>合法的 min 和 max 参数必须包含左小括号“(”或左中括号“[”，其中左小括号“(”表示开区间，而左中括号“[”则表示闭区间。min 或 max 也可使用特殊字符“+”和“-”，分别表示正无穷大与负无穷大。</p><ul><li><strong>zlexcount</strong></li></ul><p>格式：ZLEXCOUNT key min max</p><p>功能：该命令仅适用于集合中所有成员都具有相同分值的情况。该命令返回该集合中元素值本身（而非 score 值）介于 min 和 max 范围内的元素数量。</p><ul><li><strong>zremrangebylex</strong></li></ul><p>格式：ZREMRANGEBYLEX key min max</p><p>功能：该命令仅适用于集合中所有成员都具有相同分值的情况。该命令会移除该集合中元素值本身介于 min 和 max 范围内的所有元素。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>有序 Set 最为典型的应用场景就是排行榜，例如音乐、视频平台中根据播放量进行排序的排行榜；电商平台根据用户评价或销售量进行排序的排行榜等。将播放量作为 score，将作品 id 作为 member，将用户评价积分或销售量作为 score，将商家 id 作为 member。使用 zincrby 增加排序 score，使用 zrevrange 获取 Top 前几名，使用 zrevrank 查询当前排名，使用 zscore 查询当前排序 score 等。</p><h1 id="8-benchmark-测试工具"><a href="#8-benchmark-测试工具" class="headerlink" title="8. benchmark 测试工具"></a>8. benchmark 测试工具</h1><p>在Redis安装完毕后会自动安装一个redis-benchmark测试工具，用于测试 Redis 的性能。查看到其用法：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203615.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203615.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="389fce4e1ceb36a4a62dee0adf4bafad.png"></p><p>常用的 options：</p><ul><li>-h：指定要测试的 Redis 的 IP，若为本机，则可省略</li><li>-p：指定要测试的 Redis 的 port，若为 6379，则可省略</li><li>-c：指定模拟有客户端的数量，默认值为 50</li><li>-n：指定这些客户端发出的请求的总量，默认值为 100000</li><li>-d：指定测试 get&#x2F;set 命令时其操作的 value 的数据长度，单位字节，默认值为 3。在测试其它命令时该指定没有用处。</li><li>-t：指定要测试的命令，多个命令使用逗号分隔，不能有空格</li><li>-q：指定仅给出总述性报告</li></ul><p>测试结果分析：</p><p>该测试工具会逐个测试所有 Redis 命令，每个命令都会给出一份测试报告，每个测试报告由四部分构成：</p><ol><li>测试环境报告</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203622.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="92237527e68bdc417c2b17dcad98a23d.png"></p><ol start="2"><li>延迟百分比分布</li></ol><p>这是按照百分比进行的统计报告：每完成一次剩余测试量的 50%就给出一个统计数据。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203629.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203629.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1cc6d1d6727bc0df83ec616393926a81.png"></p><ol start="3"><li>延迟的累积分布</li></ol><p>这是按照时间间隔统计的报告：基本是每 0.1 毫秒统计一次。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203707.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203707.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="cf2e5c0a591cc1ee92a310c4045c6bb3.png"></p><ol start="4"><li>总述报告</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203714.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203714.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0668e4a3ae820f7b4ba5060c8b0f2565.png"></p><h1 id="9-简单动态字符串-SDS"><a href="#9-简单动态字符串-SDS" class="headerlink" title="9. 简单动态字符串 SDS"></a>9. 简单动态字符串 SDS</h1><p>Redis 中 Value 的基础数据类型都是字符串。如 Hash 型 Value 的 field 与 value 的类型、List 型、Set 型、ZSet 型 Value 的元素的类型等都是字符串。虽然 Redis 是使用标准 C 语言开发的，但并没有直接使用 C 语言中传统的字符串表示，而是自定义了一 种字符串。这种字符串本身的结构比较简单，但功能却非常强大，称为简单动态字符串， Simple Dynamic String，简称 SDS。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203717.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203717.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d7c68ffd2265488fcd23137582a43e59.png"></p><p>其中 embstr 就表示该数据底层使用SDS字符串存储，但是 Redis 中的所有字符串并不都是 SDS，也会出现 C 字符串。C 字符串只会出现在字符串“字面常量”中，该字符串不可能发生变更，如控制台输出的 ‘zhangsan’</p><h3 id="SDS-结构"><a href="#SDS-结构" class="headerlink" title="SDS 结构"></a>SDS 结构</h3><p>SDS 不同于 C 字符串。C 字符串本身是一个以双引号括起来，以空字符’\0’结尾的字符序 列。但 SDS 是一个结构体，定义在 Redis 安装目录下的 src&#x2F;sds.h 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">    <span class="comment">// buf[]中已使用字节数量，称为 SDS 的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf[]中尚未使用的字节数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 SET country “China”命令时，键 country 与值”China”都是 SDS 类型的，只不过一个是 SDS 的变量，一个是 SDS 的字面常量。”China”在内存中的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203722.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="93932fc21a02a4c65c5085a88e4dd6e2.png"></p><p>通过以上结构可以看出，SDS 的 buf 值实际是一个 C 字符串，包含空字符’\0’共占 6 个字节。但 SDS 的 len 是不包含空字符’\0’的。</p><h3 id="SDS-的优势"><a href="#SDS-的优势" class="headerlink" title="SDS 的优势"></a>SDS 的优势</h3><p>C 字符串使用 Len+1 长度的字符数组来表示实际长度为 Len 的字符串，字符数组最后以空字符’\0’结尾，表示字符串结束。这种结构简单，但不能满足 Redis 对字符串功能性、安全性及高效性等的要求。</p><h4 id="防止”字符串长度获取”性能瓶颈"><a href="#防止”字符串长度获取”性能瓶颈" class="headerlink" title="防止”字符串长度获取”性能瓶颈"></a>防止”字符串长度获取”性能瓶颈</h4><p>对于 C 字符串，若要获取其长度，则必须要通过遍历整个字符串才可获取到的。对于超长字符串的遍历，会成为系统的性能瓶颈。</p><p>SDS 结构体中直接就存放着字符串的长度数据，所以对于获取字符串长度需要 消耗的系统性能，与字符串本身长度是无关的，不会成为 Redis 的性能瓶颈。</p><h4 id="保障二进制安全"><a href="#保障二进制安全" class="headerlink" title="保障二进制安全"></a>保障二进制安全</h4><p>C 字符串中只能包含符合某种编码格式的字符，例如 ASCII、UTF-8 等，并且除了字符串末尾外，其它位置是不能包含空字符’\0’的，否则该字符串就会被程序误解为提前结束。而在图片、音频等二进制数据中以空字符’\0’作为分隔符的情况又是很常见的。</p><p>SDS 不是以空字符’\0’作为字符串结束标志的，其是通过 len 属性来判断字符串是否结束的。所以，对于程序处理 SDS 中的字符串数据，无需对数据做任何限制、过滤、假设，只需读取即可。数据写入的是什么，读到的就是什么。</p><h4 id="减少内存再分配次数"><a href="#减少内存再分配次数" class="headerlink" title="减少内存再分配次数"></a>减少内存再分配次数</h4><p>C语言字符串需要添加元素时，底层是创建新数组来存储（类似Java中的String），为了防止后面的数据被覆盖，会对内存进行再分配。</p><p>SDS 采用了空间预分配策略与惰性空间释放策略来避免内存再分配问题</p><ul><li>空间预分配策略：每次 SDS 进行空间扩展时，程序不但为其分配所需的空间，还会为其分配额外的未使用空间，以减少内存再分配次数。而额外分配的未使用空间大小取决于空间扩展后 SDS 的 len 属性值。<ul><li>如果 len 属性值小于 1M，那么分配的未使用空间 free 的大小与 len 属性值相同。</li><li>如果 len 属性值大于等于 1M ，那么分配的未使用空间 free 的大小固定是 1M。</li></ul></li><li>惰性空间释放策略：SDS 字符串长度如果缩短，那么多出的未使用空间将暂时不释放，而是增加到 free 中。以使后期扩展 SDS 时减少内存再分配次数。如果要释放 SDS 的未使用空间，则可通过 sdsRemoveFreeSpace()函数来释放。</li></ul><h4 id="兼容C函数"><a href="#兼容C函数" class="headerlink" title="兼容C函数"></a>兼容C函数</h4><p>Redis 中提供了很多的 SDS 的 API，以方便用户对 Redis 进行二次开发。为了能够兼容 C 函数，SDS 的底层数组 buf[]中的字符串仍以空字符’\0’结尾。</p><h3 id="常用的-SDS-操作函数"><a href="#常用的-SDS-操作函数" class="headerlink" title="常用的 SDS 操作函数"></a>常用的 SDS 操作函数</h3><table><thead><tr><th align="center">函数</th><th>功能描述</th></tr></thead><tbody><tr><td align="center">sdsnew()</td><td>使用指定的 C 字符串创建一个 SDS</td></tr><tr><td align="center">sdsempty()</td><td>创建一个不包含任何字符串数据的 SDS</td></tr><tr><td align="center">sdsdup()</td><td>创建一个指定 SDS 的副本</td></tr><tr><td align="center">sdsfree()</td><td>释放指定的 SDS</td></tr><tr><td align="center">sdsclear()</td><td>清空指定 SDS 的字符串内容</td></tr><tr><td align="center">sdslen()</td><td>获取指定 SDS 的已使用空间 len 值</td></tr><tr><td align="center">sdsavail()</td><td>获取指定 SDS 的未使用空间 free 值</td></tr><tr><td align="center">sdsMakeRoomFor()</td><td>使指定的 SDS 的 free 空间增加指定的大小</td></tr><tr><td align="center">sdsRemoveFreeSpace()</td><td>释放指定 SDS 的 free 空间</td></tr><tr><td align="center">sdscat()</td><td>将指定的 C 字符串拼接到指定 SDS 字符串末尾</td></tr><tr><td align="center">sdscatsds()</td><td>将指定的 SDS 的字符串拼接到另一个指定 SDS 字符串末尾</td></tr><tr><td align="center">sdscpy()</td><td>将指定的 C 字符串复制到指定的 SDS 中，覆盖原 SDS 字符串内容</td></tr><tr><td align="center">sdsgrouzero()</td><td>扩展 SDS 字符串到指定长度。这个扩展是使用空字符’\0’填充</td></tr><tr><td align="center">sdsrange()</td><td>截取指定 SDS 中指定范围内的字符串</td></tr><tr><td align="center">sdstrim()</td><td>在指定 SDS 中删除所有指定 C 字符串中出现的所有字符</td></tr><tr><td align="center">sdsemp()</td><td>对比两个给定的 SDS 字符串是否相同</td></tr><tr><td align="center">sdstolow()</td><td>将指定 SDS 字符串中的所有字母变为小写</td></tr><tr><td align="center">sdstoupper()</td><td>将指定 SDS 字符串中的所有字母变为大写</td></tr></tbody></table><h1 id="10-集合的底层实现原理"><a href="#10-集合的底层实现原理" class="headerlink" title="10. 集合的底层实现原理"></a>10. 集合的底层实现原理</h1><p>Redis 中对于 Set 类型的底层实现，直接采用了 hashTable。但对于 Hash、ZSet、List 集合的底层实现进行了特殊的设计，使其保证了 Redis 的高性能。</p><h2 id="Hash与ZSet"><a href="#Hash与ZSet" class="headerlink" title="Hash与ZSet"></a>Hash与ZSet</h2><p>对于Hash与ZSet集合，其底层的实现实际有两种：压缩列表zipList，与跳跃列表skipList。</p><p>用户写入不同的数据，系统会自动使用不同的实现。同时满足以配置文件 redis.conf 中相关集合元素数量阈值与元素大小阈值两个条件。就使用压缩列表 zipList，只要有一个条件不满足就使用跳跃列表 skipList。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203729.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203729.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b2244a1e09b3d0007f7224665d8469f7.png"></p><blockquote><p>集合元素个数不能大于默认值：128 字节，且每个集合元素大小都小于 默认值：64 字节</p></blockquote><h3 id="zipList"><a href="#zipList" class="headerlink" title="zipList"></a>zipList</h3><p>zipList，通常称为压缩列表，是一个经过特殊编码的用于存储字符串或整数的<strong>双向链表</strong>。其底层数据结构由三部分构成：head、entries 与 end。这三部分在内存上是<strong>连续存放</strong>的。</p><ol><li><p>head 由三部分构成：</p><ul><li>zlbytes：占 4 个字节，用于存放 zipList 列表整体数据结构所占的字节数，包括 zlbytes 本身的长度。 </li><li>zltail：占 4 个字节，用于存放 zipList 中最后一个 entry 在整个数据结构中的偏移量。该数据的存在可以快速定位列表的尾 entry 位置，以方便操作。</li><li>zllen：占 2 字节，用于存放列表包含的 entry 个数。由于其只有 16 位，所以 zipList 最多可以含有的 entry 个数为 2^16 -1 &#x3D; 65535 个。</li></ul></li><li><p>entries：真正的列表，由很多的列表元素 entry 构成。由于不同的元素类型、数值的不同，从而导致每个 entry 的长度不同，每个 entry 由三部分构成：</p><ul><li>prevlength：该部分用于记录上一个 entry 的长度，以实现逆序遍历。默认长度为 1 字节， 只要上一个 entry 的长度&lt;254 字节，prevlength 就占 1 字节，否则其会自动扩展为 3 字节长度。</li><li>encoding：该部分用于标志后面的 data 的具体类型。如果 data 为整数类型，encoding 固定长度为 1 字节。如果 data 为字符串类型，则 encoding 长度可能会是 1 字节、2 字节或 5 字节。data 字符串不同的长度，对应着不同的 encoding 长度。</li><li>data：真正存储的数据。数据类型只能是整数类型或字符串类型。不同的数据占用的字节长度不同。</li></ul></li><li><p>end：end 只包含一部分，称为 zlend。占 1 个字节，值固定为 255，即二进制位为全 1，表示 一个 zipList 列表的结束。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203734.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5ab9e2f274ce8d67d1093fe321163f96.png"></p><p>对于 ziplist，实现复杂，为了逆序遍历，每个 entry 中包含前一个 entry 的长度，这样会导致在 ziplist 中间修改或者插入 entry 时需要进行级联更新。</p><blockquote><p>除了需要改变 entres 的结构，还需要改变后一个元素(以及修改元素) head 中的 zltail</p></blockquote><p>在高并发的写操作场景下会极度降低 Redis 的性能。</p><p>在 Redis 7.0 中，已经将 zipList 全部替换为了 listPack，但为了兼容性，在配置中也保留 了 zipList 的相关属性。</p><h4 id="listPack"><a href="#listPack" class="headerlink" title="listPack"></a>listPack</h4><p>listPack 也是一个经过特殊编码的用于存储字符串或整数的双向链表。其底层数据结构 也由三部分构成：head、entries 与 end，且这三部分在内存上也是连续存放的。</p><ol><li>head 由两部分构成：<ul><li>totalBytes：占 4 个字节，用于存放 listPack 列表整体数据结构所占的字节数，包括 totalBytes 本身的长度。</li><li>elemNum：占 2 字节，用于存放列表包含的 entry 个数。其意义与 zipList 中 zllen 的相同。</li></ul></li><li>entries ：最大的变化就是没有了记录前一个 entry 长度的 prevlength，而增加了记录当前 entry 长度的 element-total-len。</li></ol><ul><li>encoding：该部分用于标志后面的 data 的具体类型。如果 data 为整数类型，encoding 长度可能会是 1、2、3、4、5 或 9 字节。不同的字节长度，其标识位不同。如果 data 为字符串类型，则 encoding 长度可能会是 1、2 或 5 字节。data 字符串不同的长度，对应着不同的 encoding 长度。</li><li>data</li><li>element-total-len：该部分用于记录当前 entry 的长度，用于实现逆序遍历。由于其特殊的记录方式，使其本身占有的字节数据可能会是 1、2、3、4 或 5 字节。</li></ul><h3 id="skipList"><a href="#skipList" class="headerlink" title="skipList"></a>skipList</h3><p>skipList，跳跃列表，简称跳表，是一种<strong>随机化</strong>的数据结构，基于并联的链表，实现简单， 查找效率较高。</p><p>简单来说就是随机多加了一些指针，在有序链表能够快速定位数据</p><p>简单实现（非随机）：</p><p>为了提升查找效率，在偶数结点上增加一个指针，让其指向下一个偶数结点。这样所有偶数结点就连成了一个新的链表（简称高层链表），当然，高层链表包含的节点个数只是原来链表的一半。此时再想查找某个数据时，先沿着高层链表进行查找。当遇到第一个比待查数据大的节点时，立即从该大节点的前一个节点回到原链表中进行查找。</p><p>对链表分层级的方式从原理上看确实提升了查找效率，但在实际操作时就出现了问题：由于固定序号的元素拥有固定层级，所以列表元素出现增加或删除的情况下，会导致列表整体元素层级大调整，但这样势必会大大降低系统性能。</p><p>这就体现了随机的好处</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="quickList"><a href="#quickList" class="headerlink" title="quickList"></a>quickList</h3><p>quickList，快速列表，quickList 本身是一个双向无循环链表，它的每一个节点都是一个 zipList。从Redis3.2版本开始，对于List的底层实现，使用quickList替代了zipList 和 linkedList。</p><p>quickList 本质上是 zipList 和 linkedList 的混合体。其将 linkedList 按段切分，每一段使用 zipList 来紧凑存储若干真正的数据元素，多个 zipList 之间使用双向指针串接起来。当然，对于每个 zipList 中最多可存放多大容量的数据元素，在配置文件中通过 list-max-ziplist-size 属性可以指定。</p><ol><li>检索操作：</li></ol><p>quickList 由一个个的 zipList 构成，每个 zipList 的 zllen 中记录的就是当前 zipList 中包含的 entry 的个数，即包含的真正数据元素的个数。根据要检索元素的 index，从 quickList 的头节点开始，逐个对 zipList 的 zllen 做 sum 求和，直到找到第一个求和后 sum 大于 index 的 zipList，那么要检索的这个元素就在这个 zipList 中。</p><ol start="2"><li>插入：</li></ol><p>由于 zipList 是有大小限制的，所以在 quickList 中插入一个元素在逻辑上相对就比较复杂一些。假设要插入的元素的大小为 insertBytes，而查找到的插入位置所在的 zipList 当前的大小为 zlBytes，那么具体可分为下面几种情况：</p><p>情况一：当 insertBytes + zlBytes &lt;&#x3D; list-max-ziplist-size 时，直接插入到 zipList 中相应位置 即可</p><p>情况二：</p><p>当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的首部位置，此时需要查看该 zipList 的前一个 zipList 的大小 prev_zlBytes。</p><ul><li>若 insertBytes + prev_zlBytes&lt;&#x3D; list-max-ziplist-size 时，直接将元素插入到前一个 zipList 的尾部位置即可</li><li>若 insertBytes + prev_zlBytes&gt; list-max-ziplist-size 时，直接将元素自己构建为一个新 的 zipList，并连入 quickList 中</li></ul><p>情况三：</p><p>当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的尾部位置，此时需要查看该 zipList 的后一个 zipList 的大小 next_zlBytes。</p><ul><li>若 insertBytes + next_zlBytes&lt;&#x3D; list-max-ziplist-size 时，直接将元素插入到后一个 zipList 的头部位置即可</li><li>若 insertBytes + next_zlBytes&gt; list-max-ziplist-size 时，直接将元素自己构建为一个新的 zipList，并连入 quickList 中</li></ul><p>情况四：当 insertBytes + zlBytes &gt; list-max-ziplist-size，且插入的位置位于该 zipList 的中间位置，则将当前 zipList 分割为两个 zipList 连接入 quickList 中，然后将元素插入到分割后的前面 zipList 的尾部位置</p><ol start="3"><li>删除操作</li></ol><p>对于删除操作，只需要注意一点，在相应的 zipList 中删除元素后，该 zipList 中是否还有元素。如果没有其它元素了，则将该 zipList 删除，将其前后两个 zipList 相连接。</p><h1 id="11-BitMap-操作命令"><a href="#11-BitMap-操作命令" class="headerlink" title="11. BitMap 操作命令"></a>11. BitMap 操作命令</h1><p>BitMap 是 Redis 2.2.0 版本中引入的一种新的数据类型。该数据类型本质上就是一个仅包含 0 和 1 的二进制字符串。而其所有相关命令都是对这个字符串二进制位的操作。用于描述该字符串的属性有三个：key、offset、bitValue。</p><p>key：BitMap 是 Redis 的 key-value 中的一种 Value 的数据类型，所以该 Value 一定有其对 应的 key。</p><p>offset：每个 BitMap 数据都是一个字符串，字符串中的每个字符都有其对应的索引，该索引从 0 开始计数。该索引就称为每个字符在该 BitMap 中的偏移量 offset。这个 offset 的值的范围是[0，2^32 -1]，近43亿</p><p>bitValue：每个 BitMap 数据中都是一个仅包含 0 和 1 的二进制字符串，每个 offset 位上的字符就称为该位的值 bitValue。bitValue 的值非 0 即 1。</p><ol><li><strong>setbit</strong></li></ol><p>格式：SETBIT key offset value</p><p>功能：为给定 key 的BitMap 数据的 offset 位置设置值为 value。其返回值为修改前该 offset 位置的 bitValue</p><p>对于原 BitMap 字符串中不存在的 offset 进行赋值，字符串会自动伸展以确保它 可以将 value 保存在指定的 offset 上，空白位置以 0 填充。需要注意的是，对使用较大 offset 的 SETBIT 操作来说，内存分配过程可能造成 Redis 服务器被阻塞。</p><ol start="2"><li><strong>getbit</strong></li></ol><p>格式：GETBIT key offset</p><p>功能：对 key 所储存的 BitMap 字符串值，获取指定 offset 偏移量上的位值 bitValue。</p><p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><ol start="3"><li><strong>bitcount</strong></li></ol><p>格式：BITCOUNT key [start] [end]</p><p>功能：统计给定字符串中被设置为 1 的 bit 位的数量。一般情况下，统计的范围是给定的整个 BitMap 字符串。但也可以通过指定额外的 start 或 end 参数，实现仅对指定字节范围内字符串进行统计，包括 start 和 end 在内。注意，这里的 start 与 end 的单位是字节，不是 bit，并且从 0 开始计数</p><ol start="4"><li><strong>bitpos</strong></li></ol><p>格式：BITPOS key bit [start] [end]</p><p>功能：返回 key 指定的 BitMap 中第一个值为指定值 bit(非 0 即 1) 的二进制位的位置。在默认情况下， 命令将检测整个 BitMap，但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。</p><ol start="5"><li><strong>bitop</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：BITOP operation destkey key [key …]</span><br></pre></td></tr></table></figure><p>功能：对一个或多个 BitMap 字符串 key 进行二进制位操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR </p><blockquote><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 BitMap 作为输入。</p><p>除了 NOT 操作外，其他对一个 BitMap 的操作其实就是一个复制。</p><p>如果参与运算的多个 BitMap 长度不同，较短的 BitMap 会以 0 作为补充位与较长 BitMap 运算，且运算结果长度与较长 BitMap 的相同。</p></blockquote><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>由于 offset 的取值范围很大，所以其一般应用于大数据量的二值性统计。例如平台活跃用户统计（访问或未访问）、支持率统计（支持或不支持）、员工考勤统计（上班或未上班）、图像二值化（黑或白）等。</p><h1 id="12-HyperLogLog-操作命令"><a href="#12-HyperLogLog-操作命令" class="headerlink" title="12. HyperLogLog 操作命令"></a>12. HyperLogLog 操作命令</h1><p>HyperLogLog 是 Redis 2.8.9 版本中引入的一种新的数据类型，其意义是 hyperlog log，超级日志记录。该数据类型可以简单理解为一个 set 集合，集合元素为字符串。但实际上 HyperLogLog 是一种<strong>基数计数概率算法</strong>，通过该算法可以利用极小的内存完成独立总数的统 计。其所有相关命令都是对这个“set 集合”的操作。</p><p>HyperLogLog 算法是一个纯数学算法</p><ol><li><strong>pfadd</strong></li></ol><p>格式：PFADD key element [element …]</p><p>功能：将任意数量的元素添加到指定的 HyperLogLog 集合里面。如果内部存储被修改了返回 1，否则返回 0。</p><ol start="2"><li><strong>pfcount</strong></li></ol><p>格式：PFCOUNT key [key …]</p><p>功能：该命令作用于单个 key 时，返回给定 key 的 HyperLogLog 集合的近似基数；该命 令作用于多个 key 时，返回所有给定 key 的 HyperLogLog 集合的并集的近似基数；如果 key 不存在，则返回 0。</p><ol start="3"><li><strong>pfmerge</strong></li></ol><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>HyperLogLog 可对数据量超级庞大的日志数据做不精确的去重计数统计。当然，这个不 精确的度在 Redis 官方给出的误差是 0.81%。这个误差对于大多数超大数据量场景是被允许的。对于平台上每个页面每天的 UV 数据，非常适合使用 HyperLogLog 进行记录。</p><blockquote><p>pv是页面浏览量；uv是客户端数量</p></blockquote><h1 id="13-Geospatial-操作命令"><a href="#13-Geospatial-操作命令" class="headerlink" title="13. Geospatial 操作命令"></a>13. Geospatial 操作命令</h1><p>Geospatial，地理空间。</p><p>Redis 在 3.2 版本中引入了 Geospatial 这种新的数据类型。该类型本质上仍是一种集合， 只不过集合元素比较特殊，是一种由三部分构成的数据结构，这种数据结构称为空间元素：</p><ul><li>经度：longitude。有效经度为[-180，180]。正的表示东经，负的表示西经。</li><li>纬度：latitude。有效纬度为[-85.05112878，85.05112878]。正的表示北纬，负的表示南纬。</li><li>位置名称：为该经纬度所标注的位置所命名的名称，也称为该 Geospatial 集合的空间元 素名称。</li></ul><p>通过该类型可以设置、查询某地理位置的经纬度，查询某范围内的空间元素，计算两空间元素间的距离等。</p><ol><li><strong>geoadd</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member …]</span><br></pre></td></tr></table></figure><p>功能：将一到多个空间元素添加到指定的空间集合中。</p><p>当用户尝试输入一个超出范围的经度或者纬度时，该命令会返回一个错误。</p><ol start="2"><li><strong>geopos</strong></li></ol><p>格式：GEOPOS key member [member …]</p><p>功能：从指定的地理空间中返回指定元素的位置，即经纬度。</p><p>因为该命令接受可变数量元素作为输入，所以即使用户只给定了一个元素，命令也会返回数组。</p><ol start="3"><li><strong>geodist</strong></li></ol><p>格式：GEODIST key member1 member2 [unit]</p><p>功能：返回两个给定位置之间的距离。其中 unit 必须是：m(米，默认)、km(千米)、mi(英里)、ft(英尺)</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。另外，在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><ol start="4"><li><strong>geohash</strong></li></ol><p>格式：GEOHASH key member [member …]</p><p>功能：返回一个或多个位置元素的 Geohash 值。</p><p>GeoHash 是一种地址编码方法。他能够把二维的空间经纬度数据编码成一个字符串。该值主要用于底层应用或者调试， 实际中的作用并不大。</p><ol start="5"><li><strong>georadius</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</span><br></pre></td></tr></table></figure><p>功能：以给定的经纬度为中心，返回指定地理空间中包含的所有位置元素中，与中心距离不超过给定半径的元素。返回时还可携带额外的信息：</p><ul><li>WITHDIST ：在返回位置元素的同时，将位置元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。</li><li>WITHCOORD ：将位置元素的经维度也一并返回。</li><li>WITHHASH：将位置元素的 Geohash 也一并返回，不过这个 hash 以整数形式表示</li></ul><p>命令默认返回未排序的位置元素。 通过以下两个参数，用户可以指定被返回位置元素的排序方式：</p><ul><li>ASC ：根据中心的位置，按照从近到远的方式返回位置元素。</li><li>DESC ：根据中心的位置，按照从远到近的方式返回位置元素。</li></ul><p>在默认情况下， 该命令会返回所有匹配的位置元素。虽然用户可以使用 COUNT  选项去获取前 N 个匹配元素，但因为命令在内部可能会需要对所有被匹配的元素进行处理，所以在对一个非常大的区域进行搜索时，即使使用 COUNT 选 项去获取少量元素，该命令的执行速度也可能会非常慢。</p><ol start="6"><li><strong>georadiusbymember</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</span><br></pre></td></tr></table></figure><p>功能：这个命令和 GEORADIUS 命令一样，都可以找出位于指定范围内的元素，但该命令的中心点是由位置元素形式给定的，而不是像 GEORADIUS 那样，使用输入的经纬度来指定中心点。</p><p>返回结果中也是包含中心点位置元素的</p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>Geospatial 的意义是地理位置，所以其主要应用地理位置相关的计算。例如钉钉中的“签到” 功能等。</p><h1 id="14-发布-x2F-订阅命令"><a href="#14-发布-x2F-订阅命令" class="headerlink" title="14. 发布&#x2F;订阅命令"></a>14. 发布&#x2F;订阅命令</h1><p>发布&#x2F;订阅，即 pub&#x2F;sub，是一种消息通信模式：发布者也称为消息生产者，生产和发送 消息到存储系统；订阅者也称为消息消费者，从存储系统接收和消费消息。整个消息发布者、 订阅者与存储系统称为消息系统。</p><p>Redis 构成的消 息系统中，发布&#x2F;订阅的消息都是以频道 Channel 分类的。</p><ol><li><strong>subscribe</strong></li></ol><p>格式：SUBSCRIBE channel [channel …]</p><p>Redis 客户端通过一个 subscribe 命令可以同时订阅任意数量的频道。在输出了订阅了主题后，命令处于阻塞状态，等待相关频道的消息。</p><ol start="2"><li><strong>psubscribe</strong></li></ol><p>格式：PSUBSCRIBE pattern [pattern …]</p><p>功能：订阅一个或多个符合给定模式的频道。</p><p>这里的模式只能使用通配符 *。例如，it* 可以匹配所有以 it 开头的频道，像 it.news、 it.blog、it.tweets 等；news.*可以匹配所有以 news.开头的频道，像 news.global.today、 news.it 等。</p><ol start="3"><li><strong>publish</strong></li></ol><p>格式：PUBLISH channel message</p><p>功能：Redis 客户端退订指定的频道。</p><p>如果没有频道被指定，也就是一个无参数的 UNSUBSCRIBE 命令被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p><ol start="4"><li><strong>punsubscribe</strong></li></ol><p>格式：PUNSUBSCRIBE [pattern [pattern …]]</p><p>功能：退订一个或多个符合给定模式的频道。</p><p>这里的模式只能使用通配符 *。如果没有频道被指定，客户端将退订所有订阅的频道。</p><ol start="5"><li><strong>pubsub</strong></li></ol><p>格式：PUBSUB  &lt;subcommand&gt; [argument [argument …]]</p><p>功能：PUBSUB 是一个查看订阅与发布系统状态的内省命令集，它由数个不同格式的子命令组成</p><ul><li>pubsub channels</li></ul><p>格式：PUBSUB CHANNELS [pattern]</p><p>功能：列出当前所有的活跃频道。活跃频道指的是那些至少有一个订阅者的频道。</p><p>如果不给出 pattern 参数，将会列出订阅&#x2F;发布系统中的所有活跃频道。如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。pattern 中只能使用通配符*。</p><ul><li>pubsub numsub</li></ul><p>格式：PUBSUB NUMSUB [channel-1 … channel-N]</p><p>功能：返回给定频道的订阅者数量。不给定任何频道则返回一个空列表。</p><ul><li>pubsub numpat</li></ul><p>格式：PUBSUB NUMPAT</p><p>功能：查询当前 Redis 所有客户端订阅的所有频道模式的数量总和</p><h1 id="15-Redis-事务"><a href="#15-Redis-事务" class="headerlink" title="15. Redis 事务"></a>15. Redis 事务</h1><p>Redis 的事务的本质是一组命令的批处理。这组命令在执行过程中会被顺序地、一次性全部执行完毕，只要没有出现语法错误，这组命令在执行期间是不会被中断。</p><p>事务特性：</p><ul><li>Redis 的事务仅保证了数据的一致性，不具有像 DBMS 一样的 ACID 特性。</li><li>这组命令中的某些命令的执行失败不会影响其它命令的执行，不会引发回滚。即不具备原子性。</li><li>这组命令通过乐观锁机制实现了简单的隔离性。没有复杂的隔离级别。</li><li>这组命令的执行结果是被写入到内存的，是否持久取决于 Redis 的持久化策略，与事务无关。</li></ul><h3 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h3><ol><li><strong>multi</strong>：开启事务</li><li><strong>exec</strong>：执行事务</li><li><strong>discard</strong>：取消事务</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203747.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203747.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="78872cfb3a5d701f267f30f5fd69ebe3.png"></p><h3 id="Redis-事务异常处理"><a href="#Redis-事务异常处理" class="headerlink" title="Redis 事务异常处理"></a>Redis 事务异常处理</h3><p>语法错误：</p><p>当事务中的命令出现语法错误时，整个事务在 exec 执行时会被取消。也就是所有指令都不执行</p><p>执行异常：</p><p>如果事务中的命令没有语法错误，但在执行过程中出现异常，该异常不会影响其它命令的执行。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203751.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203751.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a9c6c606aa88a68ea2e695c1c6eeaecb.png"></p><h3 id="Redis-事务隔离机制"><a href="#Redis-事务隔离机制" class="headerlink" title="Redis 事务隔离机制"></a>Redis 事务隔离机制</h3><p>在并发场景下可能会出现多个客户端对同一个数据进行修改的情况。为了解决这种情况造成的问题，Redis 事务通过乐观锁机制（添加版本号）实现了多线程下的执行隔离。</p><ul><li><strong>watch</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203754.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101203754.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="82f5ad336720032ba812d9153a760ed7.png"></p><p>由于添加了乐观锁，另一个客户端在此期间先修改了age，导致此客户端事务执行失败</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列第一章</title>
      <link href="/2023/11/01/Redis/1.Redis%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/01/Redis/1.Redis%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1. Redis简介"></a>1. Redis简介</h1><p>Redis，Remote Dictionary Server，远程字典服务，由意大利人 Salvatore Sanfilippo（又名 Antirez）开发，是一个使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库，其提供多种语言的 API。</p><p>Redis 之所以称之为字典服务，是因为 Redis 是一个 key-value 存储系统。</p><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。传统的关系数据库在处理超大规模和高并发的 SNS 类型 的 web2.0 纯动态网站时出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</p><ol><li>键值存储数据库：典型代表是 Redis。</li><li>列存储数据库：典型代表是 HBase。</li></ol><p>关系型数据库是典型的行存储数据库。其存在的问题是，按行存储的数据在物理层面占用的是连续存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储。</p><ol start="3"><li>文档型数据库：最像关系型数据库的 NoSQL。典型代表是 MongoDB。</li><li>图形(Graph)数据库：典型代表是 Neo4J。</li></ol><h2 id="Redis-的用途"><a href="#Redis-的用途" class="headerlink" title="Redis 的用途"></a>Redis 的用途</h2><p>Redis 在生产中使用最多的场景就是做数据缓存。即客户端从 DBMS 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT，而且降低了 DBMS 的压力。</p><p>根据 Redis 缓存的数据与 DBMS 中数据的同步性划分，缓存一般可划分为两类：</p><ul><li><span style="color: gold;">实时同步缓存</span></li></ul><p>DBMS 中数据更新后，Redis 缓存中的存放的相关数据会被立即清除，以促使再有对该数据的访问请求到来时，必须先从 DBMS 中查询获取到最新数据，然后再写入到 Redis。</p><ul><li><span style="color: gold;">阶段性同步缓存</span>。</li></ul><p>Redis 缓存中的数据允许在一段时间内与 DBMS 中的数据不完全一致。而这个时间段就是这个缓存数据的过期时间。</p><h2 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h2><p>能够做缓存的技术、中间件很多，例如MyBatis 自带的二级缓存、Memched 等。只所以在生产中做缓存的产品几乎无一例外的会选择 Redis，是因为它有很多其它产品所不具备的特性。</p><ol><li>性能极高：Redis 读的速度可以达到 11w 次&#x2F;s，写的速度可以达到 8w 次&#x2F;s。<ul><li>Redis 的所有操作都在内存中。</li><li>Redis 是用 C 语言开发。</li><li>Redis 源码非常精细（集性能与优雅于一身）。</li></ul></li><li>简单稳定</li><li>持久化：Redis 内存中的数据可以进行持久化，其有两种方式：RDB 与 AOF。</li><li>高可用集群：Redis 提供了高可用的主从集群功能，可以确保系统的安全性。</li><li>丰富的数据类型</li><li>强大的功能：Redis 提供了数据过期功能、发布&#x2F;订阅功能、简单事务功能，还支持 Lua 脚本扩展功能。</li><li>客户端语言广泛：Redis提供了简单的 TCP 通信协议，编程语言可以方便地的接入 Redis。</li><li>支持 ACL 权限控制：之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块（一种细粒度的权限管理策略，可以针对任意用户与组进行权限控制）</li><li>支持多线程 IO 模型：Redis 之前版本采用的是单线程模型，从 6.0 版本开始支持了多线 程模型。</li></ol><h2 id="Redis-的-IO-模型"><a href="#Redis-的-IO-模型" class="headerlink" title="Redis 的 IO 模型"></a>Redis 的 IO 模型</h2><p>Redis 处理客户端请求所采用 的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的。</p><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是纯粹的单线程模型。即所有客户 端的请求全部由一个线程处理。</p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202516.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7add5d02e29cdaa5f947d56d1a75fc06.png" width="647" height="287"><p>采用了多路复用技术，常见的有三种多路选择算法：</p><ul><li>select 模型：底层使用数组，性能较低</li><li>poll 模型：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的。</li><li>epoll 模型的选择算法：采用的是回调方式。根据就绪事件发生后的处理方式的不同， 又可分为 LT 模型与 ET 模型。</li></ul><p>每个客户端若要向 Redis 提交请求，都需要与 Redis 建立一个 socket 连接，并向事件分发器（会根据不同的就绪事件，将任务交由不同的事件处理器处理）注册一个事件。一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个唯一的线程来处理。如果该线程繁忙，则将该任务写入到任务队列等待线程处理。</p><h3 id="混合线程模型"><a href="#混合线程模型" class="headerlink" title="混合线程模型"></a>混合线程模型</h3><p>从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线 程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。 例如，持久化、对 AOF 的 rewrite、对失效连接的清理等。</p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202521.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202521.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c2560a6afa6feebfe80ba4b3c9ce7c97.png" width="650" height="349"><h3 id="多线程模式"><a href="#多线程模式" class="headerlink" title="多线程模式"></a>多线程模式</h3><p>Redis 6.0 版本，才是真正意义上的多线程模型。因为其对于客户端请求的处理采用的是多线程模型。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202524.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202524.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="950c59b92a4ccca773b8e5fecd233fab.png"></p><p>多线程 IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求写入到任务队列。而对具体任务（命令）的处理，仍是由主线程处理。这样做使得用户无需考虑线程安全问题，无需考虑事务控制，无需考虑像 LPUSH&#x2F;LPOP 等命令的执行顺序问题。</p><p>总结：</p><ul><li>单线程模型</li></ul><p>可维护性高，性能高。性能会受到影响，且由于单线程只能使用一个处理器，会形成处理器浪费。</p><ul><li>多线程模型</li></ul><p>结合了多线程与单线程的优点，避开了它们的所有不足。并非是一个真正意义上的 “多线程”，因为真正处理“任务”的线程仍是单线程</p><h1 id="2-Redis-的安装与配置"><a href="#2-Redis-的安装与配置" class="headerlink" title="2. Redis 的安装与配置"></a>2. Redis 的安装与配置</h1><p>官网：<a href="https://redis.io/">Redis</a></p><p>将 Redis 安装到 Linux 系统中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure><p>Redis 是由 C&#x2F;C++ 语言编写的，而从官网下载的 Redis 安装包需要编译后才可安装，所以必须要使用相关编译器。对于 C&#x2F;C++ 语言的编译器，使用最多的是 gcc 与 gcc-c++</p><ol><li>上传到虚拟机后进行解压：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-7.03.tar.gz -C /opt/apps</span><br></pre></td></tr></table></figure><blockquote><p>为了方便可以将解压后的文件目录改为redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv redis-7.0.3/ redis</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>编译：</li></ol><p>编译过程是根据 Makefile 文件进行的，解压包中已经存在该文件，进入到解压目录中，然后执行编译命令 make。</p><ol start="3"><li>安装：</li></ol><p>编译过后执行 make install 进行安装。可以看到，共安装了三个组件：redis 服务器、客户端与一个性能测试工具 benchmark。</p><p>安装完成后打开&#x2F;usr&#x2F;local&#x2F;bin 目录，可以看到出现了很多的可执行文件。<br>echo $PATH 可以看到，&#x2F;usr&#x2F;local&#x2F;bin 目录是存在于该系统变量中的。</p><h2 id="Redis-的启停"><a href="#Redis-的启停" class="headerlink" title="Redis 的启停"></a>Redis 的启停</h2><p> Redis 的停止：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>方式一：前台启动</p><p>在任意目录执行 redis-server 命令即可启动 Redis。这种启动方式会占用当前命令行窗口。可以直接 ctrl+c 结束进程。</p><p>方式二：命令式后台启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub redis-server &amp;</span><br></pre></td></tr></table></figure><p>使用 nohub 命令，最后再添加一个&amp;符，可以使要启动的程序在后台以守护进程方式运行。这样的好处是，进程启动后不会占用一个会话窗口，且其还会在当前目录，即运行启动命令的当前目录中创建一个 nohup.out 文件用于记录 Redis 的操作日志。</p><p>方式三：配置式后台启动</p><p>可以通过修改 Linux 中 Redis 的核心配置文件 redis.conf 达到后台启动的目的。redis.conf 文件在 Redis 的安装目录根下。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202532.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202532.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e5ef20b1415faacd9f0455f53ad46703.png"></p><blockquote><p>将 no 改为 yes</p></blockquote><p>修改后再启动 Redis，就无需再键入 nohup 与&amp;符了，但必须要指定启动所使用的 Redis 配置文件。</p><p>使用 nohup redis-server &amp;命令启动 Redis 时，启动项中已经设置好了 Redis 各个参数的默认值，Redis 会按照这些设置的参数进行启动。但这些参数是可以在配置文件中进行修改的，修改后，需要在启动命令中指定要加载的配置文件，这样，配置文件中的参数值将覆盖原默认值。</p><p>Redis 已经给我们提供好了配置文件模板，就是 redis.conf 文件。对 redis.conf 配置文件做了修改，要在开启 Redis 时需要显示指出要加载的配置文件。配置文件应紧跟在 redis-server 的后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /opt/apps/redis/redis.conf</span><br></pre></td></tr></table></figure><blockquote><p>为了方便起见，我们可以给该命令设置别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;#查看所有别名</span><br><span class="line">&gt;alias</span><br><span class="line">&gt;#设置别名</span><br><span class="line">&gt;alias redis-server=&#x27;redis-server /opt/apps/redis/redis.conf&#x27;</span><br><span class="line">&gt;#删除别名</span><br><span class="line">&gt;unalias redis-server</span><br></pre></td></tr></table></figure></blockquote><h2 id="Redis-的连接"><a href="#Redis-的连接" class="headerlink" title="Redis 的连接"></a>Redis 的连接</h2><p>Redis 是一个内存数据库服务器，就像 MySQL 一样，对其操作也需要通过客户端进行。若要使远程主机上的客户端能够连接并访问到服务端的 Redis，则服务端首先要做如下配置。</p><h3 id="绑定客户端-IP"><a href="#绑定客户端-IP" class="headerlink" title="绑定客户端 IP"></a>绑定客户端 IP</h3><p>Redis 可以通过修改配置文件来限定可以访问自己的客户端 IP。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bbb51eefd2cbf5909c9948367c05196f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bbb51eefd2cbf5909c9948367c05196f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bbb51eefd2cbf5909c9948367c05196f.png"></p><p>默认配置只允许当前主机访问 Redis，不需要限定访问的客户端可以直接注释掉</p><h3 id="关闭保护模式"><a href="#关闭保护模式" class="headerlink" title="关闭保护模式"></a>关闭保护模式</h3><p>默认保护模式是开启的，其只允许本机的客户端访问</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/62743fd77a15b0b5218061127ff7d8db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/62743fd77a15b0b5218061127ff7d8db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="62743fd77a15b0b5218061127ff7d8db.png"></p><h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><p>默认没有密码。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/02f2418b52df744252659daca2a117a9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/02f2418b52df744252659daca2a117a9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="02f2418b52df744252659daca2a117a9.png"></p><p>设置后没有通过密码登录的用户，无法读&#x2F;写 Redis。</p><p>使用密码：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202544.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202544.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ff68cddaa8a7ebc0a123e48906ab4cc5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202546.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="22d758ff7ae5e128b298b1beca162c28.png"></p><h3 id="禁止-x2F-重命名命令"><a href="#禁止-x2F-重命名命令" class="headerlink" title="禁止&#x2F;重命名命令"></a>禁止&#x2F;重命名命令</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202548.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202548.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5f86ce17855dd2204efeeef5e771236e.png"></p><p>禁用 flushall 命令，也可以在双引号内重命名命令，防止其他用户使用</p><h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>Redis 客户端也像 MySQL 客户端一样有多种类型：命令行客户端、图形界面客户端、Java 代码客户端。</p><ol><li>Redis 提供了基本的命令行客户端。打开命令行客户端的命令为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h Redis服务器IP -p Redis端口号 -a 密码</span><br></pre></td></tr></table></figure><blockquote><p>连接本机 Redis，且端口号没有改变(6379)，则-h 与-p 选项可以省略不写；-a 也可以省略</p></blockquote><ol start="2"><li>图形界面客户端</li></ol><p>Redis 的图形界面客户端中较出名的是 Redis Desktop Manager 。该软件在0.8.8 版本后变为了商业化收费软件。 官网为：<a href="https://resp.app/">https://resp.app/</a></p><blockquote><p>连接需要关闭防火墙</p></blockquote><ol start="3"><li>Java 代码客户端</li></ol><p>所谓 Java 代码客户端就是一套操作 Redis 的 API，其作用就像 JDBC 一样，所以 Java 代码客户端其实就是一个或多个 Jar 包，提供了对 Redis 的操作接口。最常用也是最有名的是 Jedis。</p><h1 id="3-Redis-配置文件详解"><a href="#3-Redis-配置文件详解" class="headerlink" title="3. Redis 配置文件详解"></a>3. Redis 配置文件详解</h1><p>打开配置文件：</p><ul><li>1-6 行用于说明，如果要启动 Redis，需要指出配置文件的路径。</li><li>8-16 行用于说明当前配置文件中可以使用的的容量单位及意义。</li><li>18 行用于说明这些容量单位没有大小写之分。</li></ul><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>指定要在当前配置文件中包含的配置文件。</p><p>目的主要是便于配置信息管理：可以将不同场景的配置都进行单独定义，然后在当前核心配置文件中根据不同场景选择包含进不同的配置文件。</p><p>如注释所述，需要将包含的配置文件写在最后一行，包含的配置文件中的参数会覆盖当前配置文件中的参数</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202558.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9be8495f740432dd0b674673edd49a93.png"></p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>Redis 配置文件中可以通过加载不同的第三方模块，来增强、扩展 Redis 的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202600.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202600.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f6abe76410281e4f3230ffda7470ad53.png"></p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>Network 配置模块是比较重要的部分，主要进行网络相关的配置。</p><ol><li>bind</li></ol><p>指定可以访问当前 Redis 服务的客户端 IP，默认只允许本地访问</p><ol start="2"><li>protected-mode</li></ol><p>默认保护模式是开启的。其只允许本机的客户端访问</p><ol start="3"><li>port</li></ol><p>Redis 监听的连接端口号，默认 6379</p><ol start="4"><li>tcp-backlog</li></ol><p>tcp-backlog 是一个 TCP 连接的队列，其主要用于解决高并发场景下客户端<span style="color:DarkTurquoise">慢连接</span>问题。这里设置的值就是这个队列的长度。该队列与 TCP 连接的三次握手有关。不同的 Linux 内核，backlog 队列中存放的元素（客户端连接）类型是不同的。</p><p>Linux 内核 2.2 版本之前，该队列中存放的是已完成了第一次握手的所有客户端连接。当然，此时的 backlog 队列中的连接具有两种状态：未完成三次握手的连接状态为 SYN_RECEIVED，已完成三次握手的连接状态为 ESTABLISHED。只有 ESTABLISHED 状态的连接才会被 Redis 处理。</p><p>Linux 内核 2.2 版本之后 TCP 系统中维护了两个队列：SYN_RECEIVED 队列与 ESTABLISHED 队列。此时的 backlog 就是 ESTABLISHED 队列。</p><p>查看 Linux 内核版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><p>TCP 中的 backlog 队列的长度在 Linux 中由内核参数 somaxconn 来决定。所以在 Redis 中该队列的长度由 Redis 配置文件设置与 somaxconn 来共同决定：取它们中的最小值。</p><p>查看当前 Linux 内核中 somaxconn 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><blockquote><p>默认是128</p></blockquote><p>高并发场景下，backlog 的值最好要大一些，否则可能会影响系统性能。 修改&#x2F;etc&#x2F;sysctl.conf 文件，在文件最后添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn=2048</span><br></pre></td></tr></table></figure><p>执行以下命令或重启虚拟机生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ol start="5"><li>timeout</li></ol><p>空闲超时。当客户端与 Redis 间的空闲时间超过该时长后，连接自动断开。单位秒。默认值为 0，表示永远不超时。</p><ol start="6"><li>tcp-keepalive</li></ol><p>该配置主要用于设置 Redis 检测与其连接的所有客户端的存活性时间间隔，单位秒。一般是在 timeout 设置为 0 时进行配置。</p><blockquote><p>大多数软件都是由客户端定时发送“心跳”给服务器</p></blockquote><h3 id="general"><a href="#general" class="headerlink" title="general"></a>general</h3><ol><li>daemonize</li></ol><p>该配置可以控制 Redis 启动是否采用守护进程方式，即是否是后台启动。yes 是采用后 台启动。</p><ol start="2"><li>pidfile</li></ol><p>该配置用于指定 Redis 运行时 pid 写入的文件，不同的启动方式，pid 文件的产生效果是不同的：</p><ul><li>采用守护进程方式启动（daemonize 为 yes）：pid 文件为&#x2F;var&#x2F;run&#x2F;redis.pid。</li><li>采用前台启动（daemonize 为 no）：不生产 pid 文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202604.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202604.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5d88bede57b5f30fac78b7f5b036eb6a.png"></p><ol start="3"><li>loglevel</li></ol><p>配置日志的级别。Redis 中共有四个级别，由低到高依次是：debug &gt; verbose &gt; notice（默认值）&gt; warning。详细介绍可以参考注释</p><ol start="4"><li>logfile</li></ol><p>指定日志文件。如果设置为空串，则强制将日志记录到标准输出设备（显示器）；使用守护进程启动方式则会将日志发送到设备&#x2F;dev&#x2F;null（空设备）。</p><ol start="5"><li>databases</li></ol><p>设置数据库的数量，默认16个。连接默认使用 0 号数据库，可以使用 select &lt;dbid&gt;在每个连接的基础上选择不同的数据库</p><h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><p>用户设置 ACL 权限、Redis 访问密码相关配置。该模块中最常用的就是 requirepass 属性</p><h3 id="clients"><a href="#clients" class="headerlink" title="clients"></a>clients</h3><p>该模块用于设置与客户端相关的属性，其中仅包含一个属性 maxclients。 </p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202607.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231101202607.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="df8461bdb1d25d9200c19c66fb51821a.png"></p><p>maxclients 用于设置 Redis 可并发处理的客户端连接数量，默认值为 10000（Redis 内部占用32个）。如果达到了该最大连接数，则会拒绝再来的新连接，并返回一个异常信息：已达到最大连接数。</p><p>注意：该值不能超过 Linux 系统支持的可打开的文件描述符最大数量阈值。可以通过修改&#x2F;etc&#x2F;secutiry&#x2F;limits.conf 文件修改该值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n #查看阈值</span><br></pre></td></tr></table></figure><p>注释中的 important 有关集群创建，需要注意</p><h3 id="memory-management"><a href="#memory-management" class="headerlink" title="memory management"></a>memory management</h3><p>该配置可以控制最大可用内存及相关内容移除问题。</p><ol><li>maxmemory</li></ol><p>将内存使用限制设置为指定的字节数。当达到内存限制时，Redis 将根据选择的逐出策略 maxmemory-policy 尝试删除符合条件的 key。 如果不能按照逐出策略移除 key，则会给写操作命令返回 error，但不会影响只读的命令</p><ol start="2"><li>maxmamory-policy</li></ol><p>该属性用于设置，当达到 maxmemory 时，Redis 将如何选择要移除的内容。Redis 中共支持 8 种移除策略：</p><ul><li>volatile-lru：使用近似 LRU 算法移除，仅适用于设置了过期时间的 key。</li><li>allkeys-lru：使用近似 LRU 算法移除，可适用于所有类型的 key。</li><li>volatile-lfu：使用近似 LFU 算法移除，仅适用于设置了过期时间的 key。 </li><li>allkeys-lfu：使用近似 LFU 算法移除，可适用于所有类型的 key。</li><li>volatile-random：随机移除一个 key，仅适用于设置了过期时间的 key。 </li><li>allkeys-random：随机移除一个 key，可适用于所有类型的 key。</li><li>volatile-ttl：移除距离过期时间最近的 key。</li><li>noeviction：不移除任何内容，只是在写操作时返回一个错误，默认值。</li></ul><ol start="3"><li>maxmemory-samples</li></ol><p>该属性用于指定挑选要删除的 key 的样本数量。样本的选择采用的是 LRU 算法，不能修改。但从样本中再选择要移除的 key，则采用的是 maxmamory-policy 指定的策略。</p><ol start="4"><li>maxmemory-eviction-tenacity</li></ol><p>设置移除容忍度。数值越小表示容忍度越低，需要移除的数据移除延迟越小；数值越大表示容忍度越高，需要移除的数据移除延迟越大。</p><h3 id="threaded-I-x2F-O"><a href="#threaded-I-x2F-O" class="headerlink" title="threaded I&#x2F;O"></a>threaded I&#x2F;O</h3><p>该配置模块用于配置 Redis 对多线程 IO 模型的支持。</p><ol><li>io-threads</li></ol><p>该属性用于指定要启用多线程 IO 模型时，要使用的线程数量。建议至少预留一个核心（用于数据持久化）。没必要别开，会占用大量cpu资源</p><p>查看当前系统信息：<code>lscpu</code></p><ol start="2"><li>io-threads-do-reads</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/c24376e94094e227393cfeb2e4561471.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/c24376e94094e227393cfeb2e4561471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c24376e94094e227393cfeb2e4561471.png"></p><p>该属性用于启用多线程 IO 模型中的多线程处理读请求的能力。</p><p>总结：如果需要改配置，一定要先看注释，网络信息不一定对</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Netflix</title>
      <link href="/2023/10/29/%E6%A1%86%E6%9E%B6/6.Spring%20Cloud%20Netflix/"/>
      <url>/2023/10/29/%E6%A1%86%E6%9E%B6/6.Spring%20Cloud%20Netflix/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务与SpringCloud"><a href="#1-微服务与SpringCloud" class="headerlink" title="1. 微服务与SpringCloud"></a>1. 微服务与SpringCloud</h1><p>微服务的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</p><p>微服务技术栈：</p><ul><li>服务开发：Springboot、Spring、SpringMVC</li><li>服务配置与管理：Netflix公司的Archaius、阿里的Diamond等</li><li>服务注册与发现：Eureka、Consul、Zookeeper等</li><li>服务调用：Rest、RPC、gRPC</li><li>服务熔断器：Hystrix、Envoy等</li><li>负载均衡：Ribbon、Nginx等</li><li>服务接口调用(客户端调用服务的简化工具)：Feign等</li><li>消息队列：Kafka、RabbitMQ、ActiveMQ等</li><li>服务配置中心管理：SpringCloudConfig、Chef等</li><li>服务路由（API网关）：Zuul等</li><li>服务监控：Zabbix、Nagios、Metrics、Spectator等</li><li>全链路追踪：Zipkin，Brave、Dapper等</li><li>服务部署：Docker、OpenStack、Kubernetes等</li><li>数据流操作开发包：SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息</li><li>事件消息总线：Spring Cloud Bus</li><li>……</li></ul><p>Spring Cloud是一套用于构建微服务架构的规范，本章介绍的 Spring Cloud Netflix 是 Spring Cloud 的一套实现。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>官网：<a href="https://spring.io/projects/spring-cloud">Spring Cloud</a></p><blockquote><p>参考网站：<a href="https://www.springcloud.cc/">Spring Cloud中文网-官方文档中文版</a>、<a href="http://springcloud.cn/">Spring Cloud中国社区</a></p></blockquote><p>SpringCloud基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件。SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到一键启动和部署。</p><p>SpringBoot将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。</p><p>和SPringBoot的关系：SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。</p><blockquote><p>SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系. SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。   </p></blockquote><p>SpringCloud和Dubbo对比：</p><ul><li><strong>初始定位不同：</strong> SpringCloud定位为微服务架构下的一站式解决方案；Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用和治理</li><li><strong>生态环境不同：</strong> SpringCloud依托于Spring平台，具备更加完善的生态体系；而Dubbo一开始只是做RPC远程调用，生态相对匮乏。</li><li><strong>调用方式：</strong> SpringCloud是采用Http协议做远程调用，接口一般是Rest风格，比较灵活；Dubbo是采用Dubbo协议，接口一般是Java的Service接口，格式固定。但调用时采用Netty的NIO方式，性能较好。</li><li>组件差异比较多，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper</li></ul><table><thead><tr><th align="center">功能</th><th align="center">Dubbo</th><th align="center">SpringCloud</th></tr></thead><tbody><tr><td align="center">服务注册中心</td><td align="center">Zookeeper</td><td align="center">Eureka(主流)、Consul、Zookeeper</td></tr><tr><td align="center">服务调用方式</td><td align="center">RPC基于Dubbo协议</td><td align="center">REST API基于HTTP协议</td></tr><tr><td align="center">服务监控</td><td align="center">Dubbo-Monitor</td><td align="center">Spring Boot Admin</td></tr><tr><td align="center">熔断器</td><td align="center">不完善</td><td align="center">Spring Cloud Netflix Hystrix</td></tr><tr><td align="center">服务网关</td><td align="center">无</td><td align="center">Spring Cloud Netflix Zuul、Gateway</td></tr><tr><td align="center">分布式配置</td><td align="center">无</td><td align="center">Spring Cloud Config</td></tr><tr><td align="center">服务跟踪</td><td align="center">无</td><td align="center">Spring Cloud Sleuth + Zipkin(一般)</td></tr><tr><td align="center">数据流</td><td align="center">无</td><td align="center">Spring Cloud Stream</td></tr><tr><td align="center">批量任务</td><td align="center">无</td><td align="center">Spring Cloud Task</td></tr><tr><td align="center">信息总线</td><td align="center">无</td><td align="center">Spring Cloud Bus</td></tr></tbody></table><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>Remote Procedure Call，远程过程调用。</p><ul><li><strong>数据传输方式：</strong> 多数RPC框架选择TCP作为传输协议，性能比较好。</li><li><strong>数据传输内容：</strong> 请求方需要告知需要调用的函数的名称、参数、等信息。</li><li><strong>序列化方式：</strong> 客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化</li></ul><h1 id="2-构建Rest微服务"><a href="#2-构建Rest微服务" class="headerlink" title="2. 构建Rest微服务"></a>2. 构建Rest微服务</h1><p>父工程依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservicecloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicecloud-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicecloud-provider-dept-8001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicecloud-consumer-dept-80<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>microservicecloud-api：封装的整体Entity&#x2F;接口&#x2F;公共配置等</li></ul><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="comment">&lt;!-- 当前Module需要用到的jar包，父类已经包含了，可以不用写版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：网络当中传输对象必须要序列化，并且必须存在空参构造器。</p><ul><li>microservicecloud-provider-dept-8001：微服务落地的服务提供者</li></ul><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Dept部门Entity --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservicecloud-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改后立即生效，热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/**/*.xml</span>       <span class="comment"># mapper映射文件</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis.cfg.xml</span>        <span class="comment"># mybatis配置文件所在路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microservicecloud-dept</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/clouddb01</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">dbcp2:</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span>           <span class="comment"># 数据库连接池的最小维持连接数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span>       <span class="comment"># 初始化连接数</span></span><br><span class="line">      <span class="attr">max-total:</span> <span class="number">5</span>          <span class="comment"># 最大连接数</span></span><br><span class="line">      <span class="attr">max-wait-millis:</span> <span class="number">200</span>  <span class="comment"># 等待连接获取的最大超时时间</span></span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptConsumer80_App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DeptConsumer80_App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>microservicecloud-consumer-dept-80：微服务调用的客户端使用</li></ul><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自己定义的api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservicecloud-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改后立即生效，热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中只用设置端口号为80；启动类就不再赘述</p><blockquote><p>80端口是为HTTP开放的，浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入”:80”了。 </p></blockquote><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p><code>RestTemplate</code>提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。</p><p>使用restTemplate访问restful接口非常的简单粗暴。<code>(url, requestMap, ResponseBean.class)</code>这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController_Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REST_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="string">&quot;/dept/add&quot;</span>, dept, Boolean.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">&quot;/dept/get/&quot;</span> + id, Dept.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">&quot;/dept/list&quot;</span>, List.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里访问的是8001端口的服务，学习注册中心后我们的请求地址将是动态获取的。</p><p>本地测试：<a href="http://localhost/consumer/dept/list">http://localhost/consumer/dept/list</a></p><h1 id="3-Eureka"><a href="#3-Eureka" class="headerlink" title="3. Eureka"></a>3. Eureka</h1><p>Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，称为服务注册中心，负责服务注册与发现。 而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。</p><p>SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</p><p>Eureka包含两个组件：Eureka Server和Eureka Client。Eureka Server提供服务注册服务各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）        </p><h2 id="搭建eureka服务注册中心"><a href="#搭建eureka服务注册中心" class="headerlink" title="搭建eureka服务注册中心"></a>搭建eureka服务注册中心</h2><p>创建子工程microservicecloud-eureka-7001，引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--eureka-server服务端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 修改后立即生效，热部署 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">loaclhost</span>   <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>       <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span>  <span class="comment">//EurekaServer服务器端启动类,接受其它微服务注册进来</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServer7001_App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServer7001_App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地测试地址：<a href="http://localhost:7001/">http://localhost:7001/</a></p><h2 id="注册微服务"><a href="#注册微服务" class="headerlink" title="注册微服务"></a>注册微服务</h2><p>修改已创建的微服务：microservicecloud-provider-dept-8001</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将微服务provider侧注册进eureka --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>主启动类中添加注解：<code>@EnableEurekaClient</code></p><p>先后启动后可以在<a href="http://localhost:7001/%E4%B8%AD%E7%9C%8B%E5%88%B0%E6%B3%A8%E5%86%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9A">http://localhost:7001/中看到注册的服务：</a></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105739.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105739.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8148e377ba519f6c3164b8d4cb405eea.png"></p><p>我们可以在配置文件中优化微服务信息的显示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">microservicecloud-dept8001</span>  <span class="comment">#自定义服务名称信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>                  <span class="comment">#访问路径显示IP地址</span></span><br></pre></td></tr></table></figure><p>但当前点击超链接会报告ErrorPage，需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父工程中添加构建信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>microservicecloud<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">delimit</span>&gt;</span>$<span class="tag">&lt;/<span class="name">delimit</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>微服务(8001)可以在配置文件中设置页面信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">atguigu-microservicecloud</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">www.atguigu.com</span></span><br><span class="line">  <span class="comment">#以下两条都是由父类添加的构建插件解析的</span></span><br><span class="line">  <span class="attr">build.artifactId:</span> <span class="string">$&#123;project.artifactId&#125;</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">$&#123;project.version&#125;</span></span><br></pre></td></tr></table></figure><h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>Zookeeper支持CAP理论中的CP，而Eureka支持AP，在某个时刻微服务不可用了，eureka也不会立刻清理，依旧会对该微服务的信息进行保存。</p><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>以7001为模板创建Eureka Server工程7002和7003。</p><p>修改配置文件的命名；修改host文件；修改配置文件，模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka1</span>   <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>       <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span></span><br><span class="line">      <span class="comment">#defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka2:7002/eureka/,http://eureka3:7003/eureka/</span></span><br></pre></td></tr></table></figure><p>修改微服务的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:7001/eureka/,http://eureka2:7002/eureka/,http://eureka3:7003/eureka/</span></span><br></pre></td></tr></table></figure><p>依次运行注册中心和微服务即可，可以在三个注册中心中看到注册的服务。</p><blockquote><p>端口后的<code>/eureka</code>不可以改，改了微服务未能完成注册（已测试）</p></blockquote><h1 id="4-Ribbon"><a href="#4-Ribbon" class="headerlink" title="4. Ribbon"></a>4. Ribbon</h1><p> Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。其主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p><p>官网：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">Netflix&#x2F;ribbon Wiki</a></p><h3 id="LB-负载均衡"><a href="#LB-负载均衡" class="headerlink" title="LB(负载均衡)"></a>LB(负载均衡)</h3><h4 id="集中式LB"><a href="#集中式LB" class="headerlink" title="集中式LB"></a>集中式LB</h4><p>集中式LB即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</p><h4 id="进程式LB"><a href="#进程式LB" class="headerlink" title="进程式LB"></a>进程式LB</h4><p>进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>修改消费者工程，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Ribbon相关 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>追加eureka的服务注册地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:7001/eureka/,http://eureka2:7002/eureka/,http://eureka3:7003/eureka/</span></span><br></pre></td></tr></table></figure><p>在主启动类上添加<code>@EnableEurekaClient</code>注解，在获取<code>RestTemplate</code>时添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@LoadBalanced</code>一个注解就实现了负载均衡的效果，默认使用负载均衡的策略。</p></blockquote><p>修改controller中获取url的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REST_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;http://MICROSERVICECLOUD-DEPT&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号</p></blockquote><p>此时依次启动注册中心、服务端和客户端，测试：<a href="http://localhost/consumer/dept/get/1">http://localhost/consumer/dept/get/1</a></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>创建服务8002，8003以及对应的数据库，修改对应的配置文件。</p><p>注意：三个服务对外暴露的服务实例名要统一</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microservicecloud-dept</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105811.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105811.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f873ea92f4745a0e96c192ba5fbc7cdc.png"></p><h4 id="核心组件IRule"><a href="#核心组件IRule" class="headerlink" title="核心组件IRule"></a>核心组件IRule</h4><p>IRule：负载均衡策略的接口；其实现类有：</p><ol><li><code>RoundRobinRole</code>：轮询，默认策略</li><li><code>RandomRule</code>：随机</li><li><code>AvailabilityFilterRule</code>：会先过滤掉由于多次访问而处于短路还有并发的连接数量超过阈值的服务，</li><li><code>WeightedResponseTimeRule</code>：根据平均响应时间计算所有服务的</li><li><code>RetryRule</code>：先按照轮询策略获取服务，如果获取服务失败多次</li><li><code>BestAvailableRule</code>：会先过滤掉由于多次访问故障而处于断路器跳</li><li><code>ZoneAvoidanceRule</code>：默认规则，复合判断server所在区域的性能</li></ol><p>关系图：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105819.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105819.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3b43d428fdf2b876cddda994a8cae21b.png"></p><h3 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h3><p>在消费端的主启动类上添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RibbonClient(name=&quot;微服务名&quot;,configuration=自定义规则类.class)</span></span><br><span class="line"><span class="meta">@RibbonClient(name=&quot;MICROSERVICECLOUD-DEPT&quot;,configuration=MyRule.class)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：官方文档明确给出了警告，我们创建的自定义策略类不能放在<code>@ComponentScan</code>所扫描的当前包以及子包下，否则此配置类会被所有的Ribbon客户端共享，也就是达不到特殊化定制的目的。</p><blockquote><p>不能放在主启动类所在的包以及子包下。</p></blockquote><p>新建自定义策略类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRule</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();<span class="comment">//自定义为随机策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定制策略"><a href="#定制策略" class="headerlink" title="定制策略"></a>定制策略</h3><p>我们可以参照<code>RandomRule</code>的源码进行定制化策略。只需要在return处返回定制的策略即可。</p><h1 id="5-Feign"><a href="#5-Feign" class="headerlink" title="5. Feign"></a>5. Feign</h1><p>官网：<a href="https://github.com/OpenFeign/feign">OpenFeign&#x2F;feign</a></p><p>Feign是一个声明式WebService客户端，能让编写Web Service客户端更加简单。Feign支持JAX-RS标准的注解，也支持可拔插式的编码器和解码器。</p><p>Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p><p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。</p><p>在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量，优雅而简单的实现了服务调用</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>参照消费者创建包：<code>microservicecloud-consumer-dept-feign</code></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建service接口，添加<code>@FeignClient</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUD-DEPT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptClientService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/add&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Dept dept)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类添加<code>@EnableFeignClients</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages= &#123;&quot;com.atguigu.springcloud&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>修改Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController_Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptClientService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.add(dept);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign整合了Ribbon，在不做任何额外配置的情况下，Feign默认使用轮询的负载均衡策略。若想要进行修改，可使用<code>@RibbonClient</code>进行设置。</p><h1 id="6-Hystrix断路器"><a href="#6-Hystrix断路器" class="headerlink" title="6. Hystrix断路器"></a>6. Hystrix断路器</h1><p>问题：</p><p>服务雪崩：多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，导致整个系统发生更多的级联故障，进而引起系统崩溃</p><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，称为断路器。它能够保证在一个依赖出问题的情况下，避免级联故障，以提高分布式系统的弹性。 </p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。   </p><p>作用：</p><ul><li>服务降级</li><li>服务熔断</li><li>服务限流</li><li>接近实时的监控</li></ul><p>官网资料：<a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">Netflix&#x2F;Hystrix Wiki</a></p><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>服务熔断熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。</p><p>在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>参考8001新建：<code>microservicecloud-provider-dept-hystrix-8001</code></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  hystrix --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">microservicecloud-dept8001-hystrix</span>  <span class="comment">#自定义服务名称信息</span></span><br></pre></td></tr></table></figure><p>主启动类添加<code>@EnableCircuitBreaker</code>注解。</p><p>修改controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;processHystrix_Get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="built_in">this</span>.service.get(id);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == dept) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该ID：&quot;</span> + id + <span class="string">&quot;没有没有对应的信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">processHystrix_Get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dept</span>().setDeptno(id).setDname(<span class="string">&quot;该ID：&quot;</span> + id + <span class="string">&quot;没有没有对应的信息,null--@HystrixCommand&quot;</span>).setDb_source(<span class="string">&quot;no this database in MySQL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>@HystrixCommand(fallbackMethod = &quot;processHystrix_Get&quot;)</code>注解表示开启服务熔断。</p><p><code>processHystrix_Get</code>方法是消费降级的逻辑。</p></blockquote><p>一旦调用服务方法失败并抛出了错误信息后，会自动调用<code>@HystrixCommand</code>标注好的<code>fallbackMethod</code>调用类中的指定方法。</p><p>测试：<a href="http://localhost/consumer/dept/get/112">http://localhost/consumer/dept/get/112</a></p><h2 id="消费降级"><a href="#消费降级" class="headerlink" title="消费降级"></a>消费降级</h2><p>整体资源快不够了，忍痛将某些服务先关掉，待渡过难关再开启回来。</p><p>服务降级处理应该在客户端实现完成的，与服务端解耦。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>上面的写法将Hystrix与生产者高度耦合，当生产者被关闭，系统不会返回”错误”的响应信息。将两者解耦后，可以让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p><p>在<code>microservicecloud-api</code>中根据DeptClientService<code>接口新建一个实现了</code>FallbackFactory<code>接口的类</code>DeptClientServiceFallbackFactory&#96;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;DeptClientService&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DeptClientService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeptClientService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dept</span>().setDeptno(id)</span><br><span class="line">                    .setDname(<span class="string">&quot;该ID：&quot;</span> + id + <span class="string">&quot;没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭&quot;</span>)</span><br><span class="line">                    .setDb_source(<span class="string">&quot;no this database in MySQL&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码为 Feign 客户端生成降级的实现,当 Feign 客户端在调用服务提供者失败时，<code>FallbackFactory</code> 的 <code>create</code> 方法会被调用，返回一个实现了服务接口（<code>DeptClientService</code>）的降级实例。</p></blockquote><p>在<code>microservicecloud-api</code>中<code>DeptClientService</code>接口的注解<code>@FeignClient</code>中添加<code>fallbackFactory</code>属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUD-DEPT&quot;,fallbackFactory= DeptClientServiceFallbackFactory.class)</span></span><br></pre></td></tr></table></figure><p>修改消费端的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>分别测试服务端开启和关闭的情况：<a href="http://localhost/consumer/dept/get/1">http://localhost/consumer/dept/get/1</a></p><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。</p><p>Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>参照消费者创建工程<code>microservicecloud-consumer-hystrix-dashboard</code>，新增依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hystrix和 hystrix-dashboard相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure><p>创建主启动类，添加<code>@EnableHystrixDashboard</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptConsumer_DashBoard_App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DeptConsumer_DashBoard_App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要监控的Provider微服务提供者中添加监控依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- actuator监控信息完善 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：<a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></p><p>启动eureka集群和微服务提供者，查看生产者的状况：<a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a></p><h4 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h4><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105831.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105831.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5c1d374735a03f8ee00ec652b2b83cb2.png"></p><ul><li>Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置该属性来降低客户端的网络和CPU消耗。</li><li>Title：该参数对应了头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题。</li></ul><p>示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105836.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105836.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5a777d47a0db20bdd3ef6732795cc789.png"></p><p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例。 </p><p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。</p><h1 id="7-zuul路由网关"><a href="#7-zuul路由网关" class="headerlink" title="7. zuul路由网关"></a>7. zuul路由网关</h1><p>Zuul包含了对请求的路由和过滤两个最主要的功能。</p><p>路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。</p><p>Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。</p><p>注意：Zuul服务最终还是会注册进Eureka 提供代理+路由+过滤三大功能</p><p>官网：<a href="https://github.com/Netflix/zuul/wiki/Getting-Started">Netflix&#x2F;zuul Wiki</a></p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>参照消费者创建工程<code>microservicecloud-zuul-gateway-9527</code>，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建主启动类并添加<code>@EnableZuulProxy</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zuul_9527_StartSpringCloudApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Zuul_9527_StartSpringCloudApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microservicecloud-zuul-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:7001/eureka/,http://eureka2:7002/eureka/,http://eureka3:7003/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">atguigu-microservicecloud</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">www.atguigu.com</span></span><br><span class="line">  <span class="attr">build.artifactId:</span> <span class="string">$&#123;project.artifactId&#125;</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">$&#123;project.version&#125;</span></span><br></pre></td></tr></table></figure><p>启动eureka集群、服务提供者以及路由，测试：</p><ul><li>启用路由：<a href="http://localhost:9527/microservicecloud-dept/dept/get/2">http://localhost:9527/microservicecloud-dept/dept/get/2</a></li><li>原路径访问：<a href="http://localhost:8001/dept/get/2">http://localhost:8001/dept/get/2</a></li></ul><ol><li><strong>设置代理名称</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">microservicecloud-dept</span> <span class="comment">#可以使用 “*”</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">mydept.serviceId:</span> <span class="string">microservicecloud-dept</span></span><br><span class="line">    <span class="attr">mydept.path:</span> <span class="string">/mydept/**</span></span><br></pre></td></tr></table></figure><p>测试：<a href="http://localhost:9527/mydept/dept/get/2">http://localhost:9527/mydept/dept/get/2</a></p><blockquote><p><code>ignored-services</code>设置忽略原真实服务名，即此时<a href="http://localhost:9527/microservicecloud-dept/dept/get/2%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E3%80%82">http://localhost:9527/microservicecloud-dept/dept/get/2无法访问。</a></p></blockquote><ol start="2"><li><strong>设置统一公共前缀</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/test</span></span><br></pre></td></tr></table></figure><p>此时的访问路径为：<a href="http://localhost:9527/test/mydept/dept/get/2">http://localhost:9527/test/mydept/dept/get/2</a></p><h2 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h2><p>在使用Zuul作为整个微服务系统的入口时，我们可以统一在Zuul中设置拦截器，实现整个系统的请求过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyZuulFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取当前 RequestContext 对象</span></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 2.获取当前请求对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> context.getRequest();</span><br><span class="line">        <span class="comment">// 3.获取当前请求要访问的目标地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        <span class="comment">// 4.打印</span></span><br><span class="line">        System.err.println(<span class="string">&quot;servletPath=&quot;</span>+servletPath);</span><br><span class="line">        <span class="comment">// 5.当前方法返回值</span></span><br><span class="line">        <span class="comment">// true：表示应该过滤，下面继续执行 run()方法</span></span><br><span class="line">        <span class="comment">// false：表示不过滤，直接放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="comment">// 执行具体过滤逻辑</span></span><br><span class="line">        System.err.println(<span class="string">&quot;run() ...&quot;</span>);</span><br><span class="line">        <span class="comment">// 官方文档说：当前实现会忽略这个返回值，所以返回 null 即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回当前过滤器类型</span></span><br><span class="line">        <span class="comment">// 可选类型包括：pre、route、post、static</span></span><br><span class="line">        <span class="comment">// 如果需要在目标微服务前面执行过滤操作，选用 pre 类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当需要实现登录验证时，可以在run方法中重定向到登录页面。</p></blockquote><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105843.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105843.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2c8a51b7fc520b09a9a69b166f330a0a.png"></p><p><strong>访问流程</strong>：</p><ol><li>请求通过 Zuul 网关进入微服务架构</li><li>Zuul 负责路由请求到相应的消费者服务</li><li>消费者服务使用 Ribbon 客户端负载均衡来选择一个可用的生产者服务实例</li><li>Ribbon 从 Eureka 服务注册中心获取生产者服务的地址</li><li>消费者服务使用 Hystrix 来包装对生产者服务的请求。Hystrix 会进行一些预处理，例如超时设置、熔断配置等。<ul><li>生产者服务正常运行：Hystrix 接收到来自生产者的结果，然后将结果返回给消费者服务</li><li>生产者服务出现故障：Hystrix 根据预先设置的熔断策略，决定是否进行服务熔断。如果熔断触发，Hystrix 将返回预先设置的结果（<strong>消费降级</strong>），而不是将请求传递给不可用的生产者服务。</li></ul></li></ol><p><strong>注意</strong>：服务熔断和消费降级不是必然同时出现的</p><p>在一些情况下，服务熔断已经提供了足够的系统稳定性保障，不需要再引入消费降级。例如，对于某些关键的支付服务或者涉及到金融交易的服务，当服务熔断发生时，直接返回错误，而不进行降级处理，以确保数据的一致性和安全性。</p><blockquote><p>消费降级是在服务熔断的基础上实现的</p></blockquote><p>简单理解：</p><ul><li>Hystrix 根据预先设定的策略，阻止请求继续传递给不可用的服务，从而防止雪崩效应。这个过程称为服务熔断</li><li>当服务熔断发生时，Hystrix 返回预设的默认值、友好的错误提示或者提供一些基本的、受控的功能，这个过程称为消费降级</li></ul><h1 id="9-SrpingCloud-Config"><a href="#9-SrpingCloud-Config" class="headerlink" title="9. SrpingCloud Config"></a>9. SrpingCloud Config</h1><p>分布式配置中心<code>SrpingCloud Config</code>为微服务架构中的微服务提供集中化的外部配置支持。</p><p><code>SrpingCloud Config</code>分为服务端和客户端，服务端称为分布式配置中心，是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口。</p><p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，配置服务器默认采用git来存储配置信息，有助于对环境配置进行版本管理，并可以通过git客户端工具来方便的管理和访问配置内容。</p><p><code>SrpingCloud Config</code>作用：</p><ol><li>集中管理配置文件</li><li>动态化的配置更新，分环境部署，比如dev&#x2F;test&#x2F;prod</li><li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取自己的配置信息</li><li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li><li>将配置信息以REST接口的形式暴露</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105849.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231029105849.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="389e8c6e26e564519cb8eed8ea81bf74.png"></p><h2 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先需要在GitHub中创建配置文件的仓库，获取git地址；本地创建本地仓库并clone远程仓库；创建文件<code>application.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-test</span></span><br></pre></td></tr></table></figure><blockquote><p>注意文件需要以UTF-8的格式保存</p></blockquote><p>将文件推送到GitHub上。</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>创建模块：<code>microservicecloud-config-server</code></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microservicecloud-config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="comment">#这里填Github仓库地址</span></span><br></pre></td></tr></table></figure><p>创建主启动类并添加注解**<code>@EnableConfigServer</code>**</p><p>启动微服务，测试：<a href="http://localhost:3344/application-dev.yml">http://localhost:3344/application-dev.yml</a></p><p>五种访问规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure><blockquote><p>label表示分支名；当profile不存在时会返回公共配置</p></blockquote><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>本地仓库新建文件<code>microservicecloud-config-client.yml</code>并提交到远程仓库：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8201</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:7001/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8202</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>新建工程：<code>microservicecloud-config-client</code></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloud Config客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建配置文件：<code>bootstrap.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">microservicecloud-config-client</span> <span class="comment">#需要从GitHub上读取的资源名称，注意没有yml后缀名</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#本次访问的配置项</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#本服务启动后先去找客户端获取GitHub的服务地址</span></span><br></pre></td></tr></table></figure><blockquote><p>application.yml是用户级的资源配置项；bootstrap.yml是系统级的，<strong>优先级更高</strong></p></blockquote><p>Spring Cloud会创建一个<code>Bootstrap Context</code>，作为Spring应用<code>Application Context</code>的父上下文。初始化时<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p><p>Bootstrap属性有高优先级，默认情况下不会被本地配置覆盖，所以新增<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p><p>正常创建主启动类，不需要添加新注解。</p><p>创建Rest类，从GitHub上读取配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientRest</span>&#123;</span><br><span class="line">    <span class="meta">@value(&quot;$&#123;Spring.application.name&#125;&quot;)</span></span><br><span class="line">    privatet String applicationName;</span><br><span class="line">    <span class="meta">@value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)</span></span><br><span class="line">    privatet String eurekaServers;</span><br><span class="line">    <span class="meta">@value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    privatet String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationName+<span class="string">&quot;\t&quot;</span>+eurekaServers+<span class="string">&quot;\t&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先后启动配置中心客户端和服务端，测试：<a href="http://localhost:8201/config">http://localhost:8201/config</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud Netflix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/10/07/%E6%A1%86%E6%9E%B6/2.SpringMVC/"/>
      <url>/2023/10/07/%E6%A1%86%E6%9E%B6/2.SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringMVC简介"><a href="#1-SpringMVC简介" class="headerlink" title="1. SpringMVC简介"></a>1. SpringMVC简介</h1><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分（在JavaWeb.thymeleaf有详细介绍）</p><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目，是 Spring 为表述层开发提供的一整套完备的解决方案。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p></blockquote><p>SpringMVC的特点:</p><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h2 id="Hello，World！"><a href="#Hello，World！" class="headerlink" title="Hello，World！"></a>Hello，World！</h2><p>创建Maven工程，添加web模块，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>使用maven前：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223312.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223312.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e2fe9ab81cfb3a54d825cad681fca9a2.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/3892c4ae4a91293cf84658999df1c6f5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/3892c4ae4a91293cf84658999df1c6f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3892c4ae4a91293cf84658999df1c6f5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/1bd0a2f072740718b45a5363c780fb9d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/1bd0a2f072740718b45a5363c780fb9d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1bd0a2f072740718b45a5363c780fb9d.png"></p><p>使用maven：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223329.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223329.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="77978a834c586a226bcb3cc2fffb79c9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223332.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223332.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3e1a9e0687c0af59c7dc96e1deab4821.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d0ff6f43a3f8bcb313e4a59eee178290.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d0ff6f43a3f8bcb313e4a59eee178290.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d0ff6f43a3f8bcb313e4a59eee178290.png"></p><h4 id="默认配置方式"><a href="#默认配置方式" class="headerlink" title="默认配置方式"></a>默认配置方式</h4><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>jsp本质上就是一个servlet，不需要映射控制器方法</p></blockquote><h4 id="扩展配置方式（推荐）"><a href="#扩展配置方式（推荐）" class="headerlink" title="扩展配置方式（推荐）"></a>扩展配置方式（推荐）</h4><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>classpath：只会到你的class路径中查找找文件;</li><li>classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。</li></ul><p>&lt;url-pattern&gt;标签中使用&#x2F;和&#x2F;*的区别：</p><p>&#x2F;所匹配的请求可以是&#x2F;login或.html或.js或.css方式的请求路径，但是&#x2F;不能匹配.jsp请求路径的请求，因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面。</p><p>&#x2F;*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用&#x2F;*的写法</p><h3 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器，请求控制器中每一个处理请求的方法称为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Index</span> &#123;</span><br><span class="line">    <span class="comment">//实现对首页的访问</span></span><br><span class="line">    <span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line">    <span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line">    <span class="comment">// localhost:8080/demo1/</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过超链接跳转到指定页面</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建springMVC的配置文件"><a href="#创建springMVC的配置文件" class="headerlink" title="创建springMVC的配置文件"></a>创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;servlet&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>流程：</p><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p><h1 id="2-RequestMapping注解"><a href="#2-RequestMapping注解" class="headerlink" title="2. @RequestMapping注解"></a>2. @RequestMapping注解</h1><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会在映射关系中找对应的控制器方法来处理这个请求。</p><h2 id="注解的位置："><a href="#注解的位置：" class="headerlink" title="注解的位置："></a>注解的位置：</h2><ol><li>标识一个类：设置映射请求的请求路径的初始信息</li><li>标识一个方法：设置映射请求请求路径的具体信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"><span class="comment">//此时请求映射所映射的请求的请求路径为：/test/RequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/RequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">RequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h2><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><ul><li><p>注解的value属性通过请求的请求地址匹配请求映射</p></li><li><p>注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p></li><li><p>注解的value属性必须设置</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/RequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">RequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不能存在注解参数相同的控制器方法（可以存在方法重载），即一个地址不能有两个控制器方法，服务器会报错（不确定使用哪个控制器方法）</p></blockquote><h3 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h3><ul><li>注解的method属性通过请求的请求方式（get或post）匹配请求映射</li><li>注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</li><li>不指明method属性时所有请求方式都能接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">    method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405</p></blockquote><p>对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><ul><li>@GetMapping：处理get请求的映射</li><li>@PostMapping：处理post请求的映射</li><li>@PutMapping：处理put请求的映射</li><li>@DeleteMapping：处理delete请求的映射</li></ul><p>常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p><h3 id="params属性（了解）"><a href="#params属性（了解）" class="headerlink" title="params属性（了解）"></a>params属性（了解）</h3><ul><li><p>注解的params属性通过请求的请求参数匹配请求映射；</p></li><li><p>注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><ul><li>“param”：要求请求映射所匹配的请求必须携带param请求参数</li><li>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</li><li>“param&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数且param&#x3D;value</li><li>“param!&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数但是param!&#x3D;value</li></ul></li></ul><blockquote><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Index</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target运行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/target&quot;,method = RequestMethod.POST,params = &quot;password!=123456&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">targetPost</span><span class="params">(String user,String password)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user:&quot;</span>+user+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上数代码，当满足targetPost的注解条件时，会进入targetPost，不满足会进入target</p></blockquote><h3 id="headers属性（了解）"><a href="#headers属性（了解）" class="headerlink" title="headers属性（了解）"></a>headers属性（了解）</h3><ul><li><p>注解的headers属性通过请求的请求头信息匹配请求映射</p></li><li><p>注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><ul><li>四种表达式和 params 属性类似</li></ul></li></ul><blockquote><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误</p></blockquote><h2 id="ant风格路径"><a href="#ant风格路径" class="headerlink" title="ant风格路径"></a>ant风格路径</h2><p>SpringMVC支持ant风格的路径：</p><p>？：表示任意的单个字符</p><p>*：表示任意的一个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/t*st&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/**/test&quot;)</span></span><br></pre></td></tr></table></figure><p>在使用**时，只能使用&#x2F;**&#x2F;xxx的方式</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><strong>SpringMVC支持路径中的占位符</strong>（重点）</p><p>原始方式：&#x2F;deleteUser?id&#x3D;1</p><p>rest方式：&#x2F;deleteUser&#x2F;1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-SpringMVC获取请求参数"><a href="#3-SpringMVC获取请求参数" class="headerlink" title="3. SpringMVC获取请求参数"></a>3. SpringMVC获取请求参数</h1><p>通过ServletAPI获取：</p><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p><strong>value</strong>：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p><strong>defaultValue</strong>：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/RequestParam&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/RequestParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span>String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当 @RequestParam 注解中的”username”改为”name”，浏览器的访问会报400错误。</p></blockquote><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>将请求头信息和控制器方法的形参创建映射关系，注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>将cookie数据和控制器方法的形参创建映射关系，一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPOJO</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题（不需要考虑get请求），可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote><h1 id="4-域对象共享数据"><a href="#4-域对象共享数据" class="headerlink" title="4. 域对象共享数据"></a>4. 域对象共享数据</h1><h2 id="request域共享数据"><a href="#request域共享数据" class="headerlink" title="request域共享数据"></a>request域共享数据</h2><p>使用ServletAPI向request域对象共享数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ModelAndView"><a href="#使用ModelAndView" class="headerlink" title="使用ModelAndView"></a>使用ModelAndView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">mav</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;mav张三&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Model"><a href="#使用Model" class="headerlink" title="使用Model"></a>使用Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/model&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">model</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;model张三&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/map&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(Map&lt;String,Object&gt; map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;map张三&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ModelMap"><a href="#使用ModelMap" class="headerlink" title="使用ModelMap"></a>使用ModelMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/mmp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">mmp</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;mmp张三&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Model、ModelMap、Map的关系"><a href="#Model、ModelMap、Map的关系" class="headerlink" title="Model、ModelMap、Map的关系"></a>Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实都是 BindingAwareModelMap 实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">session</span><span class="params">(HttpSession hs)</span>&#123;</span><br><span class="line">    hs.setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/application&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">application</span><span class="params">(HttpSession hs)</span>&#123;</span><br><span class="line">    hs.getServletContext().setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-SpringMVC的视图"><a href="#5-SpringMVC的视图" class="headerlink" title="5. SpringMVC的视图"></a>5. SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖（JSTL标签库），转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过<strong>转发</strong>的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><p>SpringMVC中默认的转发视图是InternalResourceView（也是JSP页面使用的）</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/map&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于直接输入地址会被thymeleaf的视图解析器解析，所以当我们想要转发到另一个控制器方法时，需要使用到 forward:</p><p>总结：只能转发请求，不能转发具体的页面</p></blockquote><h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/map&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于重定向不能访问WEB-INF目录下的内容（不再赘述与转发的差别），所以一般重定向的也是请求，不是具体的页面</p></blockquote><h2 id="解惑："><a href="#解惑：" class="headerlink" title="解惑："></a>解惑：</h2><h3 id="redirect-重定向时是否需要加”-x2F-“斜杠"><a href="#redirect-重定向时是否需要加”-x2F-“斜杠" class="headerlink" title="redirect 重定向时是否需要加”&#x2F;“斜杠"></a>redirect 重定向时是否需要加”&#x2F;“斜杠</h3><p>目前发现由于在配置文件中设置了DispatcherServlet的拦截范围为&#x2F;，重定向html页面（webapp目录下）由于被拦截且找不到对应的控制器方法会报404</p><p>为了演示，这里使用jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testPath</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果 redirect之后没有添加斜杠，就会使用当前controller的相对路径</span><br><span class="line">访问的是：http://localhost:8080/demo1/user/index.jsp</span><br><span class="line">如果 redirect之后添加了斜杠，就会拼接项目的根路径 </span><br><span class="line">访问的是：http://localhost:8080/demo1/index.jsp</span><br></pre></td></tr></table></figure><h3 id="RequestMapping注解中的value是否加斜杠"><a href="#RequestMapping注解中的value是否加斜杠" class="headerlink" title="RequestMapping注解中的value是否加斜杠"></a>RequestMapping注解中的value是否加斜杠</h3><p>可加可不加，在springmvc底层会对其进行处理，如果没有斜杠会自动加上</p><h2 id="视图控制器view-controller"><a href="#视图控制器view-controller" class="headerlink" title="视图控制器view-controller"></a>视图控制器view-controller</h2><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--代替下面的控制方法</span></span><br><span class="line"><span class="comment">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="comment">public String index() &#123;</span></span><br><span class="line"><span class="comment">    return &quot;index&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> path：设置处理的请求地址</span></span><br><span class="line"><span class="comment"> view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置<strong>开启mvc注解驱动</strong>的标签：&lt;mvc:annotation-driven &#x2F;&gt;</p></blockquote><h1 id="6-RESTful"><a href="#6-RESTful" class="headerlink" title="6. RESTful"></a>6. RESTful</h1><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><p>资源：资源是一种看待服务器的方式，即将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。</p><p>资源的表述：资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><p>状态转移：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h2 id="RESTful的实现"><a href="#RESTful的实现" class="headerlink" title="RESTful的实现"></a>RESTful的实现</h2><p>HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>RESTful 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><p>示例：</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id&#x3D;1</td><td>user&#x2F;1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id&#x3D;1</td><td>user&#x2F;1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h2><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p>条件：</p><ul><li>当前请求的请求方式必须为post</li><li>当前请求必须传输请求参数_method</li></ul><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式。</p><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><blockquote><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p></li><li><pre><code class="java">String paramValue = request.getParameter(this.methodParam);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 示例：</span><br><span class="line"></span><br><span class="line">### 功能清单</span><br><span class="line"></span><br><span class="line">| 功能                | URL 地址    | 请求方式 |</span><br><span class="line">| ------------------- | ----------- | -------- |</span><br><span class="line">| 访问首页√           | /           | GET      |</span><br><span class="line">| 查询全部数据√       | /employee   | GET      |</span><br><span class="line">| 删除√               | /employee/2 | DELETE   |</span><br><span class="line">| 跳转到添加数据页面√ | /toAdd      | GET      |</span><br><span class="line">| 执行保存√           | /employee   | POST     |</span><br><span class="line">| 跳转到更新数据页面√ | /employee/2 | GET      |</span><br><span class="line">| 执行更新√           | /employee   | PUT      |</span><br><span class="line"></span><br><span class="line">### 处理静态页面访问</span><br><span class="line"></span><br><span class="line">为了html页面能够导入vue.js等静态页面，需要设置springMVC.xml</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;!--配置视图控制器--&gt;</span><br><span class="line">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;</span><br><span class="line">&lt;mvc:view-controller path=&quot;/add&quot; view-name=&quot;add&quot;/&gt;</span><br><span class="line">&lt;!--开放对静态资源的访问--&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler /&gt;</span><br><span class="line">&lt;!--开启mvc注解驱动--&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></blockquote><blockquote><p>执行顺序：先通过 DispatcherServlet 寻找控制器方法，不能找到后通过 DefaultServlet 寻找，找不到就报404</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;static/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;static/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> del = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">el</span>: <span class="string">&quot;#tab&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//event存储着（点击）事件的相关信息</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">delEmp</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> delForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;delForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">href</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//event.target表示事件发生的对象</span></span></span><br><span class="line"><span class="language-javascript">                        delForm.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="language-javascript">                        delForm.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//取消a标签的默认行为</span></span></span><br><span class="line"><span class="language-javascript">                        event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tab&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>option<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee:$&#123;list&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee/&#125;+$&#123;employee.id&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;delEmp&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 有两种方式在thymeleaf的url中添加参数 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue框架在使用时遇到个坑，如果 el 直接对应a标签（delete），绑定的点击方法无效，未找到原因。将el对应table标签，调用时才能生效，猜测：需要将el对应在父标签，其中的子标签才能使用绑定的方法。</p></blockquote><p>关于表单修改时的回显：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender:<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;employee.gender&#125;==&#x27;1&#x27;?&#x27;checked&#x27;:&#x27;false&#x27;&quot;</span>&gt;</span>male</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;employee.gender&#125;==&#x27;0&#x27;?&#x27;checked&#x27;:&#x27;false&#x27;&quot;</span>&gt;</span>female</span><br><span class="line">            <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制方法调用DAO中的方法，RESTful需要使用 @PathVariable 接受参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/employee/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    dao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-HttpMessageConverter"><a href="#7-HttpMessageConverter" class="headerlink" title="7. HttpMessageConverter"></a>7. HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/RequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/RequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@RequestBody()</span>String body)</span>&#123;</span><br><span class="line">    System.out.println(body);<span class="comment">//username=123&amp;password=123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里有一种更好的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/RequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@RequestBody()</span>Map(String,String)</span> map)&#123;</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/RequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(RequestEntity&lt;String&gt; entity)</span>&#123;</span><br><span class="line">    System.out.println(entity.getHeaders());</span><br><span class="line">    System.out.println(entity.getBody());<span class="comment">//username=123&amp;password=123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里是将字符串返回给页面显示，而不是返回success.html页面</p></blockquote><h3 id="SpringMVC处理-JSON"><a href="#SpringMVC处理-JSON" class="headerlink" title="SpringMVC处理 JSON"></a>SpringMVC处理 JSON</h3><p>导入jackson的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>该标签的三个使用场景：</p><ol><li>自动注册<strong>RequestMappingHandlerMapping与RequestMappingHandlerAdapter</strong>两个Bean,这是Spring MVC为@Controller分发请求所必需的，并且提供了数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持,@Valid支持读写XML的支持（JAXB）和读写JSON的支持（默认Jackson）等功能。</li><li>静态资源的访问</li><li>需要controller返回一个json对象</li></ol></blockquote><p>在处理器方法上使用@ResponseBody注解进行标识，将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;john&quot;</span>,<span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器显示：{“id”:1,”name”:”john”,”age”:23}</p><h3 id="SpringMVC处理-Ajax"><a href="#SpringMVC处理-Ajax" class="headerlink" title="SpringMVC处理 Ajax"></a>SpringMVC处理 Ajax</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;sp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/ResponseBody&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;ajax&quot;</span>&gt;</span>Ajax<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;static/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;static/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&quot;#sp&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">ajax</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">name</span>:<span class="string">&quot;john&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>:<span class="number">23</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(resp.<span class="property">data</span>));</span></span><br><span class="line"><span class="language-javascript">                    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span></span><br><span class="line"><span class="language-javascript">                    &#125;);</span></span><br><span class="line"><span class="language-javascript">                    event.<span class="title function_">preventDefault</span>();<span class="comment">//防止页面跳转，即阻止标签的默认行为</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test1</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;_&quot;</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;john&quot;</span>,<span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><h1 id="8-文件上传和下载"><a href="#8-文件上传和下载" class="headerlink" title="8. 文件上传和下载"></a>8. 文件上传和下载</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>使用ResponseEntity实现下载文件的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字，attachment表示以附件形式下载</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文件的下载基本上都是固定格式，能改的只有图片的名字</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype&#x3D;”multipart&#x2F;form-data”</p><blockquote><p>enctype：encodetype就是编码类型。multipart&#x2F;form-data是指表单数据由多部分构成，既有文本数据，又有文件等二进制数据。</p><p>默认情况下，enctype的值是application&#x2F;x-www-form-urlencoded，只能上传文本格式的文件；使用multipart&#x2F;form-data，表示以<strong>二进制</strong>的形式上传，可以上传多种类型的文件。</p><p>只有使用了multipart&#x2F;form-data，才能完整的传递文件数据。</p></blockquote><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在SpringMVC的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>SpringMVC内部不是使用类型注入，而是通过id注入，所以这里的id必须为multipartResolver</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hzName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了防止上传文件重名出现内容覆盖的问题，可以使用uuid</p><p><code>UUID uuid = UUID.randomUUID();</code></p></blockquote><h1 id="9-拦截器"><a href="#9-拦截器" class="headerlink" title="9. 拦截器"></a>9. 拦截器</h1><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor接口</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>ref是在 ioc 容器中查找对应id的对象，所以创建的拦截器需要@Component 注解</p></blockquote><p>HandlerInterceptor 接口中有三个默认方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><p>多个拦截器的执行顺序：</p><ul><li>每个拦截器的preHandle()都返回true</li></ul><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><ul><li>某个拦截器的preHandle()返回了false</li></ul><p>preHandle()返回false和它之前的拦截器的preHandle()会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><h3 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h3><p>过滤器和拦截器的区别：</p><ol><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223407.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223407.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="abdd466d05761ab6e9f1fee93b1052b6.png"></p><blockquote><p>拦截器在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端期间间进行后期处理。</p></blockquote><blockquote><p>拦截器是被包裹在过滤器之中的。</p></blockquote><h1 id="10-异常处理器"><a href="#10-异常处理器" class="headerlink" title="10. 异常处理器"></a>10. 异常处理器</h1><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于注解的异常处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="11-注解配置SpringMVC"><a href="#11-注解配置SpringMVC" class="headerlink" title="11. 注解配置SpringMVC"></a>11. 注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h2 id="创建初始化类，代替web-xml"><a href="#创建初始化类，代替web-xml" class="headerlink" title="创建初始化类，代替web.xml"></a>创建初始化类，代替web.xml</h2><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。</p><p>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，会用它来配置Servlet上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceResponseEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建配置类代替spring的配置文件"><a href="#创建配置类代替spring的配置文件" class="headerlink" title="创建配置类代替spring的配置文件"></a>创建配置类代替spring的配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建配置类代替SpringMVC的配置文件"><a href="#创建配置类代替SpringMVC的配置文件" class="headerlink" title="创建配置类代替SpringMVC的配置文件"></a>创建配置类代替SpringMVC的配置文件</h2><p>代替SpringMVC的配置文件需要实现以下功能：</p><p>1、扫描组件   2、视图解析器     3、view-controller    4、default-servlet-handler   5、开启mvc注解驱动    6、文件上传解析器   7、异常处理      8、拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">FirstInterceptor</span> <span class="variable">firstInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//设置异常映射</span></span><br><span class="line">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">        <span class="comment">//设置共享异常信息的键</span></span><br><span class="line">        exceptionResolver.setExceptionAttribute(<span class="string">&quot;ex&quot;</span>);</span><br><span class="line">        resolvers.add(exceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">            webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成视图解析器并为解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-SpringMVC执行流程"><a href="#12-SpringMVC执行流程" class="headerlink" title="12. SpringMVC执行流程"></a>12. SpringMVC执行流程</h1><p>SpringMVC的九大核心组件：</p><ol><li>MultipartResolver（文件处理器）</li></ol><p>对应的初始化方法是initMultipartResolver(context)，用于处理上传请求，将普通的request包装成MultipartHttpServletRequest</p><ol start="2"><li>LocaleResolver（当前环境处理器）</li></ol><p>对应的初始化方法是initLocaleResolver(context)，从request中解析出Locale。主要有两个地方用到Locale：ViewResolver视图解析时；用到国际化资源或主题时。</p><ol start="3"><li>ThemeResolver（主题处理器）</li></ol><p>对应的初始化方法是initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。SpringMVC的主题也支持国际化。</p><ol start="4"><li>HandlerMapping（处理器映射器）</li></ol><p>对应的初始化方法是initHandlerMappings(context)，根据request找到相应的处理器。</p><ol start="5"><li>HandlerAdapter（处理器适配器）</li></ol><p>对应的初始化方法是initHandlerAdapters(context)，调用对应的控制器方法。</p><ol start="6"><li>HandlerExceptionResolver（异常处理器）</li></ol><p>对应的初始化方法是initHandlerExceptionResolvers(context)，根据异常设置ModelAndView，交给渲染方法进行渲染</p><ol start="7"><li>RequestToViewNameTranslator（视图名称翻译器）</li></ol><p>对应的初始化方法是initRequestToViewNameTranslator(context)，当Handler处理完后并没有设置View也没有设置ViewName，就需要从request获取ViewName</p><ol start="8"><li>ViewResolver（页面渲染处理器）</li></ol><p>对应的初始化方法是initViewResolvers(context)，用来将String类型的视图名和Locale解析为View类型的视图。</p><ol start="9"><li>FlashMapManager（参数传递管理器）</li></ol><p>对应的初始化方法是initFlashMapManager(context)，用来管理FlashMap。FlashMap主要用在redirect重定向中传递参数。</p><blockquote><p>springmvc的九大组件，不包括DispatcherServlet，DispatcherServlet就是一个前端控制器，负责转发，衔接的工作，不负责具体的处理逻辑，所以不归入到springmvc九大组件也是合理的</p></blockquote><h2 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h2><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223411.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1af4a9aa05ed6c2c6f0c9af8ecee1e74.png"></p><h3 id="初始化WebApplicationContext"><a href="#初始化WebApplicationContext" class="headerlink" title="初始化WebApplicationContext"></a>初始化WebApplicationContext</h3><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建WebApplicationContext"><a href="#创建WebApplicationContext" class="headerlink" title="创建WebApplicationContext"></a>创建WebApplicationContext</h3><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SpringMVC可以理解为一个继承自spring容器的子容器，spring容器是最顶层的父类容器，跟java的继承原理一样，子容器能使用父类的对象，但是父容器不能使用子类的对象。</p></blockquote><h3 id="DispatcherServlet初始化策略"><a href="#DispatcherServlet初始化策略" class="headerlink" title="DispatcherServlet初始化策略"></a>DispatcherServlet初始化策略</h3><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet调用组件处理请求"><a href="#DispatcherServlet调用组件处理请求" class="headerlink" title="DispatcherServlet调用组件处理请求"></a>DispatcherServlet调用组件处理请求</h2><h3 id="processRequest"><a href="#processRequest" class="headerlink" title="processRequest()"></a>processRequest()</h3><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doService"><a href="#doService" class="headerlink" title="doService()"></a>doService()</h3><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch()"></a>doDispatch()</h3><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult()"></a>processDispatchResult()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><ol><li>SpringMVC 前端控制器 DispatcherServlet捕获到浏览器端发送的请求。</li><li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：<ul><li>不存在，判断是否配置了mvc:default-servlet-handler<ul><li>没有：客户端展示404错误</li><li>有：访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</li></ul></li></ul></li><li>根据 URI 调用HandlerMapping，获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回给 DispatcherServlet。</li><li>DispatcherServlet 根据获得的处理器执行链中的处理器，选择合适的HandlerAdapter。（处理器适配器有三种）</li><li>之后开始执行拦截器的preHandler(…)方法【正向】</li><li>提取Request中的模型数据，填充Handler参数，执行Handler，处理请求。在填充Handler入参的过程中，根据需求，Spring将做一些额外的工作：<ul><li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li><li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中（一般都使用 js 完成，所以没讲）</li></ul></li><li>Handler执行完成后，会向DispatcherServlet 返回一个ModelAndView对象。</li><li>开始执行拦截器的postHandle(…)方法【逆向】。</li><li>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，渲染视图。</li><li>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</li><li>将渲染结果返回给客户端。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/10/06/%E6%A1%86%E6%9E%B6/1.Spring5/"/>
      <url>/2023/10/06/%E6%A1%86%E6%9E%B6/1.Spring5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring5-框架概述"><a href="#1-Spring5-框架概述" class="headerlink" title="1. Spring5 框架概述"></a>1. Spring5 框架概述</h1><p>Spring 是轻量级的开源的 JavaEE 框架，也称 Spring Framework ；可以解决企业应用开发的复杂性。</p><p>Spring 两个核心部分：IOC 和 AOP</p><p>Spring 特点：（1）方便解耦，简化开发 （2）Aop 编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低 API 开发难度</p><p>Spring5 下载地址：<a href="https://repo.spring.io/ui/native/release/org/springframework/spring/">https://repo.spring.io/ui/native/release/org/springframework/spring/</a></p><p>内容介绍：① IOC容器 ② AOP ③ JdbcTemplate ④ 事务管理 ⑤ Spring5 新特性</p><p>导入Spring5相关jar包：commons-logging-1.1.1.jar ；spring-beans-5.3.23.jar ；spring-context-5.3.23.jar ；spring-core-5.3.23.jar ；spring-expression-5.3.23.jar；</p><h1 id="2-IOC-容器"><a href="#2-IOC-容器" class="headerlink" title="2. IOC 容器"></a>2. IOC 容器</h1><p>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 。</p><p>使用 IOC 目的：为了耦合度降低 </p><p>底层原理：xml解析、工厂模式、反射</p><blockquote><p>xml 配置文件中配置创建的对象，创建相关类的工厂类，在工厂类中解析xml文件，最后通过反射创建对象</p></blockquote><h2 id="IOC-容器实现"><a href="#IOC-容器实现" class="headerlink" title="IOC 容器实现"></a>IOC 容器实现</h2><p>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂；</p><p>Spring 提供 IOC 容器实现的两种方式（两个接口）：</p><ul><li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用</li></ul><blockquote><p>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</p></blockquote><ul><li>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</li></ul><blockquote><p>加载配置文件时候就会把在配置文件对象进行创建。</p><p>对于服务器而言，应该在服务器启动时就将对象创建</p></blockquote><p>ApplicationContext 的实现类：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222900.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222900.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5ed097ecb50adc20fc66b39f49a17a09.png"></p><blockquote><p>其中 FileSystemXmlApplicationContext 使用系统路径（带盘符）<br>ClassPathXmlApplicationContext 使用工程路径，默认是当前Module的 src 目录下</p></blockquote><h2 id="IOC操作-Bean-管理"><a href="#IOC操作-Bean-管理" class="headerlink" title="IOC操作 Bean 管理"></a>IOC操作 Bean 管理</h2><p>Bean 管理指的是两个操作：Spring 创建对象；Spring 注入属性。</p><p>Bean 管理操作有两种方式：1. 基于 xml 配置文件方式实现；2. 基于注解方式实现</p><h3 id="基于-xml-操作"><a href="#基于-xml-操作" class="headerlink" title="基于 xml 操作"></a>基于 xml 操作</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认使用空参构造器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 </li><li>在 bean 标签有很多属性，介绍常用的属性 <ul><li>id 属性：唯一标识 </li><li>class 属性：类全路径（包类路径）</li></ul></li><li>创建对象时候，默认也是执行无参数构造方法完成对象创建</li></ol><h4 id="注入属性"><a href="#注入属性" class="headerlink" title="注入属性"></a>注入属性</h4><p><strong>DI：依赖注入，就是注入属性</strong></p><p>方式一：使用对象的 set 方法注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 spring 配置文件配置对象创建，配置属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 property 完成属性注入</span></span><br><span class="line"><span class="comment"> name：类里面属性名称</span></span><br><span class="line"><span class="comment"> value：向属性注入的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;john&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用带参构造器进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;john&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>p 名称空间注入（了解）</p><p>使用 p 名称空间注入，可以简化基于 xml 配置方式</p><ol><li>在配置文件中添加 p 名称空间</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用 set 方法注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;john&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入特殊属性"><a href="#注入特殊属性" class="headerlink" title="注入特殊属性"></a>注入特殊属性</h4><ol><li>字面量</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null 值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--属性值包含特殊字符</span></span><br><span class="line"><span class="comment">例如：&lt;&gt;</span></span><br><span class="line"><span class="comment">1.进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment">2.把带特殊符号内容写到 CDATA</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注入属性 - 外部Bean</li></ol><p>（1）创建两个类 service 类和 dao 类 （2）在 service 调用 dao 里面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123; userDao.add(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 service 和 dao 对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入 userDao 对象</span></span><br><span class="line"><span class="comment">  name 属性：类里面属性名称</span></span><br><span class="line"><span class="comment">  ref 属性：创建 userDao 对象 bean 标签 id 值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注入属性 - 内部Bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;john&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Test.Animals&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;小黄&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;species&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>注入属性 - 级联赋值</li></ol><p>写法一（其实就是外部 Bean）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;john&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;animals&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;animals&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Animals&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;小黄&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;species&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写法二：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;john&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;animals&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pet.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pet.species&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;animals&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Animals&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;小黄&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;species&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这种方式必须在 Person 类中存在 getPet() 方法才能使用，级联赋值会覆盖外部 Bean 注入的属性</p></blockquote><h4 id="注入集合属性"><a href="#注入集合属性" class="headerlink" title="注入集合属性"></a><strong>注入集合属性</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] courses;</span><br><span class="line">    <span class="comment">//2 list 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//3 map 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line">    <span class="comment">//4 set 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Stu&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>javaSE<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据结构<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Map 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>JDBC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在集合里面设置对象类型值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个 course 对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提取集合注入部分：</strong></p><ol><li>在 Spring 配置文件中引入名称空间 util</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 util 标签完成 list 集合注入提取</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>Java从入门到精通<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据结构<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;books&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IOC容器实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里只展示最后一次测试，其它测试不再赘述</span></span><br><span class="line">ApplicationContext ac=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">System.out.println(book);</span><br></pre></td></tr></table></figure><h3 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><p>在 Spring 中，设置创建的 Bean 默认情况是单实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">System.out.println(book1 == book2);</span><br></pre></td></tr></table></figure><blockquote><p>在默认情况下，book1 和 book2 地址相同，即指向同一个实例，</p></blockquote><p>设置单实例或多实例：</p><ul><li>在 spring 配置文件的 bean 标签中，属性（scope）用于设置单实例还是多实例<ul><li>singleton，默认值，表示单实例对象</li><li>prototype，表示多实例对象</li></ul></li></ul><blockquote><p>设置 scope 值是 singleton ，加载 spring 配置文件时就会创建单实例对象；设置 scope 值是 prototype ，在调用 getBean 方法时才创建多实例对象</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置生成多实例对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;books&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p>生命周期：从对象创建到对象销毁的过程</p><ol><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>使用 bean（对象获取到了）</li><li>当容器关闭时，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置初始化方法和销毁方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Book&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加 Bean 的后置处理器后，Bean 的生命周期有七步：</p><ol><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization  </li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization </li><li>使用 bean（对象获取到了）</li><li>当容器关闭时，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol><h4 id="添加后置处理器"><a href="#添加后置处理器" class="headerlink" title="添加后置处理器"></a>添加后置处理器</h4><ol><li>创建类，实现接口 BeanPostProcessor，创建后置处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置后置处理器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--会给当前配置文件中的所有Bean都添加此后置处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xml自动装配"><a href="#xml自动装配" class="headerlink" title="xml自动装配"></a>xml自动装配</h3><p>根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p><p>bean 标签属性 autowire，配置自动装配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据属性名称自动注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;work&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Work&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根据属性类型自动注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;animal&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Animals&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>byName ：根据属性名称注入 ，注入值 bean 的 id 值必须与类的属性名称相同</p></blockquote><h3 id="外部属性文件导入"><a href="#外部属性文件导入" class="headerlink" title="外部属性文件导入"></a>外部属性文件导入</h3><p>直接配置数据库信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入外部属性文件配置数据库连接池：</p><p>需要引入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 spring 配置文件使用标签引入外部属性文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解操作"><a href="#基于注解操作" class="headerlink" title="基于注解操作"></a>基于注解操作</h3><p>注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值, 属性名称&#x3D;属性值..)；使用注解操作可以简化xml配置。</p><p>Spring 针对 Bean 管理中创建对象提供了四种注解：</p><ol><li><strong>@Component</strong> </li><li><strong>@Service</strong> ：一般用在业务层（Service层）</li><li><strong>@Controller</strong> ：一般用在表现层（Servlet层）</li><li><strong>@Repository</strong>：一般用在持久层（DAO层）</li></ol><blockquote><p>作用：把当前类对象存入Spring容器中<br>属性：value 用于指定bean的id，不写默认为首字母小写的当前类名<br>每种注解都可以随意使用，但spring框架为我们提供明确的三层使用的注解，能使我们的三层对象更加清晰</p></blockquote><h4 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h4><ol><li>引入依赖 spring-aop-5.3.23.jar</li><li>开启组件扫描</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果扫描多个包</span></span><br><span class="line"><span class="comment"> 1 多个包使用逗号隔开</span></span><br><span class="line"><span class="comment"> 2 扫描包上层目录</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;Test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建类，在类上面添加创建对象注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//&lt;bean id=&quot;userDaoImpl&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>开启组件扫描的细节配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 use-default-filters&#x3D;”false” 表示现在不使用默认 filter，自己配置 filter；context:include-filter ，表示设置扫描哪些内容</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>默认filter扫描四种注解，context:exclude-filter： 设置哪些内容不进行扫描</p></blockquote><h4 id="注入属性-1"><a href="#注入属性-1" class="headerlink" title="注入属性"></a>注入属性</h4><ol><li>@Autowired：先根据属性类型进行自动装配，没有再按名字寻找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用注解方式注入属性不需要 set 方法，注解内部都封装好了</p></blockquote><ol start="2"><li>@Qualifier：根据名称进行注入</li></ol><p>@Qualifier 需要和 @Autowired 一起使用，应对一个接口存在多个实现类的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;userDaoImpl1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Resource：先按照名字寻找，没有再按类型查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//@Resource</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//只根据名称进行注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方不建议用@Resource,因为它是 javax （Java拓展包）的内容</p><ol start="4"><li>@Value：注入普通类型属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h4 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h4><p>创建配置类，替代 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;Test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserService <span class="title function_">getUserService</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring 通过调用标记了@Bean 注解的方法将对象放入 IOC 容器，不会重复调用方法。原因是 Spring 想要获取 bean 对应的实例对象时会查看 IOC 容器中是否已经有了这个对象，如果有则不会执行这个方法，从而保证这个 bean 是单实例的。</p></blockquote><blockquote><p>可以配合@Scope 注解修改为多实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">us</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    us.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3. AOP"></a>3. AOP</h1><p>面向切面（方面）编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><blockquote><p>描述：不修改源代码的情况下，在主干功能里面添加新功能</p></blockquote><p>底层原理：使用动态代理，分为两种情况</p><ol><li>被代理类有接口，使用<strong>JDK动态代理</strong>（JavaSE.反射机制）</li></ol><p>创建接口实现类的代理对象，增强类的方法，具体见JavaSE中介绍</p><ol start="2"><li>被代理类没有接口，使用<strong>CGLIB动态代理</strong></li></ol><p> CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑。此外，因为 CGLIB 采用整型变量建立了方法索引，这比使用 JDK 动态代理更快。</p><p>区别：</p><ul><li>JDK 动态代理只能对接口进行代理，不能对普通的类进行代理，这是因为 JDK 动态代理生成的代理类，其父类是 <code>Proxy</code>，且 Java 不支持类的多继承。</li><li>CGLIB 能够代理接口和普通的类，但是被代理的类不能被 <code>final</code> 修饰，且接口中的方法不能使用 <code>final</code> 修饰。</li><li>JDK 动态代理使用 Java 反射技术进行操作，在生成类上更高效。</li><li>CGLIB 使用 ASM 框架直接对字节码进行修改，使用了 <code>FastClass</code> 的特性。在某些情况下，类的方法执行会比较高效。</li></ul><p>AOP术语：</p><ol><li>连接点：类中可以被增强的方法都称为连接点</li><li>切入点：真正被增强的方法称为切入点</li><li>通知（增强）：实际增强的逻辑部分称为通知（增强）<ul><li>通知有多种类型：前置通知、后置通知、环绕通知、异常通知、最终通知</li></ul></li><li>切面：把通知应用到切入点的动作称为切面</li></ol><h2 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h2><p>Spring 框架一般都是基于 AspectJ 实现AOP操作；AspectJ 不是Spring组成部分，是独立的AOP框架，一般把 AspectJ 和 Spring 框架一起使用。</p><p>引入AOP相关依赖：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222905.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222905.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2320be21c3933191699f5467ac7051c2.png"></p><p>切入点表达式：</p><p>作用：指明对哪个类里面的哪个方法进行增强</p><p>语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举例 1：对 dao.BookDao 类里面的 add 进行增强</span><br><span class="line">execution(* dao.BookDao.add(..))</span><br><span class="line">举例 2：对 dao.BookDao 类里面的所有的方法进行增强</span><br><span class="line">execution(* dao.BookDao.* (..))</span><br><span class="line">举例 3：对 dao 包里面所有类，类里面所有方法进行增强</span><br><span class="line">execution(* dao.*.* (..))</span><br></pre></td></tr></table></figure><blockquote><p>其中开头的 * 表示任意权限修饰符；返回类型可以省略，以空格代替</p></blockquote><h3 id="AspectJ-配置文件"><a href="#AspectJ-配置文件" class="headerlink" title="AspectJ 配置文件"></a>AspectJ 配置文件</h3><p>注入名称空间 aop</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Spring配置文件中创建增强类和被增强类的对象，并在配置文件中配置切入点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Test.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* Test.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置通知类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeBuy&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="AspectJ-注解"><a href="#AspectJ-注解" class="headerlink" title="AspectJ 注解"></a>AspectJ 注解</h3><ol><li>在Spring配置文件中开启注解扫描（需要注入context 和 aop两个名称空间）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;Test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用注解创建增强类和被增强类的对象</li><li>增强类添加 <strong>@Aspect</strong> 注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;<span class="comment">//被增强类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookProxy</span> &#123;<span class="comment">//增强类</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在 spring 配置文件中开启生成代理对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在增强类中作为通知方法的上面使用切入点表达式配置通知类型注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;execution(* Test.Book.buy(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeBuy</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;beforeBuy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@Before</strong>：表示作为前置通知</li><li><strong>@AfterReturning</strong>：表示后置通知（返回通知）</li><li><strong>@After</strong>：表示最终通知，无论是否出现异常都会被执行</li><li><strong>@AfterThrowing</strong>：表示异常通知，当程序发生异常才会执行</li><li><strong>@Around</strong>：表示环绕通知</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(value = &quot;execution(* Test.Book.buy(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundBuy</span><span class="params">(ProceedingJoinPoint pj)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line">    <span class="comment">//被增强的方法执行，此方法携带异常</span></span><br><span class="line">    pj.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>环绕通知的执行包含前置通知和后置通知，即分别在前置通知之前和后置通知之后执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ApplicationContext ac= <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    book.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相同切入点抽取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* Test.Book.buy(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(value = &quot;demo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeBuy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;beforeBuy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置增强类的优先级</strong></p><p>多个增强类对同一个方法进行增强时可以设置执行顺序。</p><p>在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高（最小为0）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookProxy</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>完全注解开发</strong></p><p>创建配置类，不需要创建 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;Test&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中 proxyTargetClass 用于切换jdk代理和cglib代理；默认为false，有接口实现的是jdk的动态代理，没有接口的是cglib代理，设置为true生成的都是cglib的代理，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigAop.class);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    book.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-JdbcTemplate"><a href="#4-JdbcTemplate" class="headerlink" title="4. JdbcTemplate"></a>4. JdbcTemplate</h1><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><p>引入依赖：spring-jdbc-5.3.23.jar ；spring-orm-5.3.23.jar ；spring-tx-5.3.23.jar</p><ol><li>在Spring文件中配置数据库连接池</li></ol><blockquote><p>在Spring中，数据库配置文件使用 username 命名，程序运行后，windows的用户名会覆盖数据库的用户名，会造成数据库连接错误</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jdbc配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对指定文件目录开启注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;aTest,Test3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 JdbcTemplate 对象，注入 DataSource</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入 dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 dao 注入 jdbcTemplate 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在service注入dao对象</li><li>调用 JdbcTemplate 对象中的方法实现功能</li></ol><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li><strong>update(String sql, Object…args)</strong></li></ul><p>该方法可以实现增删改功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;update book set name=?,price=? where id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jt.update(sql, book.getName(), book.getPrice(),book.getId());</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>queryForObject(String sql, Class&lt;T&gt; requiredType)</strong></li></ul><p>第二个参数：返回类型 Class</p><p>该方法可以实现例如查询记录数等功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countAll</span><span class="params">()</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;select count(*) from book&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jt.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object…args)</strong></li></ul><p>第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装</p><p>该方法可以实现单个JavaBean对象的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;select * from book where id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jt.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Book.class), id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>query(String sql, RowMapper&lt;T&gt; roMapper, Object…args)</strong></li></ul><p>该方法可以实现分页查询等功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;select * from book&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jt.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Book.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><ul><li>batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</li></ul><p>第二个参数：List 集合，添加多条记录数据</p><p>该方法可以实现批量添加、删除、修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdate</span><span class="params">(List&lt;Object[]&gt; args)</span> &#123;</span><br><span class="line">    String sql=<span class="string">&quot;update book set name=?,price=? where id=?&quot;</span>;</span><br><span class="line">    jt.batchUpdate(sql, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法返回一个 int[] ，但是返回值有特定含义，例如 -2 表示操作成功但不能计数</p></blockquote><h1 id="5-事务操作"><a href="#5-事务操作" class="headerlink" title="5. 事务操作"></a>5. 事务操作</h1><p>事务是数据库操作最基本单元。（在JDBC.概述有详细介绍）</p><p>事务的四个特性（ACID）：原子性；一致性；隔离性；持久性。</p><p>经典例子：转账</p><h2 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h2><p>事务一般在Service层（业务逻辑层）添加。</p><p>在Spring进行事务管理有两种方式：编程式事务管理和声明式事务管理</p><p>编程式事务管理即以往学习的五个步骤：1. 开启事务（关闭自动提交）2. 进行业务操作 3. 没有异常，提交事务；出现异常，回滚事务</p><h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><h4 id="基于xml-配置文件"><a href="#基于xml-配置文件" class="headerlink" title="基于xml 配置文件"></a>基于xml 配置文件</h4><ol><li>配置事务管理器</li><li>配置通知</li><li>配置切入点和切面</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 配置通知，若事务管理器名不为transactionManager，此处还需引用transaction-manger=&quot;&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--若是查询方法，可以设置只读属性read-only=&quot;true&quot;，数据库会进行优化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3 配置切入点和切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* Test.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="事务管理参数配置"><a href="#事务管理参数配置" class="headerlink" title="事务管理参数配置"></a>事务管理参数配置</h4><ol><li>propagation：设置事务传播行为</li></ol><p>当一个事务方法被其它事务方法调用时，这个事务方法如何进行</p><p>事务的传播行为可以由传播属性指定。Spring定义了7种传播行为。</p><table><thead><tr><th align="center">传播属性</th><th>描述</th></tr></thead><tbody><tr><td align="center"><strong>REQUIRED</strong></td><td>如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行</td></tr><tr><td align="center"><strong>REQUIRED_NEW</strong></td><td>当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起</td></tr><tr><td align="center">SUPPORTS</td><td>如果有事务在运行，当前的方法就在这个事务内运行，否额它可以不运行在事务中</td></tr><tr><td align="center">NOT_SUPPORTED</td><td>当前的方法不应该运行在事务中，如果有运行的事务，将他挂起</td></tr><tr><td align="center">MANDATORY</td><td>当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常</td></tr><tr><td align="center">NEVER</td><td>当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常</td></tr><tr><td align="center">NESTED</td><td>如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行</td></tr></tbody></table><blockquote><p>REQUIRED：在事务A中调用方法B，方法B会加入到事务A中，合并成一个事务，互相影响（事务A或方法B若出现异常，全部回滚）</p></blockquote><blockquote><p>REQUIRED_NEW：在事务A中调用方法B，方法B会开启内层事务B，互不影响（两个事务谁出异常谁回滚，正常运行的会提交）</p></blockquote><ol start="2"><li>ioslation：设值事务隔离级别</li></ol><p>三个读问题：脏读、不可重复读、虚（幻）读。（在JDBC.概述有详细介绍）</p><p>Spring可以设置四种隔离级别：</p><table><thead><tr><th></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（读未提交数据）</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr><tr><td>READ COMMITTED（读已提交数据）</td><td align="center">无</td><td align="center">有</td><td align="center">有</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td align="center">无</td><td align="center">无</td><td align="center">有</td></tr><tr><td>SERIALIZABLE（串行化）</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr></tbody></table><ol start="3"><li>timeout：超时时间</li></ol><p>事务需要在一定时间内进行提交，如果不提交进行回滚。</p><p>默认值是 -1 ，即无超时时间。设置时间以秒单位进行计算</p><ol start="4"><li>readOnly：是否只读</li></ol><p>读：查询操作，写：添加修改删除操作 </p><p>readOnly 默认值 false，表示可以增删改查操作，设置成 true 之后，只能查询</p><ol start="5"><li>rollbackFor：回滚</li></ol><p>设置出现哪些异常进行事务回滚。默认运行时异常回滚，建议有异常都回滚</p><ol start="6"><li>noRollbackFor：不回滚</li></ol><p>设置出现哪些异常不进行事务回滚</p><h4 id="基于注解方式"><a href="#基于注解方式" class="headerlink" title="基于注解方式"></a>基于注解方式</h4><ol><li>在Spring配置文件配置事务管理器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Spring配置文件引入名称空间并中开启事务注解</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 service 类上面（或者 service 类的方法上面）添加事务注解</li></ol><ul><li><strong>@Transactional</strong></li></ul><p>如果添加在类上面，这个类里面所有的方法都添加事务；添加方法上面，为这个方法添加事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改单价</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>&#123;</span><br><span class="line">    bd.decline();</span><br><span class="line">    <span class="type">int</span> i=<span class="number">12</span>/<span class="number">0</span>;</span><br><span class="line">    bd.increase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全注解声明式"><a href="#完全注解声明式" class="headerlink" title="完全注解声明式"></a>完全注解声明式</h4><p>创建配置类，使用配置类替代 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;Test3&quot;)</span>  <span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        ps.load(is);</span><br><span class="line">        dataSource.setDriverClassName(ps.getProperty(<span class="string">&quot;driverClassName&quot;</span>));</span><br><span class="line">        dataSource.setUrl(ps.getProperty(<span class="string">&quot;url&quot;</span>));</span><br><span class="line">        dataSource.setUsername(ps.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        dataSource.setPassword(ps.getProperty(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        dataSource.setInitialSize(<span class="number">5</span>);</span><br><span class="line">        dataSource.setMaxActive(<span class="number">10</span>);</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 JdbcTemplate 对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">//到 ioc 容器中根据类型找到 dataSource</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//注入 dataSource</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager</span><br><span class="line">    <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ApplicationContext ac=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">    <span class="type">BookService</span> <span class="variable">bs</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line">    bs.change();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同一个测试方法中不能既使用配置文件，又使用全注解，比如配置文件中创建了 JdbcTemplate 的Bean对象，又在配置类中创建了，注入时会报错（不能分辨注入哪一个）</p></blockquote><h1 id="6-Spring5框架新功能"><a href="#6-Spring5框架新功能" class="headerlink" title="6. Spring5框架新功能"></a>6. Spring5框架新功能</h1><p>Spring5 框架的代码基于 Java8，运行时兼容 JDK9，删除了许多不建议使用的类和方法</p><h2 id="日志封装"><a href="#日志封装" class="headerlink" title="日志封装"></a>日志封装</h2><p>Spring 5.0 框架自带了通用的日志封装。移除了 Log4jConfigListener，官方建议使用 Log4j2</p><p>引入jar包：log4j-api-2.11.2.jar ；log4j-core-2.11.2.jar ；log4j-slf4j-impl-2.11.2.jar ；slf4j-api-1.7.30.jar ；</p><p>创建 log4j2.xml 配置文件（名字固定）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的 appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Nullable-注解"><a href="#Nullable-注解" class="headerlink" title="@Nullable 注解"></a>@Nullable 注解</h2><p>Spring5 框架核心容器支持@Nullable 注解；可以使用在方法、属性或参数上面</p><ol><li>注解用在方法上面，表示方法返回值可以为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>注解使用在方法参数里面，表示方法参数可以为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="meta">@Nullable</span> String name,<span class="type">int</span> id)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注解使用在属性上面，表示属性值可以为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h2 id="函数式风格"><a href="#函数式风格" class="headerlink" title="函数式风格"></a>函数式风格</h2><p>Spring5 核心容器支持函数式风格 GenericApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给 spring 进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1 创建 GenericApplicationContext 对象</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">//2 调用 context 的方法对象注册</span></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="comment">//这里的参数含有供给型接口 Supplier，这里使用了构造器引用</span></span><br><span class="line">    <span class="comment">//context.registerBean(Book.class);</span></span><br><span class="line">    context.registerBean(<span class="string">&quot;book1&quot;</span>,Book.class, Book::<span class="keyword">new</span>);</span><br><span class="line">    <span class="comment">//3 获取在 spring 注册的对象</span></span><br><span class="line">    <span class="comment">// Book book = (Book)context.getBean(&quot;Test3.Book&quot;);</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> (Book)context.getBean(<span class="string">&quot;book1&quot;</span>);</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>registerBean()方法中有三个参数，第一个是bean的别名，最后一个是Supplier接口，这两个参数都有@Nullable注解</p></blockquote><h2 id="测试整合"><a href="#测试整合" class="headerlink" title="测试整合"></a>测试整合</h2><p>整合 JUnit4，需要导入jar包</p><p>使用注解方式创建测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest4</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring5 支持整合 JUnit5，需要引入jar 包</p><p>使用注解创建测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以使用一个复合注解完成整合</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Webflux"><a href="#Webflux" class="headerlink" title="Webflux"></a>Webflux</h2><p>点击此处接着<a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=53&vd_source=43882264793a4ce5e4b13671c1025aa3">学习</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell</title>
      <link href="/2023/10/05/%E5%B7%A5%E5%85%B7/Shell/"/>
      <url>/2023/10/05/%E5%B7%A5%E5%85%B7/Shell/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Shell概述"><a href="#1-Shell概述" class="headerlink" title="1. Shell概述"></a>1. Shell概述</h1><p>Shell是一个命令行解释器，用于接受应用程序&#x2F;用户命令，然后调用操作系统内核；Shell还是一个功能相当强大的编程语言，易编写、调试且灵活性强。</p><p>Linux提供的Shell解析器有多种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><blockquote><p>sh 是 bash 的软连接；CentOS默认的解析器是 bash，可以通过 echo $SHELL 查看环境变量</p></blockquote><p>第一个Shell脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# touch hello.sh</span><br><span class="line">[root@hadoop100 ~]# cat hello.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;hello,world!&quot;</span><br></pre></td></tr></table></figure><blockquote><p>脚本一般以 #!&#x2F;bin&#x2F;bash 开头：指定解析器</p></blockquote><h2 id="脚本常用的执行方式："><a href="#脚本常用的执行方式：" class="headerlink" title="脚本常用的执行方式："></a>脚本常用的执行方式：</h2><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash/sh 脚本的相对路径或绝对路径</span><br></pre></td></tr></table></figure><blockquote><p>此方式不需要赋予脚本可执行权限（x）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223941.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006223941.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5797f1b702bddeffc0d7aaf2d6eb454c.png"></p><p>方式二：</p><p>采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限）</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224010.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="817249656491c03abfa67fd1a7994cc2.png"></p><blockquote><p>在目录使用相对路径时，不能直接输入名字，会当成命令执行</p></blockquote><p>方式三：</p><p>在脚本的路径前加上“.”或者 source</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./source 脚本路径</span><br></pre></td></tr></table></figure><p>前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则 子 shell 关闭，回到父 shell 中。在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前 shell 里执行，这也是为什么我们每次要修改完&#x2F;etc&#x2F;profile 文件以后，需要 source</p><blockquote><p>开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的当前变量，父 shell 是不可见的</p></blockquote><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><h2 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用系统变量：$HOME、$PWD、$SHELL、$USER 等</span><br><span class="line">[root@hadoop100 ~]# echo $变量名 #查看系统变量的值</span><br><span class="line">[root@hadoop100 ~]# env #查看所有的全局环境变量</span><br><span class="line">[root@hadoop100 ~]# printenv #查看所有的系统全局变量，和env差不多</span><br><span class="line">[root@hadoop100 ~]# printenv 变量名 #查看系统变量的值</span><br><span class="line">[root@hadoop100 ~]# set #查看当前 Shell 中所有变量</span><br></pre></td></tr></table></figure><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>定义变量：变量名&#x3D;变量值，注意，&#x3D;号前后不能有空格</p><p>撤销变量：unset 变量</p><p>声明静态变量（只读变量&#x2F;常量）：readonly 变量，注意：不能 unset</p><p>把变量提升为全局环境变量：export 变量</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224012.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="203040577d6e3e37bd1b3da62f1fbdaa.png"></p><blockquote><p>在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算；如 a&#x3D;1+2 是以字符串的形式存储</p><p>变量的值如果有空格，需要使用双引号或单引号括起来；</p></blockquote><p>变量定义规则：</p><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</li><li>等号两侧不能有空格</li></ol><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ol><li>$n</li></ol><p>$n （功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# ./hello.sh a</span><br><span class="line"></span><br><span class="line">cho &quot;hello,world!&quot;</span><br><span class="line">echo &#x27;====$n====&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224015.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3d438b234747dafbe75f4f92ea335728.png"></p><blockquote><p>单引号不解析内部内容；双引号会解析。没有输入的参数没有输出</p></blockquote><ol start="2"><li>$#</li></ol><p>$# （功能描述：获取所有输入参数个数，常用于循环,判断参数的个数是否正确以及加强脚本的健壮性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# ./hello.sh a</span><br><span class="line"></span><br><span class="line">cho &quot;hello,world!&quot;</span><br><span class="line">echo &#x27;====$n====&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">echo &#x27;====$#====&#x27;</span><br><span class="line">echo $#</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224018.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="844007d3e90a35fffe413fddd5337c99.png"></p><ol start="3"><li>$*、$@</li></ol><p>$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><blockquote><p>$* 相当于将所有参数组合为 ‘a b’ 的字符串；$@ 可以看作将参数放到一个数组中</p></blockquote><ol start="4"><li>$?</li></ol><p>$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明 上一个命令执行不正确了。）</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/0588115cbd9734a0a81e6714fb1c753a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/0588115cbd9734a0a81e6714fb1c753a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0588115cbd9734a0a81e6714fb1c753a.png"></p><h1 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h1><p>Linux中特定的运算需要使用expr命令</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224024.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224024.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0871a4b1d2ac49666eabe1a1b5696d7a.png"></p><blockquote><p>相当于向expr命令传输三个参数；其中*需要转义才能识别</p></blockquote><p>当我们需要赋值给变量时，需要使用Linux中的命令替换（将一个命令的结果替换再进行操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadpoo100 ~]# a=$(expr 5 \* 2)</span><br><span class="line">[root@hadpoo100 ~]# a=`expr 5 \* 2` #使用反引号</span><br></pre></td></tr></table></figure><p>为了方便快捷的进行运算，我们可以使用Linux指定的运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$((运算式)) 或 $[运算式]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224036.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224036.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d50a87f99a173dfebd8fd0888fca0a9e.png"></p><p>为变量赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadpoo100 ~]# a=$[(2+3)*2]</span><br></pre></td></tr></table></figure><h1 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5. 条件判断"></a>5. 条件判断</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test 条件 或 [ 条件 ]（注意 条件 前后要有空格）</span><br></pre></td></tr></table></figure><blockquote><p>条件非空即为 true，[ atguigu ]返回 true，[ ] 返回 false。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224039.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224039.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a092946f8a932a27334a713a4e274ee6.png"></p><blockquote><p>注意 &#x3D; 两边需要空格，否则会被看作为一个字符串</p></blockquote><ol><li>两个整数之间比较</li></ol><table><thead><tr><th align="center">条件</th><th>功能</th></tr></thead><tbody><tr><td align="center">-eq</td><td>等于（equal）</td></tr><tr><td align="center">-ne</td><td>不等于（not equal）</td></tr><tr><td align="center">-lt</td><td>小于（less than）</td></tr><tr><td align="center">-le</td><td>小于等于（less equal）</td></tr><tr><td align="center">-gt</td><td>大于（greater than）</td></tr><tr><td align="center">-ge</td><td>大于等于（greater equal）</td></tr></tbody></table><blockquote><p>可以用 “-z” 判断变量是否为空<br>如果是字符串之间的比较 ，用等号“&#x3D;”判断相等；用“!&#x3D;”判断不等。</p></blockquote><ol start="2"><li>按照文件权限进行判断</li></ol><table><thead><tr><th align="center">条件</th><th>功能</th></tr></thead><tbody><tr><td align="center">-r</td><td>有读的权限（read）</td></tr><tr><td align="center">-w</td><td>有写的权限（write）</td></tr><tr><td align="center">-x</td><td>有执行的权限（execute）</td></tr></tbody></table><ol start="3"><li>按照文件类型进行判断</li></ol><table><thead><tr><th align="center">条件</th><th>功能</th></tr></thead><tbody><tr><td align="center">-e</td><td>文件存在（existence）</td></tr><tr><td align="center">-f</td><td>文件存在并且是一个常规的文件（file）</td></tr><tr><td align="center">-d</td><td>文件存在并且是一个目录（directory）</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224042.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6257d66391fb804898b2cab0a5f0fb53.png"></p><p>多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一 条命令执行失败后，才执行下一条命令）</p><blockquote><p>类似Java中的三元运算符</p></blockquote><h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6. 流程控制"></a>6. 流程控制</h1><h2 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h2><ol><li>单分支</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]；then 程序 ；fi</span><br><span class="line"></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>Linux 中使用 ; 可以在一行执行多条命令</p></blockquote><p>多条件判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ] &amp;&amp; [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ 条件判断式 -a 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>其中 -a ：and；-o：or。</p></blockquote><ol start="2"><li>多分支</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">else</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>if 后要有空</p></blockquote><h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值 1&quot;）</span><br><span class="line">如果变量的值等于值 1，则执行程序 1</span><br><span class="line">;;</span><br><span class="line">&quot;值 2&quot;）</span><br><span class="line">如果变量的值等于值 2，则执行程序 2</span><br><span class="line">;;</span><br><span class="line">……</span><br><span class="line">*）</span><br><span class="line">如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><blockquote><p>case 行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p><p>双分号“;;”表示命令序列结束，相当于 java 中的 break。</p><p>最后的“*）”表示默认模式，相当于 java 中的 default。</p></blockquote><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>在 (( )) 中可以直接使用数学上的运算符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ((i=0;i&lt;$1;i++))</span><br><span class="line">do</span><br><span class="line">sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值 1 值 2 值 3…</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>此语法有点类似Java中的增强 for 循环</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224045.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224045.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="686dcf7b6553068b9f4095158b574851.png"></p><blockquote><p>Shell 中 {} 表示一个序列，如 {1..100} 表示1到100</p></blockquote><p>$* 和 $@ 的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;====$*====&#x27;</span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line">echo &#x27;====$@====&#x27;</span><br><span class="line">for i in $@</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224048.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224048.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1ad3e4140e828aa4eb7888c68b2d91d2.png"></p><blockquote><p>在不加双引号时，两者输出是相同的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;====$*====&#x27;</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line">echo &#x27;====$@====&#x27;</span><br><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224116.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006224116.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8a3f8d33727e8ad85c0b61f1e4160a8c.png"></p><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>程序内部必须改变条件判断式的参数，否则会陷入死循环</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">a=1</span><br><span class="line">while [ a -lt $1 ]</span><br><span class="line">do</span><br><span class="line">#sum=$[$a+$sum]</span><br><span class="line">#a=$[$a+1]     标准写法</span><br><span class="line">let sum+=a</span><br><span class="line">let a++</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><blockquote><p>为了代码方便书写，Shell 添加了 let 命令可以使用其它编程语言的语法</p></blockquote><h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read (选项) (参数)</span><br></pre></td></tr></table></figure><blockquote><p>-p：指定读取值时的提示符；<br>-t：指定读取值时等待的时间（秒）不加表示一直等待</p><p>参数：指定读取值的变量名</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds :&quot; name</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure><h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><ol><li>basename</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename [string / pathname] [suffix]</span><br></pre></td></tr></table></figure><blockquote><p>basename 命令会删掉最后一个（‘&#x2F;’）及之前的字符，然后将字符串显示出来。basename 可以理解为取路径里的文件名称</p><p>suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p></blockquote><ol start="2"><li>dirname</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname 文件绝对路径</span><br></pre></td></tr></table></figure><blockquote><p>从给定的包含绝对路径的文件名中去除文件名 （非目录的部分），然后返回剩下的路径（目录的部分）。dirname 可以理解为取文件路径名称</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo name:$(basename $0 .sh)</span><br><span class="line">echo path:$(cd $(dirname $0);pwd)</span><br></pre></td></tr></table></figure><blockquote><p>命令替换可以看作系统函数的调用方式</p></blockquote><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">    Action;</span><br><span class="line">    [return n;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中 [] 中的内容都可以省略</p></blockquote><p>shell 脚本是逐行运行。不会像其它语言一 样先编译，必须在调用函数地方之前，先声明函数。</p><p>函数返回值，只能通过$?系统变量获得，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值 n(0-255)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">function add()&#123;</span><br><span class="line">s=$[$!+$2]</span><br><span class="line">echo $s</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;请输入第一个整数&quot; a</span><br><span class="line">read -p &quot;请输入第二个整数&quot; b</span><br><span class="line">sum=$&#123;add $a $b&#125;</span><br><span class="line">echo &quot;结果：&quot;$sum</span><br></pre></td></tr></table></figure><blockquote><p>这样函数的返回值不会受到 $? 的限制，且返回值sum可以进行进一步计算</p></blockquote><h1 id="8-文本处理工具"><a href="#8-文本处理工具" class="headerlink" title="8. 文本处理工具"></a>8. 文本处理工具</h1><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut [选项参数] filename</span><br><span class="line">说明：默认分隔符是制表符</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">-f</td><td>列号，提取第几列</td></tr><tr><td align="center">-d</td><td>分隔符，按照指定分隔符分割列，默认是制表符“\t”</td></tr><tr><td align="center">-c</td><td>按字符进行切割后加 n 表示取第几列，比如 -c 1</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看ip</span><br><span class="line">[root@hadoop100 ~]# ifconfig |grep netmask |cut -d &quot; &quot; -f  10</span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] ‘/pattern1/&#123;action1&#125; /pattern2/&#123;action2&#125;...’ filename</span><br><span class="line">pattern：表示 awk 在数据中查找的内容，就是匹配模式</span><br><span class="line">action：在找到匹配内容时所执行的一系列命令</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">-F</td><td>指定输入文件分隔符</td></tr><tr><td align="center">-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 1 列和第 7 列，中间以“，”号分割。</span><br><span class="line">[root@hadoop100 ~]# awk -F : &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; /etc/passwd</span><br><span class="line">/bin/bash</span><br><span class="line">#只显示/etc/passwd 的第一列和第七列，以逗号分割，且在所有行前面添加列名 user，shell 在最后一行添加 end,end。</span><br><span class="line">[root@hadoop100 ~]# cat /etc/passwd |awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125;&#123;print $1&quot;,&quot;$7&#125;END&#123;print &quot;end,end&quot;&#125;&#x27;</span><br><span class="line">user,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">...</span><br><span class="line">leamon,/bin/bash</span><br><span class="line">end,end</span><br><span class="line">#将 passwd 文件中的用户 id 加 1 并输出</span><br><span class="line">[root@hadoop100 ~]# awk -v i=1 -F : &#x27;&#123;print $3+i&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><blockquote><p>BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p></blockquote><table><thead><tr><th align="center">内置变量</th><th>说明</th></tr></thead><tbody><tr><td align="center">FILENAME</td><td>文件名</td></tr><tr><td align="center">NR</td><td>已读的记录数（行号）</td></tr><tr><td align="center">NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计 passwd 文件名，每行的行号，每行的列数</span><br><span class="line">[root@hadoop100 ~]# awk -F : &#x27;&#123;print &quot;filename:&quot;FILENAME&quot;,linenum:&quot;NR&quot;,col:&quot;NF&#125;&#x27; /etc/passwd</span><br><span class="line">#切割 IP</span><br><span class="line">[root@hadoop100 ~]# ifconfig ens33 | awk &#x27;/netmask/ &#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>awk 中如果前面很多空格，默认删除</p></blockquote><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>可以使用Linux 自带的 mesg 和 write 工具，向其它用户发送消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">who #查看所有用户</span><br><span class="line">who -T #查看所有用户是否打开mesg；+：打开</span><br><span class="line">mesg #查看是否打开mesg；mesg y/n （打开/关闭）</span><br><span class="line">write 用户名 控制台 #向指定用户发消息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务</title>
      <link href="/2023/10/03/%E6%A1%86%E6%9E%B6/7.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/10/03/%E6%A1%86%E6%9E%B6/7.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK定时器"><a href="#JDK定时器" class="headerlink" title="JDK定时器"></a>JDK定时器</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h3><p>像下面的Timer和定时任务线程池，底层都是小顶堆的结构。</p><p>堆是特殊的树，满足下面两个条件就是一个小顶堆：</p><ul><li>是一颗完全二叉树</li><li>堆中的某个节点的值总是不大于其父节点的值</li></ul><p>插入元素（定时任务）：插入尾部，逐步上浮（与父节点比较，进行交换）</p><p>删除堆顶元素（执行定时任务）：将尾部（最大的元素）放到堆顶，逐步下沉（与子节点比较，进行交换）</p><h3 id="时间轮算法"><a href="#时间轮算法" class="headerlink" title="时间轮算法"></a>时间轮算法</h3><p>小顶堆只适合相近时间内的小量任务，当执行时间相差过大或任务量很大时，添加新任务或执行堆顶任务时堆化的性能很低。</p><p>像Quartz或者其他复杂的定时任务框架，底层更多地会使用时间轮算法。</p><h4 id="链表-数组实现"><a href="#链表-数组实现" class="headerlink" title="链表+数组实现"></a>链表+数组实现</h4><p>while-true-sleep；遍历数组，每个下标建立一个链表，链表节点中存储任务，遍历到就取出执行。</p><p>比如数组的长度为24，每一个数组元素中存储执行任务的链表，相对小顶堆性能有了很大提升，但依然存在问题，比如想在每个月的1号执行任务就不好实现，不够灵活。</p><h4 id="round型时间轮"><a href="#round型时间轮" class="headerlink" title="round型时间轮"></a>round型时间轮</h4><p>任务上记录一个round值，遍历到便将round值减1，为0时取出执行。</p><p>比如数组的长度为24，每个数组元素中存储执行任务的链表，链表节点中除了存储任务，还存储了round值，比如明天的任务就可以设置round为1，当第二遍遍历到时便可取出执行。</p><p>存在问题：每次需要遍历所有的任务，效率较低</p><h4 id="分层时间轮"><a href="#分层时间轮" class="headerlink" title="分层时间轮"></a>分层时间轮</h4><p>使用多个不同时间维度的轮：</p><ul><li>天轮：记录几点执行</li><li>月轮：记录几号执行</li></ul><p>月轮中匹配当前日期，若存在任务，就到天轮中遍历任务执行，达到几号几点执行任务的需求。</p><blockquote><p>像Linux中定时任务的cron表达式就是典型的分层时间轮</p></blockquote><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>Timer类中有几个属性需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小顶堆，存放timeTask</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line"><span class="comment">//任务执行线程；死循环不断检查是否有任务需要执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>单线程执行任务，任务可能相互阻塞</li><li>运行时异常会导致timer线程终止</li><li>任务调度时基于绝对时间的，对系统时间敏感</li></ul><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里定时任务就已经启动了，但是队列中没有任务，所以一直等待</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加任务</span></span><br><span class="line">            <span class="comment">// timer.schedule(new MyTimerTask(&quot;task&quot; + i), 0, 2000);</span></span><br><span class="line">            timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(<span class="string">&quot;task&quot;</span> + i), <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTimerTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;结束时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>schedule</code>与<code>scheduleAtFixedRate</code>异同：</p><p>相同点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">任务执行未超时，下次执行时间 = 上次执行开始时间 + period；</span><br><span class="line"></span><br><span class="line">任务执行超时，下次执行时间 = 上次执行结束时间；</span><br><span class="line"></span><br><span class="line">在任务执行未超时时，它们都是上次执行时间加上间隔时间，来执行下一次任务。而执行超时时，都是立马执行。</span><br></pre></td></tr></table></figure><p>区别点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schedule侧重保持间隔时间的稳定。</span><br><span class="line">schedule 执行任务超时，第N个任务会在  N-1个任务执行完成后，不做period等待，立即启动执行；N任务执行未超时，N+1个任务会在N任务执行完成后，等待period，再执行。</span><br><span class="line">即：schedule侧重时间间隔的稳定，错过了就错过了，后续按照新的节奏走。</span><br><span class="line"></span><br><span class="line">scheduleAtFixedRate侧重保持执行频率的稳定。</span><br><span class="line">scheduleAtFixedRate在任务执行超时后，不错period等待，立即执行下一个任务。并且后续任务会根据超时时长，不做period等待，立即执行后续的任务，直到追上设定的节奏后，再进行period等待执行后续任务。</span><br><span class="line">即：scheduleAtFixedRate侧重的是频率的稳定，如果错过了，就取消period等待，努力追上设定好的节奏。</span><br></pre></td></tr></table></figure><h2 id="定时任务线程池"><a href="#定时任务线程池" class="headerlink" title="定时任务线程池"></a>定时任务线程池</h2><p><code>ScheduledThreadPoolExecutor</code>：</p><ul><li><p>使用多线程执行任务，不会相互阻塞</p></li><li><p>如果线程失活，会创建新线程执行任务。（线程抛异常，任务会被丢弃，需要做捕获处理）</p></li><li><p>DalayedWorkQueue：小顶堆，无界队列</p><ul><li><p>在定时线程池中，最大线程数是没有意义的，核心线程数才有意义</p></li><li><p>执行时间距离当前时间越近的任务在队列的前面</p></li><li><p>用于添加ScheduleFutureTask（继承于FutureTask，实现RunnableScheduledFuture接口）</p><ul><li>提供异步执行的能力，并且可以返回执行时间</li></ul></li><li><p>线程池中的线程从DelayQueue中获取ScheduleFutureTask，然后执行任务</p></li><li><p>实现了Delayed接口，可以通过getDelay方法获取延迟时间</p></li></ul></li><li><p>Leader-Follower模式</p><ul><li>避免没必要的唤醒和阻塞的操作，节省资源</li></ul></li></ul><blockquote><p>在<strong>Leader-follower线程模型</strong>中每个线程有三种模式，leader,follower, processing。</p><p>在Leader-follower线程模型一开始会创建一个线程池，并且会选取一个线程作为leader线程，leader线程负责监听网络请求，其它线程为follower处于waiting状态，当leader线程接受到一个请求后，会释放自己作为leader的权利，然后从follower线程中选择一个线程进行激活，然后激活的线程被选择为新的leader线程作为服务监听，然后老的leader则负责处理自己接受到的请求（现在老的leader线程状态变为了processing），处理完成后，状态从processing转换为follower</p></blockquote><p><code>SingleThreadScheduledExecutor</code>：</p><ul><li><p>单线程的ScheduledThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;tesk-&quot;</span> + i), <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;结束时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间隔是固定的，无论上一个任务是否完成</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="type">long</span> initialDelay,<span class="type">long</span> delay,TimeUnit unit);</span><br><span class="line"><span class="comment">//间隔是不固定的，其会在周期任务的上一个任务执行完成后再开始计时，并在指定时间间隔之后才开始执行任务</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="type">long</span> initialDelay,<span class="type">long</span> period,TimeUnit unit);</span><br></pre></td></tr></table></figure><h1 id="定时任务框架-Quartz"><a href="#定时任务框架-Quartz" class="headerlink" title="定时任务框架-Quartz"></a>定时任务框架-Quartz</h1><p>官网：<a href="http://www.quartz-scheduler.org/">Quartz Enterprise Job Scheduler (quartz-scheduler.org)</a></p><h2 id="结构图："><a href="#结构图：" class="headerlink" title="结构图："></a>结构图：</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006215239.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006215239.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c25d8afce8bbd8c976a39df7caf62208.png"></p><ol><li><p>Job：封装为JobDetail设置属性</p><ul><li><code>@DisallowConcurrentExecution</code>：禁止并发地执行同一个job定义（JobDetail定义的）多个实例</li><li><code>@PersistJobDataAfterExecution</code>：持久化JobDetail中的JobDataMap（对Trigger中的DataMap无效）<ul><li>如果一个任务不是持久化的，则当没有触发器关联它时，Quartz会从scheduler中删除它</li></ul></li><li>如果一个任务请求恢复，一般是该任务执行期间发生了系统奔溃或者其他关闭进程的操作，当服务再次启动的时候，会再次执行该任务，此时，<code>JobExercutionContext.isRecovering()</code>会返回true</li></ul></li><li><p>Trigger：触发器</p><ul><li><p>优先级</p><ul><li>同时触发的Trigger之间才会比较优先级</li><li>如果Trigger是可恢复的，在恢复后再调度时，优先级不变</li></ul></li><li><p><code>misfire</code>：错过触发</p><ul><li><p>判断条件：</p><ul><li>job到达触发时间时没有执行</li><li>被执行的延迟时间超过了Quartz配置的<code>misfire Threshold</code>阈值</li></ul></li></ul></li><li><p>产生原因：</p><ul><li><p>当job达到触发时间时，所有线程都被其他job占用，没有可用线程</p><ul><li>再job需要触发的时间点，scheduler停止了</li><li>job使用了<code>@DisallowConcurrentExecution</code>注解，job不能并发执行，当达到了下一个job执行点时，上一个任务还未完成</li><li>job指定了过去的开始执行时间，例如当前是8点，指定开始时间为7点</li></ul></li><li><p><strong>策略</strong>：默认都使用<code>MISFIRE_INSTRUCTION_SMART_POLICY</code>；Quartz会根据Trigger的类型（SimpleTrigger或CronTrigger）和配置自动选择最合适的处理方式。</p><ul><li><p><code>SimpleTrigger</code>：具体时间，指定间隔重复执行</p><ul><li><p>now*相关的策略，会立即执行第一个misfire的任务，同时会修改<code>startTime和repeatCount</code>，导致会重新计算<code>finalFireTime</code>，打乱原计划</p></li><li><p>next*相关的策略，不会立即执行misfire的任务，补充执行</p></li></ul></li></ul></li><li><p><code>CronTrigger</code>：cron表达式</p><ul><li><code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY</code>：Trigger错过后忽略Misfire策略。例如当前时间是下午2点，而任务本应该在早上10点执行，Quartz框架会等待下一个触发时间，比如下午3点，然后执行任务。它不会考虑错过的10点触发时间，而是仅仅基于当前时间和下一个预定触发时间进行调度。<ul><li><code>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW</code>：Trigger错过后立即执行</li></ul></li><li><code>MISFIRE_INSTRUCTION_DO_NOTHING</code>：Trigger错过后不做任何处理</li></ul></li></ul></li><li><p><code>calendar</code>：设置排除时间段</p></li></ul></li><li><p>Scheduler：调度器，基于Trigger的设定执行Job</p><ul><li><p>SchedulerFactory：</p><ul><li>创建Scheduler</li><li>DirectSchedulerFactory：在代码中定制Scheduler</li><li>StdSchedulerFactory：读取classPah下的<code>quartz.properties</code>文件来实例化Scheduler</li></ul></li><li><p>JobStore：存储运行时信息，包括Trigger、Schduler、JobDetail、业务锁等</p><ul><li><p>RAMJobStore（内存实现）</p></li><li><p>JobStoreTX（JDBC，事务由Quartz管理）</p></li><li><p>JobStoreCMT（JDBC，使用容器事务）</p></li><li><p>ClusteredJobStore（集群实现）</p></li><li><p>TerracottaJobStore（Terracotta中间件）</p></li></ul></li><li><p>ThreadPool</p><ul><li>SimpleThreadPool</li><li>自定义线程池</li></ul></li></ul></li><li><p>JobDataMap：保存任务实例的状态信息</p><ul><li>JobDetail：默认旨在Job被添加到调度程序（任务执行计划表）scheduler的时候，存储一次关于该任务的状态信息数据，可以使用注解<code>@PersistJobDataAfterExecution</code>注解标明在一个任务执行完毕之后就存储一次</li><li>Trigger：任务被多个触发器引用的时候，根据不同的触发时机，可以提供不同的输入条件</li></ul></li></ol><h2 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="comment">// 判断是否是恢复执行的任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">recovering</span> <span class="operator">=</span> context.isRecovering();</span><br><span class="line">        <span class="comment">// 获取各自存储的数据</span></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDataMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">triggerMap</span> <span class="operator">=</span> context.getTrigger().getJobDataMap();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">mergedMap</span> <span class="operator">=</span> context.getMergedJobDataMap();</span><br><span class="line">        <span class="comment">// 框架自动调用set方法，结果为 trigger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;jobDataMap:&quot;</span> + jobDataMap.get(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">        jobDataMap.put(<span class="string">&quot;count&quot;</span>, jobDataMap.getIntValue(<span class="string">&quot;count&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;mergedMap:&quot;</span> + mergedMap.get(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quartzTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">        <span class="comment">// 创建一个HolidayCalendar对象，定义假期日期（1月1日）</span></span><br><span class="line">        <span class="type">HolidayCalendar</span> <span class="variable">holidayCalendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HolidayCalendar</span>();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">christmas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        <span class="comment">// 1月</span></span><br><span class="line">        christmas.set(Calendar.MONTH, Calendar.JANUARY);</span><br><span class="line">        <span class="comment">// 1日</span></span><br><span class="line">        christmas.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        holidayCalendar.addExcludedDate(christmas.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                <span class="comment">// 存储数据</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;jobDetail&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jobDetail&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;count&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 创建触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;trigger1&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;trigger&quot;</span>, <span class="string">&quot;trigger&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;trigger&quot;</span>)</span><br><span class="line">                .usingJobData(<span class="string">&quot;count&quot;</span>, <span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 设置触发器的启动时间</span></span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">// 设置启动策略</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        <span class="comment">// 设置延迟时间</span></span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>)</span><br><span class="line">                        <span class="comment">// 设置一直重复执行</span></span><br><span class="line">                        .repeatForever())</span><br><span class="line">                .modifiedByCalendar(<span class="string">&quot;holidayCalendar&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// StdSchedulerFactory使用配置文件创建调度器；这里使用默认的</span></span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        <span class="comment">// 注册Trigger和JobDetail到Scheduler</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        <span class="comment">// 将HolidayCalendar关联到Scheduler</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        name（名称）：Calendar 对象指定的唯一标识符。</span></span><br><span class="line"><span class="comment">        calendar（日历）：用于定义排除特定日期和时间的规则。</span></span><br><span class="line"><span class="comment">        replace（替换）：设置为 true，新的 Calendar 对象将替换掉已存在的。</span></span><br><span class="line"><span class="comment">            为 false，如果同名的 Calendar 对象已经存在，将会抛出 ObjectAlreadyExistsException 异常。</span></span><br><span class="line"><span class="comment">        updateTriggers（更新触发器）：设置为 true，那么与 Calendar 相关联的所有 Trigger 对象（使用 modifiedByCalendar(name) 方法关联的 Trigger）将会被更新，以反映新的 Calendar 规则。</span></span><br><span class="line"><span class="comment">            如果设置为 false，只有在新建 Trigger 时才会使用新的 Calendar 规则，已存在的 Trigger 不会受到影响。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduler.addCalendar(<span class="string">&quot;holidayCalendar&quot;</span>, holidayCalendar, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库建表脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_LOCKS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_TRIGGERS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;</span><br><span class="line">DROP TABLE IF EXISTS QRTZ_CALENDARS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_JOB_DETAILS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    JOB_NAME  VARCHAR(200) NOT NULL,</span><br><span class="line">    JOB_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    DESCRIPTION VARCHAR(250) NULL,</span><br><span class="line">    JOB_CLASS_NAME   VARCHAR(250) NOT NULL,</span><br><span class="line">    IS_DURABLE VARCHAR(1) NOT NULL,</span><br><span class="line">    IS_NONCONCURRENT VARCHAR(1) NOT NULL,</span><br><span class="line">    IS_UPDATE_DATA VARCHAR(1) NOT NULL,</span><br><span class="line">    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,</span><br><span class="line">    JOB_DATA BLOB NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    JOB_NAME  VARCHAR(200) NOT NULL,</span><br><span class="line">    JOB_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    DESCRIPTION VARCHAR(250) NULL,</span><br><span class="line">    NEXT_FIRE_TIME BIGINT(13) NULL,</span><br><span class="line">    PREV_FIRE_TIME BIGINT(13) NULL,</span><br><span class="line">    PRIORITY INTEGER NULL,</span><br><span class="line">    TRIGGER_STATE VARCHAR(16) NOT NULL,</span><br><span class="line">    TRIGGER_TYPE VARCHAR(8) NOT NULL,</span><br><span class="line">    START_TIME BIGINT(13) NOT NULL,</span><br><span class="line">    END_TIME BIGINT(13) NULL,</span><br><span class="line">    CALENDAR_NAME VARCHAR(200) NULL,</span><br><span class="line">    MISFIRE_INSTR SMALLINT(2) NULL,</span><br><span class="line">    JOB_DATA BLOB NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line">    FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span><br><span class="line">        REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_SIMPLE_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    REPEAT_COUNT BIGINT(7) NOT NULL,</span><br><span class="line">    REPEAT_INTERVAL BIGINT(12) NOT NULL,</span><br><span class="line">    TIMES_TRIGGERED BIGINT(10) NOT NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_CRON_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    CRON_EXPRESSION VARCHAR(200) NOT NULL,</span><br><span class="line">    TIME_ZONE_ID VARCHAR(80),</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_SIMPROP_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    STR_PROP_1 VARCHAR(512) NULL,</span><br><span class="line">    STR_PROP_2 VARCHAR(512) NULL,</span><br><span class="line">    STR_PROP_3 VARCHAR(512) NULL,</span><br><span class="line">    INT_PROP_1 INT NULL,</span><br><span class="line">    INT_PROP_2 INT NULL,</span><br><span class="line">    LONG_PROP_1 BIGINT NULL,</span><br><span class="line">    LONG_PROP_2 BIGINT NULL,</span><br><span class="line">    DEC_PROP_1 NUMERIC(13,4) NULL,</span><br><span class="line">    DEC_PROP_2 NUMERIC(13,4) NULL,</span><br><span class="line">    BOOL_PROP_1 VARCHAR(1) NULL,</span><br><span class="line">    BOOL_PROP_2 VARCHAR(1) NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_BLOB_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    BLOB_DATA BLOB NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_CALENDARS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    CALENDAR_NAME  VARCHAR(200) NOT NULL,</span><br><span class="line">    CALENDAR BLOB NOT NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP  VARCHAR(200) NOT NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_FIRED_TRIGGERS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    ENTRY_ID VARCHAR(95) NOT NULL,</span><br><span class="line">    TRIGGER_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    TRIGGER_GROUP VARCHAR(200) NOT NULL,</span><br><span class="line">    INSTANCE_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    FIRED_TIME BIGINT(13) NOT NULL,</span><br><span class="line">    SCHED_TIME BIGINT(13) NOT NULL,</span><br><span class="line">    PRIORITY INTEGER NOT NULL,</span><br><span class="line">    STATE VARCHAR(16) NOT NULL,</span><br><span class="line">    JOB_NAME VARCHAR(200) NULL,</span><br><span class="line">    JOB_GROUP VARCHAR(200) NULL,</span><br><span class="line">    IS_NONCONCURRENT VARCHAR(1) NULL,</span><br><span class="line">    REQUESTS_RECOVERY VARCHAR(1) NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,ENTRY_ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_SCHEDULER_STATE</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    INSTANCE_NAME VARCHAR(200) NOT NULL,</span><br><span class="line">    LAST_CHECKIN_TIME BIGINT(13) NOT NULL,</span><br><span class="line">    CHECKIN_INTERVAL BIGINT(13) NOT NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE QRTZ_LOCKS</span><br><span class="line">  (</span><br><span class="line">    SCHED_NAME VARCHAR(120) NOT NULL,</span><br><span class="line">    LOCK_NAME  VARCHAR(40) NOT NULL,</span><br><span class="line">    PRIMARY KEY (SCHED_NAME,LOCK_NAME)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p>来自官方下载的包中，路径为：quartz-2.3.0-SNAPSHOT\src\org\quartz\impl\jdbcjobstore</p></blockquote><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># 1. 基本配置</span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 调度标识名，集群中每一个实例都必须使用相同的名称。</span></span><br><span class="line"><span class="comment"># 可以为任意字符串，对于scheduler来说此值没有任何意义，但是可以区分同一系统中多个不同的实例。</span></span><br><span class="line"><span class="comment"># 如果使用了集群的功能，就必须对每一个实例使用相同的名称，这样使这些实例“逻辑上”是同一个scheduler。</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceName</span> = <span class="string">SERVICEX-SCHEDULER-INSTANCE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># ID设置为自动获取，每一个实例不能相同。</span></span><br><span class="line"><span class="comment"># 可以为任意字符串，如果使用了集群的功能，SCHEDULER实例的值必须唯一，可以使用AUTO自动生成。</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.instanceId</span> = <span class="string">AUTO</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认值为false</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.rmi.export</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认值为false</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.rmi.proxy</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认false，若是在执行Job之前Quartz开启UserTransaction，此属性应该为true。 Job执行完毕，JobDataMap更新完（如果是StatefulJob）事务就会提交。</span></span><br><span class="line"><span class="comment"># 可以在JOB类上使用 @ExecuteInJTATransaction注解，以便在各自的JOB上决定是否开启JTA事务。</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.wrapJobExecutionInUserTransaction</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 一个SCHEDULER节点允许接收的TRIGGER的最大数，默认是1。值越大定时任务执行的越多，代价是集群节点之间的不均衡。</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.batchTriggerAcquisitionMaxCount</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># 2. 调度器线程池配置</span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 线程池的实现类，一般使用SimpleThreadPool即可满足需求</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span> = <span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 指定线程数无默认值，至少为1，指定该值后线程数量不会动态增加。</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span> = <span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 线程的优先级(最大为java.lang.Thread.MAX_PRIORITY 10，最小为Thread.MIN_PRIORITY 1，默认为5)</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span> = <span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 加载任务代码的ClassLoader是否从外部继承</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否设置调度器线程为守护线程</span></span><br><span class="line"><span class="attr">org.quartz.scheduler.makeSchedulerThreadDaemon</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"># 3. 作业存储配置</span></span><br><span class="line"><span class="comment">#============================================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JDBC的存储方式</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.springframework.scheduling.quartz.LocalDataSourceJobStore</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 数据库驱动，类似于Hibernate的dialect，用于处理DB之间的差异，StdJDBCDelegate能满足大部分的DB的使用。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.driverDelegateClass</span> = <span class="string">org.quartz.impl.jdbcjobstore.PostgreSQLDelegate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否加入集群，当有多个Quartz实例在用同一套数据库时，必须设置为true。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.isClustered</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 检查集群节点状态的频率, 默认值是 15000(即15秒)</span></span><br><span class="line"><span class="comment"># 只用于设置了isClustered为true的时，才需要设置该项，用于实例上报信息给集群中的其他实例，这个值的大小会影响到侦测失败实例的敏捷度。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.clusterCheckinInterval</span> = <span class="string">5000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 这是JobStore能处理的错过触发的TRIGGER的最大数量。处理太多则很快就会导致数据库中的表被锁定够长的时间，这样则会妨碍别的（还未错过触发）TRIGGER执行的性能。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.maxMisfiresToHandleAtATime</span> = <span class="string">1</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.txIsolationLevelSerializable</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置这个参数为true会告诉Quartz从数据源获取连接后不要调用它的setAutoCommit(false)方法，大部分情况下驱动都要求调用setAutoCommit(false)。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.dontSetAutoCommitFalse</span> = <span class="string">false</span></span><br><span class="line"><span class="comment"># 这必须是一个从LOCKS表查询一行并对这行记录加锁的SQL。假设没有设置，默认值如下。&#123;0&#125;会在运行期间被配置的TABLE_PREFIX所代替。</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.selectWithLockSQL</span>=<span class="string">SELECT * FROM &#123;0&#125;LOCKS WHERE LOCK_NAME = ? FOR UPDATE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置调度引擎对触发器超时的忍耐时间 (单位毫秒)</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span> = <span class="string">12000</span></span><br><span class="line"><span class="comment"># 表的前缀，默认QRTZ_</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span> = <span class="string">QRTZ_</span></span><br></pre></td></tr></table></figure><blockquote><p>SpringBoot在2.5.6版本之后就删除了关于Quartz相关的依赖；在2.5.6及之前版本：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br></pre></td></tr></table></figure></blockquote><p>SpringBoot只需要配置数据源即可。</p><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean().getScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SchedulerFactoryBean <span class="title function_">schedulerFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        factoryBean.setSchedulerName(<span class="string">&quot;MyScheduler&quot;</span>);</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 设置配置文件</span></span><br><span class="line">        <span class="type">PropertiesFactoryBean</span> <span class="variable">propertiesFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesFactoryBean</span>();</span><br><span class="line">        propertiesFactoryBean.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;/spring-quartz.properties&quot;</span>));</span><br><span class="line">        propertiesFactoryBean.afterPropertiesSet();</span><br><span class="line">        factoryBean.setQuartzProperties(propertiesFactoryBean.getObject());</span><br><span class="line">        factoryBean.setTaskExecutor(schedulerThreadPool());</span><br><span class="line">        <span class="comment">//设置延迟时间</span></span><br><span class="line">        factoryBean.setStartupDelay(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">schedulerThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//ThreadPoolTaskExecutor是Spring框架提供的一个线程池实现，通常用于管理任务的执行。</span></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 设置线程数为虚拟机可用的处理器数</span></span><br><span class="line">        threadPool.setCorePoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        threadPool.setMaxPoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        threadPool.setQueueCapacity(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置监听器，在SpringBoot启动时启动调度器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextClosedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> &#123;</span><br><span class="line">        <span class="type">TriggerKey</span> <span class="variable">triggerKey</span> <span class="operator">=</span> TriggerKey.triggerKey(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;trigger1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> scheduler.getTrigger(triggerKey);</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(trigger)) &#123;</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                    .withIdentity(triggerKey)</span><br><span class="line">                    .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/2 * * * * ? &quot;</span>))</span><br><span class="line">                    .build();</span><br><span class="line">                <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyQuartzJob.class)</span><br><span class="line">                    .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">                scheduler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cron表达式最好还是用在线工具生成，手打容易漏空格</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQuartzJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的时间是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用简单实现"><a href="#常用简单实现" class="headerlink" title="常用简单实现"></a>常用简单实现</h2><p>使用两个注解便可以基本满足我们定时任务的需求：</p><ul><li><strong>@Scheduled</strong></li><li><strong>@EnableScheduling</strong></li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyRun.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Scheduled</strong>的用法非常灵活，以下是一些使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 60000)</span>: 每<span class="number">60</span>秒执行一次。</span><br><span class="line"><span class="meta">@Scheduled(fixedDelay = 60000)</span>: 当前次任务执行完成后，延迟<span class="number">60</span>秒后执行下一次任务。</span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 10000, fixedRate = 60000)</span>: 首次延迟<span class="number">10</span>秒，之后每<span class="number">60</span>秒执行一次。</span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 * * * * ?&quot;)</span>: 使用Cron表达式来定义更复杂的定时任务规则。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/09/28/%E5%B7%A5%E5%85%B7/Git/"/>
      <url>/2023/09/28/%E5%B7%A5%E5%85%B7/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Git-概述"><a href="#1-Git-概述" class="headerlink" title="1. Git 概述"></a>1. Git 概述</h1><p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。</p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><h3 id="集中式版本控制工具"><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h3><p>CVS、SVN(Subversion)、VSS……</p><p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>好处：每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>缺点：中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><h3 id="分布式版本控制工具"><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h3><p>Git、Mercurial、Bazaar、Darcs……</p><p>分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>解决了集中式版本控制系统的缺陷：</p><ol><li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</li></ol><h3 id="Git-和代码托管中心"><a href="#Git-和代码托管中心" class="headerlink" title="Git 和代码托管中心"></a>Git 和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。</p><p>局域网：GitLab</p><p>互联网 ：GitHub（外网）；Gitee 码云（国内网站）</p><h3 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h3><p>官网：<a href="https://git-scm.com/">Git (git-scm.com)</a></p><p>由于官网下载过慢且需要授权，我们可以使用淘宝npm的镜像地址：</p><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror (npmmirror.com)</a></p><p>Git 的安装只需要改一下安装路径，再如下图改一下环境配置信息，其它直接默认下一步即可。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221808.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221808.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bf7f1a21ba58b5314fc3abbe91efea26.png"></p><p>桌面右键，选择 Git Bash Here 即可打开 Git Bash 命令行终端，在 Git Bash 终端里输入 git –version 查看 git 版本，说明 Git 安装成功。</p><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><table><thead><tr><th align="center">命令名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td align="center">git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td align="center"><span style="color:Crimson">git init</span></td><td>初始化本地库</td></tr><tr><td align="center"><span style="color:Crimson">git status</span></td><td>查看本地库状态</td></tr><tr><td align="center"><span style="color:Crimson">git add 文件名</span></td><td>添加到暂存区</td></tr><tr><td align="center"><span style="color:Crimson">git commit -m “日志信息” 文件名</span></td><td>提交到本地库</td></tr><tr><td align="center"><span style="color:Crimson">git reflog </span></td><td>查看历史记录</td></tr><tr><td align="center"><span style="color:Crimson">git reset –hard 版本号</span></td><td>版本穿梭</td></tr><tr><td align="center">git clone -b 分支名 地址</td><td>拉取指定分支代码</td></tr></tbody></table><blockquote><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。</p><p>可以在当前用户目录的 .gitconfig 文件查看用户签名</p><p>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p></blockquote><p>Git 中的命令和 Linux 中的命令是通用的</p><table><thead><tr><th>系统</th><th>描述</th><th>名称</th><th>转义符</th></tr></thead><tbody><tr><td>Windows</td><td>回车换行</td><td>CRLF</td><td>\n\r</td></tr><tr><td>Linux</td><td>换行</td><td>LF</td><td>\n</td></tr></tbody></table><h2 id="初始化本地库："><a href="#初始化本地库：" class="headerlink" title="初始化本地库："></a>初始化本地库：</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221821.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221821.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="314015570847c684f63b39b49f3ef8e4.png"></p><blockquote><p>初始化本地库后，会在库目录创建 .git 的隐藏文件</p></blockquote><h2 id="查看本地库状态："><a href="#查看本地库状态：" class="headerlink" title="查看本地库状态："></a>查看本地库状态：</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221824.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221824.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9f49ad434e470961afabc7741b7d6f74.png"></p><p>添加文件后查看会提示检测到未追踪的文件，红色标注</p><h2 id="添加暂存区："><a href="#添加暂存区：" class="headerlink" title="添加暂存区："></a>添加暂存区：</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221829.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221829.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4ebe9f579442ac5da439a35c3cf37a34.png"></p><p>添加到暂存区后会以绿色标注；提示的代码是将暂存区的文件删除，对原文件没有影响。</p><blockquote><p>可使用git ls-files查看暂存区的文件</p></blockquote><h2 id="提交到本地库："><a href="#提交到本地库：" class="headerlink" title="提交到本地库："></a>提交到本地库：</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222057.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222057.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7bf1ac047228ddb506523ab10c03b0a3.png"></p><p>修改文件后查看状态：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222102.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222102.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="39177e211be0113323f36fe7fc224dd0.png"></p><blockquote><p>git restore &lt;file&gt; 是恢复文件，放弃修改</p></blockquote><h2 id="历史版本："><a href="#历史版本：" class="headerlink" title="历史版本："></a>历史版本：</h2><p>查看历史版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog 查看版本信息</span><br><span class="line">git log 查看版本详细信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222108.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222108.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0743fdd21a905b95725facddd87a19e2.png"></p><p>版本穿梭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222114.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222114.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d24632d46aabb39f43ea7790de198368.png"></p><blockquote><p>Git 切换版本，底层其实是移动的 master 指针。</p><p>此时本地库的文件也切换成了第一版</p></blockquote><h1 id="3-Git分支操作"><a href="#3-Git分支操作" class="headerlink" title="3. Git分支操作"></a>3. Git分支操作</h1><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222119.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7b6fd9fab71d733f9d6149aba4b2d84e.png"></p><p>分支：在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。</p><p>优点：同时并行推进多个功能开发，提高开发效率。各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><table><thead><tr><th align="center">命令名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td>创建分支</td></tr><tr><td align="center">git branch -v</td><td>查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td>切换分支</td></tr><tr><td align="center">git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr><tr><td align="center">git branch -d 分支名</td><td>删除本地分支（不会影响远程仓库中的任何分支）</td></tr></tbody></table><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222124.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222124.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a3a0b22a9428cf541f047edf7fd63d3b.png"></p><blockquote><p>创建的分支会将主分支master的内容复制一份</p></blockquote><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222128.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222128.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="816f9c441c41ca980bcf9420e3b88571.png"></p><blockquote><p>在master分支中修改文件并提交不会影响hot-fix分支的内容</p></blockquote><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>正常情况：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222138.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222138.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="30c6677610fa6055b9b13a7853ef6663.png"></p><p>合并冲突：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222152.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222152.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="149832814173dded306c3270ee1967db.png"><br><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/5eab95fcad7c33d2b9c8897d105bf6cd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/5eab95fcad7c33d2b9c8897d105bf6cd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5eab95fcad7c33d2b9c8897d105bf6cd.png"></p><blockquote><p>此时需要我们使用vim手动打开文件进行合并；其中 &lt;&lt;…&#x3D;&#x3D; 部分是当前分支提交保存的内容；&#x3D;&#x3D;..&gt;&gt; 是 hot-fix 分支中提交保存的内容；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222200.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222200.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f0f01aa9365d25da1bf7ea0626d046fa.png"></p><p>修改完后提交即可完成代码合并</p><p>注意：<strong>解决代码冲突时提交文件不能带文件名</strong></p><p>分支的底层解释：master、hot-fix 都是指向具体版本记录的指针。当前所在的分支由 HEAD 决定。所以创建分支的本质就是多创建一个指针。 HEAD 如果指向 master，那么我们现在就在 master 分支上。 切换分支的本质就是移动 HEAD 指针。</p><h2 id="Git-团队协作机制"><a href="#Git-团队协作机制" class="headerlink" title="Git 团队协作机制"></a>Git 团队协作机制</h2><p>团队内协作：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222205.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222205.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d800717a8fd6646fbe76a900ada76d3f.png"></p><p>跨团队协作：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222206.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222206.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="33c8072bcaf35e336ebb12e034f28465.png"></p><h1 id="4-GitHub-操作"><a href="#4-GitHub-操作" class="headerlink" title="4. GitHub 操作"></a>4. GitHub 操作</h1><p><a href="https://github.com/">GitHub: Let’s build from here · GitHub</a></p><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/19c000f352889834b8a98f40ad990ff8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/19c000f352889834b8a98f40ad990ff8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="19c000f352889834b8a98f40ad990ff8.png"></p><p>点击加号中的 New repository</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222214.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222214.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3c150df75ceb0cea184dcbac5b12fef2.png"></p><p>输入仓库名后即可创建</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222220.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222220.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e7d3abff4804311ac287c486a958a62d.png"></p><blockquote><p>远程仓库的地址以及连接协议</p></blockquote><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><table><thead><tr><th align="center">命令名称</th><th>作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td align="center">git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td align="center">git remote rm 别名</td><td>删除别名</td></tr><tr><td align="center">git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td align="center">git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td align="center">git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><p>由于远程仓库地址不方便使用，我们可以设置别名：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222224.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222224.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a74b4b812615213c3bd8e521228deba9.png"></p><p>推送本地分支内容时遇到的问题：</p><ol><li>Linux系统中ctrl+v操作会给系统中输入特殊字符^?,偏偏这样的字符在git-bash中又看不到，所以克隆错误的链接就出现了这样报错信息。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 /h/GitSpace (master)</span><br><span class="line">$ git push GitTest master</span><br><span class="line">fatal: protocol &#x27;https&#x27; is not supported</span><br></pre></td></tr></table></figure><blockquote><p>解决方案：删除别名重新设置</p></blockquote><ol start="2"><li>由于没有配置信任的服务器HTTPS验证。默认cURL（一个网络数据传输项目，通常说 cURL 是指 curl 命令行工具）被设为不信任任何CAs，就是说，它不信任任何服务器验证。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 /h/GitSpace (master)</span><br><span class="line">$ git push GitTest master</span><br><span class="line">fatal: unable to access &#x27;https://github.com/LeamonPuer/GitTest.git/&#x27;: SSL certificate problem: unable to get local issuer certificate</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslverify false </span><br></pre></td></tr></table></figure><p>连接远程库会在计算机建立凭据，可以在win10中的凭据管理器中查看</p><h2 id="克隆远程仓库到本地"><a href="#克隆远程仓库到本地" class="headerlink" title="克隆远程仓库到本地"></a>克隆远程仓库到本地</h2><p>在新文件夹中克隆仓库到本地；clone会做三个操作：</p><ol><li>拉取代码</li><li>初始化本地仓库</li><li>创建别名：origin</li></ol><h2 id="邀请加入团队"><a href="#邀请加入团队" class="headerlink" title="邀请加入团队"></a>邀请加入团队</h2><p>点击 Settings 进入此页面：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222227.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222227.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="983e9b633fc3a3e7c4c16a0f6ac4aa04.png"></p><p>点击 Add people：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222230.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222230.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f4c806533887874cd508dd14b1bbd0d9.png"></p><p>在搜索栏搜索用户发送邀请即可（也可以通过其它社交软件发送邀请连接）</p><h2 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><p>将远程仓库的地址复制发给邀请跨团队协作的人，在地址栏输入收到链接后点fork可以叉到自己的本地仓库，修改完成后可以点击 Pull requests请求发送给原团队（对方会审核你修改的代码，可以通过聊天室沟通信息）</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222239.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222239.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b2fac4eb15c81e29d7d170fe7ab3567a.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222245.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222245.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fd50a3d4ee15faa9e3b89544ce95e73c.png"></p><h2 id="SSH免密登录："><a href="#SSH免密登录：" class="headerlink" title="SSH免密登录："></a>SSH免密登录：</h2><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222251.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222251.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="83dcf22e32192a67f34a90f44326bd03.png"></p><p>操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">--进入当前用户的家目录</span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~</span><br><span class="line">$ pwd</span><br><span class="line">/c/Users/16958</span><br><span class="line">--删除.ssh 目录</span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~</span><br><span class="line">$ rm -rvf .ssh/</span><br><span class="line">--运行命令生成.ssh 秘钥目录</span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~</span><br><span class="line">$ ssh-keygen -t rsa -C 1695812011@qq.com</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/16958/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/c/Users/16958/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/16958/.ssh/id_rsa</span><br><span class="line">Your public key has been saved in /c/Users/16958/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:TcOXbMLknWYwaeTcw9w17lsd/IiIpWlzWQDdLg7HYtk 1695812011@qq.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|        .+*o   ..|</span><br><span class="line">|         B+X.+o..|</span><br><span class="line">|         =@./ .+ |</span><br><span class="line">|        =BE@.o..+|</span><br><span class="line">|       .S==.. ..+|</span><br><span class="line">|       . o.     o|</span><br><span class="line">|               . |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~</span><br><span class="line">$ cd .ssh/</span><br><span class="line"></span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~/.ssh</span><br><span class="line">$ ll -a</span><br><span class="line">total 21</span><br><span class="line">drwxr-xr-x 1 16958 197609    0 Dec  3 09:27 ./</span><br><span class="line">drwxr-xr-x 1 16958 197609    0 Dec  3 09:27 ../</span><br><span class="line">-rw-r--r-- 1 16958 197609 2602 Dec  3 09:27 id_rsa</span><br><span class="line">-rw-r--r-- 1 16958 197609  571 Dec  3 09:27 id_rsa.pub</span><br><span class="line"></span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~/.ssh</span><br><span class="line">$ cat id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDKMtpagypeO69I9WbYcWE/n4m7YucClMJv6uFsnBfCY5z6pzGB5F7laIGxwHbij6QE5kGA+9ApD5/2p3Rv72eKfw3xZXLL8NYqkiCyvXTQO7RfR4+Cj2G72RLUXg4WAOd+vOItjZpetL1R+0+1/X0ax3BVK86GQOsxcTAc95BUwllL63/9ttaRTjMZXlCeNdrfrUj+9Jedhnk4jFg2HOkHNljpnAvee6gqzV29hFnUgDBAM6wrf+2zIDLvzT2p3V+E+IXVLlgjNTckepSE5UUbXB5RN9woBSqv44meifwlg+GY+3XlVl8E6cFeXIJNF/IMCxCIhPzN7oCSoBf6J24FwmVT1pUxGSt2MipV8/nlD2BmueoXen9r118fYWd+R7Pt5UgzRa8gxlxmWH5o1iO1vhgLiAR9V4Cs0uuZY5BX5YiYlqop1rUc3nPRF4gmOeX2h/WVUB6dXIq5Cw6aUisbgYsgm7godTwcneazHD4EvatWTFIbhM+H5MiuVMh++PE= 1695812011@qq.com</span><br><span class="line"></span><br><span class="line">16958@DESKTOP-0B9HUJ1 MINGW64 ~/.ssh</span><br><span class="line">$</span><br></pre></td></tr></table></figure><blockquote><p>ssh-keyen 的作用是生成密匙对（公匙和密匙），-t 用来指定加密的类型，-C 后面加一段描述性字符串，网上很多人选择填邮箱，它真正的作用是让我们更好地去区分不同的密匙。</p></blockquote><p>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222301.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222301.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2b23afa652fc4428d7f9165cfe1725bb.png"></p><p>接下来再往远程仓库 push 东西的时候使用 SSH 连接就不需要登录了。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222322.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222322.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6bfec57f7e36e482a9d02c3167707292.png"></p><h1 id="5-IDEA-集成-Git"><a href="#5-IDEA-集成-Git" class="headerlink" title="5. IDEA 集成 Git"></a>5. IDEA 集成 Git</h1><h2 id="配置-Git-忽略文件"><a href="#配置-Git-忽略文件" class="headerlink" title="配置 Git 忽略文件"></a>配置 Git 忽略文件</h2><p>像 idea 中会随工程创建的 .idea 文件以及一些 .iml 文件，与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。</p><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）</p><p>这个文件的存放位置原则上在哪里都可以，为了便于让~&#x2F;.gitconfig 文件引用，建议也放在用 户家目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>在 .gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = Leamon</span><br><span class="line">        email = 1695812011@qq.com</span><br><span class="line">[http]</span><br><span class="line">        sslverify = false</span><br><span class="line">[core]</span><br><span class="line">        excludesfile = C:/Users/16958/git.ignore</span><br><span class="line">#注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）</span><br></pre></td></tr></table></figure><ol><li>定位Git程序</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222328.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222328.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="9168465921c2de450819b7f0400b9581.png"></p><ol start="2"><li>初始化本地库</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/a27a56778b1f7eb689139897a3050b36.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/a27a56778b1f7eb689139897a3050b36.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a27a56778b1f7eb689139897a3050b36.png"></p><ol start="3"><li>添加到暂存区</li></ol><p>初始化本地库后，所有的文件名称都变成了红色，需要我们添加到暂存区</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222337.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222337.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c9b80dd9481e887ec9de0c57f67d2f8a.png"></p><ol start="4"><li>提交到本地库</li></ol><p>添加到暂存区后所有的文件名称会变为绿色，提交本地库的操作也如上图；或使用更方便的窗口</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bce0d8f510e2f22c2ec67800a6d764d9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bce0d8f510e2f22c2ec67800a6d764d9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bce0d8f510e2f22c2ec67800a6d764d9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/1ae5e5dd7f28089ae662b0ea9a426cd0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/1ae5e5dd7f28089ae662b0ea9a426cd0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1ae5e5dd7f28089ae662b0ea9a426cd0.png"></p><p>可以填写提交版本的描述信息，提交后可能会报警告信息，提交失败</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bf11dcb22f32ecaa2f6cdd0f0bfac11a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/bf11dcb22f32ecaa2f6cdd0f0bfac11a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bf11dcb22f32ecaa2f6cdd0f0bfac11a.png"></p><p>我们可以设置不检查代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222359.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222359.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="24cb77427bcaa1df2bb14d6aa68eedf9.png"></p><p>提交完成后，所有文件名都恢复正常颜色</p><p>可以在左下角打开 Git 窗口，切换或查看版本信息</p><ol start="5"><li>创建分支</li></ol><p>可以在窗口栏的 Git 中选择 Branches 或点击右下角的分支名称的 New Branch</p><ol start="6"><li>切换分支</li></ol><p>点击右下角的分支名称选择要切换的分支 Checkout，切换完成后右下角的分支名会改变</p><ol start="7"><li>合并分支</li></ol><p>点击右下角的分支名称选择要合并的分支 Merge into Current，合并到当前分支；代码冲突也都是图形化的界面，比较简单，不再演示</p><h2 id="IDEA-集成-GitHub"><a href="#IDEA-集成-GitHub" class="headerlink" title="IDEA 集成 GitHub"></a>IDEA 集成 GitHub</h2><h3 id="设置-GitHub-账号"><a href="#设置-GitHub-账号" class="headerlink" title="设置 GitHub 账号"></a>设置 GitHub 账号</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222407.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222407.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="dd04ebed0935f89e6495f1969ead4d88.png"></p><blockquote><p>由于网络原因，我们一般不直接使用账号密码登录（在idea上很难登录成功），使用 Token 令牌</p></blockquote><p>进入 GitHub 点击头像的 setting 进入设置界面，点击左方选项栏的最后一个选项：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/88a9592a5ec755f413f89941c0b1e038.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/88a9592a5ec755f413f89941c0b1e038.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="88a9592a5ec755f413f89941c0b1e038.png"></p><p>进入新的界面后又两种个人令牌：beta表示还在测试的功能，我们还是使用经典的个人令牌</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222415.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222415.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="53686259fd9dcea04d87086cca7948a6.png"></p><p>创建个人令牌，是我自己的电脑，就直接设置令牌没有过期时间，权限全开</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222417.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222417.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bf8a78c666e1ed2bda6847a45ba892b5.png"></p><p>完成后会仅显示一次令牌，提前保存好</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222436.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7a4db8b4f1dabe4df0fb3d4b19886b1a.png"></p><blockquote><p>在输入令牌连接时有个小插曲,弹出的证书直接 recept 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalid authentication data ,software caused connetion abort;socket write error</span><br><span class="line">验证数据无效，软件导致连接中断；套接字写入错误</span><br></pre></td></tr></table></figure></blockquote><ol><li>分享工程到 GitHub：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222433.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222433.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8d4d161547bee7c816f555e1835e5b67.png"></p><p>设置别名后直接提交即可，idea会帮我们创建远程库</p><ol start="2"><li>推送本地库到远程库</li></ol><p>由于https协议需要网络条件，我们在使用 push 时使用之前设置的 SSH 连接</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222426.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222426.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bca8a3e44e6e644118d669089d67b779.png"></p><p>注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高！因此在动手改本地代码之前，一定要先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，<strong>切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！</strong></p><ol start="3"><li>拉取远程库到本地库</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222423.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222423.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e1f8de0997149bf1393702404b8a25a0.png"></p><blockquote><p>翻译：将传入的更改合并到当前分支；根据传入的更改重新设置当前分支的基础</p><p>pull 和update project区别：</p><p>git pull 是 git fetch + git merge FETCH_HEAD 的缩写。</p><p>git pull就是先fetch，然后执行merge 操作，如果加<em>—rebase</em>参数，就是使用git rebase 代替git merge。</p><p>Idea update project 就是你可以选择到底是merge 还是 rebase 的git pull</p></blockquote><p>注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p><ol start="4"><li>克隆远程库到本地</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222447.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222447.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="5cf9b0f7e95f37a8ff644c193b540eb7.png"></p><h1 id="6-码云"><a href="#6-码云" class="headerlink" title="6. 码云"></a>6. 码云</h1><p>众所周知，GitHub 服务器在国外，使用不是特别方便。</p><p>码云是开源中国推出的基于 Git 的代码托管服务中心，使用 方式跟 GitHub 一样，而且还是一个中文网站，如果你英文不是很好它是最好的选择。</p><p><a href="https://gitee.com/">Gitee - 基于 Git 的代码托管和研发协作平台</a></p><p>Gitee 支持绑定 GitHub、QQ等，由于是中文界面，就不多做介绍了</p><h2 id="idea-集成码云"><a href="#idea-集成码云" class="headerlink" title="idea 集成码云"></a>idea 集成码云</h2><p>idea 默认不带码云插件，我们第一步要安装 Gitee 插件。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222452.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222452.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ec87aac1b4f8a7792a64cb1ef3e89708.png"></p><blockquote><p>云服务器在国内，用 HTTPS 链接即可，没必要用 SSH 免密链接。</p><p>码云提供了直接复制 GitHub 项目的功能，方便我们做项目的迁移和下载。</p></blockquote><p>具体上传下载等操作没有太大区别，不再赘述</p><h1 id="7-GitLab"><a href="#7-GitLab" class="headerlink" title="7. GitLab"></a>7. GitLab</h1><p>GitLab 是一个使用 MIT 许可证的基于网络的 Git 仓库管理工具，具有 wiki 和 issue 跟踪功能，使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。</p><p><a href="https://about.gitlab.com/">The One DevOps Platform | GitLab</a></p><p>官网进不去，这里直接使用<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><ol><li>安装脚本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh /mnt/hgfs/EdgeDown/git/资料/gitlab-ce-15.6.1-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server cronie</span><br><span class="line"></span><br><span class="line">sudo lokkit -s http -s ssh</span><br><span class="line"></span><br><span class="line">sudo yum install -y postfix</span><br><span class="line"></span><br><span class="line">sudo service postfix start</span><br><span class="line"></span><br><span class="line">sudo chkconfig postfix on</span><br><span class="line"></span><br><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; yum -y install gitlab-ce</span><br></pre></td></tr></table></figure><blockquote><p>这里我没有远程传输文件，使用了共享文件夹，这里有个坑，Windows下文件夹命名有个空格，路径容易错，改回来</p><p>yum 安装时会检测更新，最好在镜像网站中下载最新版，否则下载巨慢，或许可以修改网络 YUM 源</p><p>如果脚本安装有问题可以先更新一下sudo工具并安装以下lokkit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install sudo</span><br><span class="line">yum install lokkit</span><br></pre></td></tr></table></figure><p>安装过程中可能还有一些小问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br><span class="line">另一个应用程序是：PackageKit</span><br><span class="line">    内存： 31 M RSS （451 MB VSZ）</span><br><span class="line">    已启动： Wed Aug 17 09:08:40 2022 - 00:59之前</span><br><span class="line">    状态：睡眠中，进程ID：2833</span><br><span class="line"> (可能是系统自动升级正在运行，yum在锁定状态中，要等待那个进程结束退出)</span><br><span class="line">解决办法：</span><br><span class="line">1.ps aux | grep yum (查询有关yum的进程进行关闭)</span><br><span class="line">命令：kill -s 9 2833 pid</span><br><span class="line">2.rm -f /var/run/yum.pid (强制关掉yum进程，并重新运行yum)</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>初始化 GitLab 服务：</li></ol><p>安装完成后（脚本执行完毕），可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><blockquote><p>显示 gitlab Reconfigured! 表示初始化成功<br>（2g运行内存，4个核心，20g空间）</p></blockquote><ol start="3"><li>启动 GitLab 服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><ol start="4"><li>访问 GitLab</li></ol><p>直接在浏览器的地址栏中输入IP地址即可访问（虚拟机必须要关闭防火墙）</p><p>第一次访问需要输入账号密码，账号默认 root，密码需要在 &#x2F;etc&#x2F;gitlab&#x2F;initial_root_password 中查看（该文件24小时后自动删除！）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# cat /etc/gitlab/initial_root_password</span><br><span class="line"># WARNING: This value is valid only in the following conditions</span><br><span class="line">#          1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environmen, it was provided before database was seeded for the first time (usually, the fi#          2. Password hasn&#x27;t been changed manually, either via UI or via command line.</span><br><span class="line">#</span><br><span class="line">sword following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.</span><br><span class="line"></span><br><span class="line">Password: kQHoxSzX4lmhfyGB9QhABvOIMjHUUJo/jtgj0HFnUAQ=</span><br><span class="line"># NOTE: This file will be automatically deleted in the first </span><br></pre></td></tr></table></figure><blockquote><p>根据该文件提供的密码可以实现第一次登录，当然这个密码太长</p></blockquote><p>修改密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rails console -e production</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222500.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222500.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a5dae567906092f8954119d5dc2d3380.png"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;user = User.where(id: 1).first #查看id为1的账号</span><br><span class="line">&gt;或者 user = User.where(name:&quot;root&quot;).first</span><br><span class="line"></span><br><span class="line">&gt;user.password=&#x27;123456789&#x27; #修改密码为12345678</span><br><span class="line">&gt;user.password_confirmation=&#x27;123456789&#x27; #确认密码</span><br><span class="line">&gt;user.save! #保存</span><br><span class="line">&gt;quit #退出‘’</span><br></pre></td></tr></table></figure></blockquote><p>IDEA 集成 GitLab 需要安装 GitLab 插件</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222503.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006222503.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e3647150143b97be953df3d9fae6cf18.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/09/17/%E5%B7%A5%E5%85%B7/Maven/"/>
      <url>/2023/09/17/%E5%B7%A5%E5%85%B7/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Maven-简介"><a href="#1-Maven-简介" class="headerlink" title="1. Maven 简介"></a>1. Maven 简介</h1><p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供<strong>构建</strong>和<strong>依赖</strong>管理支持的工具。</p><h2 id="Maven-作为依赖管理工具"><a href="#Maven-作为依赖管理工具" class="headerlink" title="Maven 作为依赖管理工具"></a>Maven 作为依赖管理工具</h2><p>随着框架的封装程度越来越高，项目中使用的jar包也越来越多。jar 包所属技术的官网通常是英文界面，网站的结构又不尽相同，甚至需要通过特殊的工具下载。第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。</p><ul><li>jar包的名称</li><li>jar包的版本</li><li>jar包内的具体细节</li></ul><p>使用 Maven 后，依赖对应的 jar 包能够<strong>自动下载</strong>，方便、快捷又规范。</p><p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p><p>使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li>jar 包之间的依赖：通过依赖的传递性自动完成</li><li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul><h2 id="Maven-作为构建管理工具"><a href="#Maven-作为构建管理工具" class="headerlink" title="Maven 作为构建管理工具"></a>Maven 作为构建管理工具</h2><p>当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。脱离 IDE 环境仍需构建</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221241.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221241.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="00666aca63d45807532bd4dfc0a3e51d.png"></p><p>构建过程包含的主要的环节：</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java 源程序编译成 *.class 字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库</li><li>部署<ul><li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li><li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li></ul></li></ul><h1 id="2-Maven-环境配置"><a href="#2-Maven-环境配置" class="headerlink" title="2. Maven 环境配置"></a>2. Maven 环境配置</h1><p>下载界面：<a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a></p><p>其中 tar.gz 是Linux系统使用的版本，zip是Windows适用版本，source表示可以看源码</p><p>需要将下载的核心程序压缩包解压到非中文、无空格的目录，在解压目录中，我们主要关注Maven的核心配置文件：<strong>conf&#x2F;settings.xml</strong></p><ol><li>指定本地仓库：</li></ol><p>本地仓库默认值：用户的家目录&#x2F;.m2&#x2F;repository。家目录往往是C盘，建议将Maven的本地仓库放在其他盘符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>H:\Maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置阿里云提供的镜像仓库</li></ol><p>Maven 下载 jar 包默认访问境外的中央仓库。改成阿里云提供的镜像仓库，可以让 Maven 下载 jar 包的时候速度更快。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置 Maven 工程的基础 JDK 版本</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>检查 JAVA_HOME 配置是否正确</li></ol><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p>可以在命令行中使用指令验证：echo %JAVA_HOME%</p><ol start="5"><li>配置 Path 环境变量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221253.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221253.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1da20272411bc458f01ee4fa5c0c7c6b.png"><br><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/6bcaf916419fa52d222b2ecaa5345f57.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/6bcaf916419fa52d222b2ecaa5345f57.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6bcaf916419fa52d222b2ecaa5345f57.png"></p><blockquote><p>配置环境变量的规律：<br>XXX_HOME 通常指向的是 bin 目录的上一级<br>PATH 指向的是 bin 目录</p></blockquote><p>可以在命令行中使用指令验证：mvn -v</p><h1 id="3-概念引入"><a href="#3-概念引入" class="headerlink" title="3. 概念引入"></a>3. 概念引入</h1><h2 id="核心概念：坐标"><a href="#核心概念：坐标" class="headerlink" title="核心概念：坐标"></a>核心概念：坐标</h2><p>在数学中可以使用x,y,z三个向量作为坐标系确定空间中唯一的点；Maven中也可以使用三个向量在 Maven 仓库中定位一个 jar 包</p><ul><li><strong>groupId</strong>：公司或组织的 id</li><li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li><li><strong>version</strong>：版本号</li></ul><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的 jar 包在 Maven 本地仓库中的位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><h3 id="使用命令生成Maven工程"><a href="#使用命令生成Maven工程" class="headerlink" title="使用命令生成Maven工程"></a>使用命令生成Maven工程</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221328.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221328.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2bbd24c273f1126b172e20025a5bda1e.png"></p><p>运行 <strong>mvn archetype:generate</strong> 命令后：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;groupId&#x27;: com.test</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;artifactId&#x27;: pro01</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;package&#x27; com.test: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Confirm properties configuration: groupId: com.test artifactId: pro01 version: 1.0-SNAPSHOT package: com.test Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】</span><br></pre></td></tr></table></figure><blockquote><p>version 中的 SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本；RELEASE 表示正式版本</p></blockquote><p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们改成较适合的 4.12 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="核心概念：POM"><a href="#核心概念：POM" class="headerlink" title="核心概念：POM"></a>核心概念：POM</h2><p>POM：Project Object Model，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p><p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p><h2 id="核心概念：约定的目录结构"><a href="#核心概念：约定的目录结构" class="headerlink" title="核心概念：约定的目录结构"></a>核心概念：约定的目录结构</h2><p>Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221355.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221355.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8fe7dfd5c9e429285137b6ebf45105fc.png"></p><p>另外还有一个 target 目录专门存放构建操作输出的结果。</p><p>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p><p>目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。</p><h2 id="执行-Maven-的构建命令"><a href="#执行-Maven-的构建命令" class="headerlink" title="执行 Maven 的构建命令"></a>执行 Maven 的构建命令</h2><p>运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。</p><blockquote><p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。</p></blockquote><ul><li><p>mvn clean：清理操作；删除 target 目录</p></li><li><p>主程序编译：mvn compile</p><p>主体程序编译结果存放的目录：target&#x2F;classes</p></li><li><p>测试程序编译：mvn test-compile</p><p>测试程序编译结果存放的目录：target&#x2F;test-classes</p></li><li><p>mvn test：测试操作</p><p>测试的报告存放的目录：target&#x2F;surefire-reports</p></li><li><p>mvn install</p><p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p></li></ul><blockquote><p>安装操作会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></blockquote><h2 id="创建-Maven-版的-Web-工程"><a href="#创建-Maven-版的-Web-工程" class="headerlink" title="创建 Maven 版的 Web 工程"></a>创建 Maven 版的 Web 工程</h2><p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。</p><p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程</p><p>生成工程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure><p>参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。</p><p>运行完指令后的操作和创建普通工程雷同，也是输入工程的坐标</p><p>生成的 pom.xml 文件中默认的打包方式是 war</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以将运行 mvn package 命令后生成 war 包复制到 Tomcat&#x2F;webapps 目录下运行</p><h2 id="让-Web-工程依赖-Java-工程"><a href="#让-Web-工程依赖-Java-工程" class="headerlink" title="让 Web 工程依赖 Java 工程"></a>让 Web 工程依赖 Java 工程</h2><p>只有 Web 工程依赖 Java 工程，没有 Java 工程依赖 Web 工程。本质上来说，Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包。执行打包命令后， Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF&#x2F;lib 目录下。</p><ul><li>mvn dependency:list：查看当前 Web 工程所依赖的 jar 包的列表</li><li>mvn dependency:tree：以树形结构查看当前 Web 工程的依赖信息</li></ul><p>显示格式：groupId:artifactId:打包方式:version:依赖的范围</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>标签的位置：dependencies&#x2F;dependency&#x2F;<strong>scope</strong></p><p>标签的可选值：<strong>compile</strong>&#x2F;<strong>test</strong>&#x2F;<strong>provided</strong>&#x2F;system&#x2F;runtime&#x2F;<em>import</em></p><table><thead><tr><th align="center">范围</th><th align="center">main目录（空间）</th><th align="center">test目录（空间）</th><th align="center">开发过程（时间）</th><th align="center">部署到服务器（时间）</th></tr></thead><tbody><tr><td align="center">compile（默认值）</td><td align="center">有效</td><td align="center">有效</td><td align="center">有效</td><td align="center">有效</td></tr><tr><td align="center">test</td><td align="center">无效</td><td align="center">有效</td><td align="center">有效</td><td align="center">无效</td></tr><tr><td align="center">provided</td><td align="center">有效</td><td align="center">有效</td><td align="center">有效</td><td align="center">无效</td></tr></tbody></table><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。</p><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>原则：在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>配置依赖的排除其实就是阻止某些 jar 包的传递，避免 jar 包传递过来和其他 jar 包冲突。</p><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Maven工程之间，A 工程(子工程)继承 B 工程(父工程)</p><p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p><p>可以在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p><p>创建父工程：和pro01一样，创建好后，需要修改打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p></blockquote><p>创建子工程：在父工程的根目录（与src目录同级）运行指令</p><p>创建完成后，父工程和子工程的pom.xml文件都会有修改</p><p>父工程：modules 和 module 标签是聚合功能的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test.com<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;test.com&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure><p>父工程中配置依赖的统一管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程中引用被父工程管理的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父工程声明自定义属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">test.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 真正实现“一处修改，处处生效”。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;test.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p><p>概念的对应关系：</p><p>从继承关系角度来看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合关系角度来看：</p><ul><li>总工程</li><li>模块工程</li></ul><p>好处：</p><ul><li><p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p><p>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p></li><li><p>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。</p></li></ul><p>依赖循环问题：</p><p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报错：循环引用</p><h1 id="4-IDEA环境使用Maven"><a href="#4-IDEA环境使用Maven" class="headerlink" title="4. IDEA环境使用Maven"></a>4. IDEA环境使用Maven</h1><p>创建Project时使用Maven创建<br><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221412.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221412.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="4f801b79196fd68d1f17d1e6dc55c45a.png"></p><p>一般不勾选idea自动生成的，直接点next，在新窗口中确定工程坐标的三个向量。</p><p>创建Project 后，DEA 会自动弹出提示，我们选择『Enable Auto-Import』，意思是启用自动导入。因为 Project、Module 新创建或 pom.xml 每次修改时都应该让 IDEA 重新加载 Maven 信息。这对 Maven 目录结构认定、Java 源程序编译、依赖 jar 包的导入都有非常关键的影响。</p><h2 id="配置Maven信息"><a href="#配置Maven信息" class="headerlink" title="配置Maven信息"></a>配置Maven信息</h2><p>每次创建 Project 后都需要设置 Maven 家目录位置，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221417.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221417.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="93da6bba5c74cd9d36fabea945ea1730.png"></p><p>创建Web模块工程：</p><p>和创建普通Java工程步骤一样，在创建完成后需要添加web工程，注意需要修改web.xml的路径：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221425.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221425.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d4e39af1d831f0ad00291217787622c4.png"></p><p>其中 src\main\webapp 时按照Maven工程的目录结构设置</p><p>为了防止每次创建工程idea默认在c盘创建本地库，可以在idea自带Maven的settings.xml做修改</p><h2 id="在idea中执行Maven命令"><a href="#在idea中执行Maven命令" class="headerlink" title="在idea中执行Maven命令"></a>在idea中执行Maven命令</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d8599f5a151d4b8e3cb6dbfca00d779e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/d8599f5a151d4b8e3cb6dbfca00d779e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d8599f5a151d4b8e3cb6dbfca00d779e.png"><br><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221438.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006221438.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="de18e16d0c91ea494f097d7c4c0b6bca.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符</span></span><br><span class="line"><span class="comment"># maven.test.skip=true 表示在执行命令的过程中跳过测试</span></span><br><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="5-其它核心概念"><a href="#5-其它核心概念" class="headerlink" title="5. 其它核心概念"></a>5. 其它核心概念</h1><ol><li>生命周期：</li></ol><p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p><table><thead><tr><th align="center">生命周期名称</th><th>作用</th><th>各个环节</th></tr></thead><tbody><tr><td align="center">Clean</td><td>清理操作相关</td><td>pre-clean clean post-clean</td></tr><tr><td align="center">Site</td><td>生成站点相关</td><td>pre-site site post-site deploy-site</td></tr><tr><td align="center">Default</td><td>主要构建过程</td><td>validate<br>generate-sources<br/>process-sources<br/>generate-resources<br/>process-resources 复制并处理资源文件，至目标目录，准备打包。<br/>compile 编译项目 main 目录下的源代码。<br/>process-classes<br/>generate-test-sources<br/>process-test-sources<br/>generate-test-resources<br/>process-test-resources 复制并处理资源文件，至目标测试目录。<br/>test-compile 编译测试源代码。<br/>process-test-classes<br/>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br/>prepare-package<br/>package 接受编译好的代码，打包成可发布的格式，如JAR。<br/>pre-integration-test<br/>integration-test<br/>post-integration-test<br/>verify<br/>install 将包安装至本地仓库，以让其它项目依赖。<br/>deploy 将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。</td></tr></tbody></table><ul><li>前面三个生命周期彼此是独立的。</li><li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。</li></ul><ol start="2"><li>插件和目标：</li></ol><p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p><ol start="3"><li>仓库：</li></ol><ul><li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li><li>远程仓库：需要联网<ul><li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li><li>Internet<ul><li>中央仓库</li><li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li></ul></li></ul></li></ul><p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="/2023/09/10/%E6%A1%86%E6%9E%B6/4.MyBatisPlus/"/>
      <url>/2023/09/10/%E6%A1%86%E6%9E%B6/4.MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyBatisPlus-简介"><a href="#1-MyBatisPlus-简介" class="headerlink" title="1. MyBatisPlus 简介"></a>1. MyBatisPlus 简介</h1><p>MyBatis-Plus(简称 MP)，是一个 MyBatis 的增强工具包，只做增强不做改变。 为简化开发工作、提高生产率而生</p><p>官方地址：<a href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p><p>框架结构：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135349.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135349.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7c1899af523d77430b7db578523b1c66.png"></p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>使用 Spring Initializr 快速初始化一个 Spring Boot 工程</p><p>配置数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;useSSL=false</span></span><br></pre></td></tr></table></figure><p>创建mapper并添加扫描路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseMapper是MyBatis-Plus提供的模板mapper</span></span><br><span class="line"><span class="comment">//其中包含了基本的CRUD方法，泛型为操作的实体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Buser&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com/demo/mybatisplus/mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyBatisPlus 底层使用了雪花算法，可能会超出integer的范围，所以主键id最好使用 BIGINT 和 Long </p></blockquote><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Buser&gt; list = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring只会将实体类放入容器，当我们导入userMapper时会编译报错</p><p>Wrapper条件构造器，可针对于SQL语句设置不同的条件，若没有条件，则可以为该形参赋值null，即查询（删除&#x2F;修改）所有数据</p></blockquote><p>我们能看到查询的结果但看不到查询的SQL语句，我们可以配置日志输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><blockquote><p>这个是自带的日志</p></blockquote><h1 id="2-基本CURD"><a href="#2-基本CURD" class="headerlink" title="2. 基本CURD"></a>2. 基本CURD</h1><p>前面已经提到，MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Buser</span> <span class="variable">buser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buser</span>(<span class="literal">null</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;xm@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.insert(buser);</span><br><span class="line">    System.out.printf(<span class="string">&quot;%d,%s&quot;</span>,i,buser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>%d：按整型数据的实际长度输出；%s：输出字符串</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135829.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135829.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="19791af68214d7c8f3f04715e00f708b.png"></p><blockquote><p>MyBatis-Plus 底层默认使用雪花算法来创建id</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//DELETE FROM buser WHERE id=?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1321287682</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批量删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过多个id批量删除</span></span><br><span class="line">    <span class="comment">//DELETE FROM buser WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">idList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(idList);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过map条件删除记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据map集合中所设置的条件删除记录</span></span><br><span class="line">    <span class="comment">//DELETE FROM buser WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//UPDATE buser SET name=?, password=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">Buser</span> <span class="variable">buser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buser</span>(<span class="number">604000258</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;112233&quot;</span>, <span class="string">&quot;xm@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(buser);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>底层是根据主键(id)查询的</p></blockquote><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查询用户信息：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM buser WHERE id=?</span></span><br><span class="line">    <span class="type">Buser</span> <span class="variable">buser</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据多个id查询多个用户信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM buser WHERE id IN ( ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; idList = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    List&lt;Buser&gt; list = userMapper.selectBatchIds(idList);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过map条件查询用户信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过map条件查询用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM buser WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    List&lt;Buser&gt; list = userMapper.selectByMap(map);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a>Service CRUD 接口</h2><p>官方说明：</p><ul><li>通用 Service CRUD 封装 IService 接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>泛型 <code>T</code> 为任意实体对象</li></ul><p>MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑</p><p>自定义接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserService继承IService模板提供的基础功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ServiceImpl实现了IService，提供了IService中基础功能的实现</span></span><br><span class="line"><span class="comment">   若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="comment">//查询记录数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量插入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// SQL长度有限制，海量数据插入单条SQL无法实行，</span></span><br><span class="line">    <span class="comment">// 因此MP将批量插入放在了通用Service中实现，而不是通用Mapper</span></span><br><span class="line">    ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;asd&quot;</span> + i);</span><br><span class="line">        user.setAge(<span class="number">20</span> + i);</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//INSERT INTO buser ( username, age ) VALUES ( ?, ? )</span></span><br><span class="line">    userService.saveBatch(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h1><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>MyBatis-Plus操作的表由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致(无视大小写)</p><p>当我们的实体类名与数据表不同时我们可以使用 @TableName 注解指定表名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;..&#125;</span><br></pre></td></tr></table></figure><p>如果很多表都具有相同的前缀，我们可以在全局配置中设定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><p>MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</p><p>若实体类中表示主键的不是id，而是其他字段，例如uid等，程序会抛出异常</p><p>我们可以通过@TableId指定表的主键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解相当于一个映射，告诉MyBatis-Plus该属性对应表中主键 id，如果表中主键名不为id如 uid，我们需要在@TableId的value中注明 <code>@TableId(&quot;uid&quot;)</code></p><h4 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h4><p>type属性用来定义主键策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(value=&quot;id&quot;,type = IdType.AUTO)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">值</th><th>描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默 认）</td><td>基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td>使用数据库的自增策略，注意，该类型请确保数据库设置了id自增， 否则无效</td></tr></tbody></table><p>我们也可以在全局配置中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>背景：</p><p>需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。</p><p>数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。</p><p>数据库分表；单表数据拆分有两种方式：</p><ul><li>垂直分表<ul><li>适合将表中某些不常用且占了大量空间的列拆分出去。</li></ul></li><li>水平分表<ul><li>水平分表适合表行数特别大的表。水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理</li></ul></li></ul><ol><li>主键自增：</li></ol><p>复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。</p><p>优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。</p><p>缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而另外一个分段实际存储的数据量有 1000 万条。</p><ol start="2"><li>取模：</li></ol><p>例如简单地用 user_id % 10 的值来 表示数据所属的数据库表编号</p><p>复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。</p><p>优点：表分布比较均匀。 </p><p>缺点：扩充新的表很麻烦，所有数据都要重分布。</p><ol start="3"><li>雪花算法</li></ol><p>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。 </p><p>核心思想： 长度共64bit（一个long型）。 </p><ul><li>首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。 </li><li>41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。 </li><li>10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。 </li><li>12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</li></ul><p>优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h3><p>MyBatis-Plus在执行SQL语句时，也要保证实体类中的属性名和表中的字段名一致</p><ul><li>情况1：</li></ul><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格。此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格</p><ul><li>情况2</li></ul><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h3><ul><li>物理删除：将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库 中仍旧能看到此条数据记录</li></ul><p>数据库中创建逻辑删除状态列，设置默认值为0；实体类中添加逻辑删除属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer isDeleted</span><br></pre></td></tr></table></figure><p>设置了该属性后，我们执行删除功能其实是执行的 update 语句，查询数据时也会自动加上<code>WHERE is_deleted=0</code></p><h1 id="4-条件构造器和常用接口"><a href="#4-条件构造器和常用接口" class="headerlink" title="4. 条件构造器和常用接口"></a>4. 条件构造器和常用接口</h1><p>wapper介绍</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135904.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="01e2cbf7334c9847336b25497294100a.png"></p><ul><li>Wrapper ： 条件构造抽象类，最顶端父类 <ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 </li><li>QueryWrapper ： 查询条件封装 </li><li>UpdateWrapper ： Update 条件封装 </li><li>AbstractLambdaWrapper ： 使用Lambda 语法 <ul><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper </li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul></li></ul></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，并且邮箱不为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>).isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和Mybatis中的Example挺像</p></blockquote><p>条件优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;user@123.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    <span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;user@123.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装select子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询用户信息的name和age字段</span></span><br><span class="line">    <span class="comment">//SELECT name,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = uerMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询id小于等于3的用户信息</span></span><br><span class="line">    <span class="comment">//SELECT * FROM t_user WHERE (id IN (select id from user where id &lt;= 3))</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 3&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p>和QueryWrapper中的方法都差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    UpdateWrapper&lt;Buser&gt; uw = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    uw.ne(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    uw.set(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, uw);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相较而言，UpdateWrapper省去了我们创建对象填充数据的过程</p></blockquote><h3 id="条件组装"><a href="#条件组装" class="headerlink" title="条件组装"></a>条件组装</h3><p>组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义查询条件，有可能为null（用户未输入或未选择）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0</span></span><br><span class="line">    <span class="comment">//且不由空白符(whitespace)构成</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(name))&#123;</span><br><span class="line">        queryWrapper.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageBegin != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageEnd != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SELECT * FROM t_user WHERE (age &gt;= ? AND age &lt;= ?)</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringUtils 是 MyBatisPlus 包中的，别导错了</p></blockquote><p>MyBatisPlus 为我们提供了带condition参数的重载方法构建查询条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08UseCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义查询条件，有可能为null（用户未输入或未选择）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(StringUtils.isNotBlank(name), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    <span class="comment">//SELECT * FROM t_user WHERE (age &gt;=? AND age &lt;= ?)</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义查询条件，有可能为null（用户未输入）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//避免使用字符串表示字段，防止运行时错误</span></span><br><span class="line">    queryWrapper</span><br><span class="line">        .like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a>LambdaUpdateWrapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//组装set子句</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper</span><br><span class="line">        .set(User::getAge, <span class="number">18</span>)</span><br><span class="line">        .set(User::getEmail, <span class="string">&quot;user@atguigu.com&quot;</span>)</span><br><span class="line">        .like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.lt(User::getAge, <span class="number">24</span>).or().isNull(User::getEmail)); <span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h2><p>我们可以在日常开发中使用MyBatisPlus框架提供的Wrappers类优雅地实现我们的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AuditWhiteList</span> <span class="variable">result</span> <span class="operator">=</span> mapper.selectOne(Wrappers.lambdaQuery(<span class="keyword">new</span> <span class="title class_">AuditWhiteList</span>().setId(<span class="number">10L</span>)));</span><br><span class="line"><span class="comment">//复杂写法</span></span><br><span class="line"><span class="type">AuditWhiteList</span> <span class="variable">result</span> <span class="operator">=</span> mapper.selectOne(Wrappers.&lt;AuditWhiteList&gt;lambdaQuery().eq(AuditWhiteList::getId,<span class="number">10L</span>));</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">List&lt;AuditWhiteList&gt; list = auditWhiteListMapper.selectList(Wrappers.lambdaQuery(AuditWhiteList.class)</span><br><span class="line">                        .in(AuditWhiteList::getProfessionId,ids));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-插件"><a href="#5-插件" class="headerlink" title="5. 插件"></a>5. 插件</h1><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;Buser&gt; page=<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示的条数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xml自定义分页"><a href="#xml自定义分页" class="headerlink" title="xml自定义分页"></a>xml自定义分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据年龄查询用户列表，分页显示</span></span><br><span class="line"><span class="comment">* page 分页对象,xml从里面进行取值;传递参数 Page 即自动分页,必须放在第一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">myPage</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SQL片段，记录基础字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Columns&quot;</span>&gt;</span>id,name,age,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--IPage&lt;User&gt; selectPageVo(Page&lt;User&gt; page, Integer age);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Columns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> FROM user WHERE age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置扫描JavaBean包：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus.type-aliases-package</span>=<span class="string">com.demo.mybatisplus.pojo</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul><li>乐观锁：多人同时修改同一条数据，只有第一次的提交生效</li><li>悲观锁：事务提交前，其他人都无法修改</li></ul><p>乐观锁实现流程：数据库中添加version字段，更新时，version + 1，如果提交时的version版本不对，则更新失败</p><p>Mybatis-Plus实现乐观锁：@Version</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加乐观锁插件配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h3><p>表中的有些字段值是固定的，例如性别，此时我们可以使用MyBatis-Plus的通用枚举来实现：@EnumValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="comment">//会将@EnumValue注解所标识的属性值存储到数据库</span></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置扫描通用枚举：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus.type-enums-package</span>=<span class="string">com.demo.mybatisplus.enums</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSexEnum</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Enum&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//设置性别信息为枚举项，会将@EnumValue注解所标识的属性值存储到数据库</span></span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="comment">//INSERT INTO user ( username, age, sex ) VALUES ( ?, ?, ? )</span></span><br><span class="line">    <span class="comment">//Parameters: Enum(String), 20(Integer), 1(Integer)</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-代码生成器"><a href="#6-代码生成器" class="headerlink" title="6. 代码生成器"></a>6. 代码生成器</h1><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>快速生成配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCodeGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取当前Java进程的工作目录;当前项目的绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用类加载器加载配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> MyCodeGenerator.class.getClassLoader().getResourceAsStream(<span class="string">&quot;mybatisPlus.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        prop.load(input);</span><br><span class="line"></span><br><span class="line">        FastAutoGenerator.create(prop.getProperty(<span class="string">&quot;codeGenerator.url&quot;</span>), prop.getProperty(<span class="string">&quot;codeGenerator.username&quot;</span>), prop.getProperty(<span class="string">&quot;codeGenerator.password&quot;</span>))</span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;Lemon&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                            <span class="comment">// .enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                            .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">                            .disableOpenDir()<span class="comment">// 不要打开资源管理器</span></span><br><span class="line">                            .outputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>); <span class="comment">// 指定输出目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 策略配置</span></span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_train_courses&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_train_&quot;</span>)<span class="comment">// 设置过滤表前缀</span></span><br><span class="line">                            .serviceBuilder()</span><br><span class="line">                            .formatServiceFileName(<span class="string">&quot;%sService&quot;</span>)<span class="comment">// 去掉service文件前面的i，%s会自动填充对象名</span></span><br><span class="line">                            .entityBuilder()</span><br><span class="line">                            <span class="comment">// 使用Lombok注解并开启链式</span></span><br><span class="line">                            .enableLombok()</span><br><span class="line">                            .enableChainModel()</span><br><span class="line">                            .enableRemoveIsPrefix()<span class="comment">// 类型字段移除 is 前缀</span></span><br><span class="line">                            .enableTableFieldAnnotation()<span class="comment">// 开启生成实体时生成字段注解</span></span><br><span class="line">                            .naming(NamingStrategy.underline_to_camel) <span class="comment">// 数据库表映射到实体的命名策略</span></span><br><span class="line">                            .columnNaming(NamingStrategy.underline_to_camel); <span class="comment">// 数据库表字段映射到实体的命名策略</span></span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                            <span class="comment">// 这里是设置各个文件类型的包名</span></span><br><span class="line">                            .xml(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                            .entity(<span class="string">&quot;domain&quot;</span>)</span><br><span class="line">                            .mapper(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                            .service(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">                            .controller(<span class="string">&quot;controller&quot;</span>)</span><br><span class="line">                            .moduleName(<span class="string">&quot;codeGenerator&quot;</span>); <span class="comment">// 设置父包模块名);</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .injectionConfig(builder -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 自定义配置Map</span></span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 修改typeConvert属性</span></span><br><span class="line">                    map.put(<span class="string">&quot;typeConvert&quot;</span>, <span class="keyword">new</span> <span class="title class_">MySqlTypeConvert</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> IColumnType <span class="title function_">processTypeConvert</span><span class="params">(GlobalConfig config, String fieldType)</span> &#123;</span><br><span class="line">                            <span class="comment">// 打印数据库字段类型，用于验证是否触发了自定义类型转换逻辑</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;Database Field Type: &quot;</span> + fieldType);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将数据库的datetime类型映射为Java的Date类型</span></span><br><span class="line">                            <span class="keyword">if</span> (fieldType.equalsIgnoreCase(<span class="string">&quot;datetime&quot;</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;Mapping to Java Date Type&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span> DbColumnType.DATE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (fieldType.equalsIgnoreCase(<span class="string">&quot;tinyint&quot;</span>)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> DbColumnType.INTEGER;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.processTypeConvert(config, fieldType);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    builder.customMap(map);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">                .templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>())</span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>目前不清楚怎么指定MySQL对应Java数据的映射怎么修改</p></blockquote><p>记录遇到一个小Bug，MySQL中字段名是关键字，在调用MyBatisPlus的方法时直接报错，解决方案：在注解处加``</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_train_courses&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Courses</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 课程简介</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(&quot;`describe`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String describe;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交互式生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FastAutoGenerator.create(DATA_SOURCE_CONFIG)</span><br><span class="line">    <span class="comment">// 全局配置</span></span><br><span class="line">    .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(<span class="string">&quot;请输入作者名称？&quot;</span>)).fileOverride())</span><br><span class="line">    <span class="comment">// 包配置</span></span><br><span class="line">    .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(<span class="string">&quot;请输入包名？&quot;</span>)))</span><br><span class="line">    <span class="comment">// 策略配置</span></span><br><span class="line">    .strategyConfig((scanner, builder) -&gt; builder.addInclude(getTables(scanner.apply(<span class="string">&quot;请输入表名，多个英文逗号分隔？所有输入 all&quot;</span>)))</span><br><span class="line">                    .controllerBuilder().enableRestStyle().enableHyphenStyle()</span><br><span class="line">                    .entityBuilder().enableLombok().addTableFills(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Column</span>(<span class="string">&quot;create_time&quot;</span>, FieldFill.INSERT)</span><br><span class="line">                    ).build())</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker</span></span><br><span class="line"><span class="comment">       .templateEngine(new BeetlTemplateEngine())</span></span><br><span class="line"><span class="comment">       .templateEngine(new FreemarkerTemplateEngine())</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    .execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 all 情况</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getTables</span><span class="params">(String tables)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;all&quot;</span>.equals(tables) ? Collections.emptyList() : Arrays.asList(tables.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-多数据源"><a href="#7-多数据源" class="headerlink" title="7. 多数据源"></a>7. 多数据源</h1><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置多数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># 配置数据源信息</span></span><br><span class="line"> <span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">dynamic:</span></span><br><span class="line"><span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">   <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">   <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">     <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">     <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">     <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">slave_1:</span></span><br><span class="line"> <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"> <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"> <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"> <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>在创建Service的实现类时，我们需要指明操作的数据库：@DS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定所操作的数据源</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@DS 也可以加在方法上实现读写分离：将写操作方法加上主库数据源，读操作方法加上从库数据源，自动切换</p></blockquote><h1 id="8-MyBatisX-插件"><a href="#8-MyBatisX-插件" class="headerlink" title="8. MyBatisX 插件"></a>8. MyBatisX 插件</h1><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生</p><p><a href="https://baomidou.com/pages/ba5b24/#%E5%8A%9F%E8%83%BD">MybatisX快速开发插件 | MyBatis-Plus (baomidou.com)</a></p><h2 id="快速生成代码"><a href="#快速生成代码" class="headerlink" title="快速生成代码"></a>快速生成代码</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135935.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="112ddff2e3942dee8a91acd235e82df6.png"></p><p>直接点击就可以快速生成代码</p><p>MyBatisX还帮我们创建了很多模板：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/f27ca2b2888f9b53dc609dc3d36ed3f0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/f27ca2b2888f9b53dc609dc3d36ed3f0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f27ca2b2888f9b53dc609dc3d36ed3f0.png"></p><p>alt+enter 还能帮我们创建好mapper映射中的SQL语句</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135943.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230903135943.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="822a8d3dd9acb4286f59d31392aaf43f.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/09/03/%E6%A1%86%E6%9E%B6/3.MyBatis/"/>
      <url>/2023/09/03/%E6%A1%86%E6%9E%B6/3.MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1. MyBatis简介"></a>1. MyBatis简介</h1><p>MyBatis最初是Apache的一个开源项目iBatis，iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。 </p><p>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects（DAO）。</p><p>特性：</p><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 </li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 </li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><blockquote><p>Hibernate 是一个全自动的ORM框架，可以自动生成SQL语句，自动执行。</p><p>ORM框架采用元数据来描述对象与关系映射的细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。简单理解为一种框架的格式</p></blockquote><p>对比：</p><ul><li>JDBC：<ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>MyBatis下载地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p>由于现在我们引入jar包都是用Maven，所以这里下载的目的主要是获取官方文档</p><p>依赖引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyBatis的核心配置文件"><a href="#MyBatis的核心配置文件" class="headerlink" title="MyBatis的核心配置文件"></a>MyBatis的核心配置文件</h3><p>习惯上命名为mybatis-config.xml，将来整合Spring 之后，这个配置文件可以省略。</p><p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/user/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//添加固定用户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addOne</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//修改固定用户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateOne</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//删除固定用户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteOne</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h3><p>相关概念：ORM（Object Relationship Mapping）对象关系映射。 </p><ul><li>对象：Java的实体类对象 </li><li>关系：关系型数据库 </li><li>映射：二者之间的对应关系</li></ul><p>映射文件的命名规则：表所对应的实体类的类名+Mapper.xml</p><blockquote><p>表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</p><p>因此一个映射文件对应一个实体类，对应一张表的操作，MyBatis映射文件用于编写SQL，访问以及操作表中的数据，存放在src&#x2F;main&#x2F;resources目录下</p></blockquote><p>MyBatis中可以面向接口操作数据，要保证两个一致：</p><ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致 </li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.user.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--int addOne();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOne&quot;</span>&gt;</span></span><br><span class="line">        insert into user</span><br><span class="line">        values (null, &#x27;张三&#x27;, &#x27;123&#x27;, &#x27;foshan&#x27;, &#x27;123&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--int updateOne();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateOne&quot;</span>&gt;</span></span><br><span class="line">        update user set name=&#x27;张三&#x27; where name = &#x27;john&#x27;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--int deleteOne();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteOne&quot;</span>&gt;</span></span><br><span class="line">        delete from user where name=&#x27;张三&#x27;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取代理对象mapper"><a href="#获取代理对象mapper" class="headerlink" title="获取代理对象mapper"></a>获取代理对象mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">Builder</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">Factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line"><span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">System.out.println(mapper.addOne());</span><br><span class="line"><span class="comment">//sqlSession.commit();</span></span><br></pre></td></tr></table></figure><blockquote><p>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的 会话） </p><p>SqlSessionFactory：是“生产”SqlSession的“工厂”。 </p><p>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的 相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</p></blockquote><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入log4j的配置文件：</p><blockquote><p>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) ；从左到右打印的内容越来越详细</p></blockquote><h2 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h2><p>由于MyBatis获取代理对象格式固定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;</span><br><span class="line">        T mapper=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">            <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(is);</span><br><span class="line">            <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">            mapper = sqlSession.getMapper(clazz);</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经展示了固定sql的增删改操作，查询稍有不同：</p><ol><li>查询一个实体类对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User selectOne();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.user.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id=1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectOne</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    System.out.println(mapper.selectOne());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查询单个数据</li></ol><p>MyBatis中设置了默认的类型别名，较为常用的有：</p><ul><li>java.lang.Integer–&gt;int,integer</li><li>int–&gt;_int,_integer</li><li>Map–&gt;map</li><li>String–&gt;string</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int count();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    select count(*) from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    System.out.println(mapper.count());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>查询List集合</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; selectAll();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.user.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    mapper.selectAll().forEach(user -&gt; System.out.println(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： </p><ol><li><p>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系</p><ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况</li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li><p>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p></li></ol><h1 id="2-核心配置文件详解"><a href="#2-核心配置文件详解" class="headerlink" title="2. 核心配置文件详解"></a>2. 核心配置文件详解</h1><p>核心配置文件中的标签必须按照固定的顺序： </p><p>&#96;properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">            alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小</span></span><br><span class="line"><span class="comment">            写</span></span><br><span class="line"><span class="comment">            若设置此属性，此时该类型的别名只能使用alias所设置的值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.user.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.user.bean.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，</span></span><br><span class="line"><span class="comment">            表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">                属性：</span></span><br><span class="line"><span class="comment">                type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">                type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">                type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                dataSource：设置数据源</span></span><br><span class="line"><span class="comment">                属性：</span></span><br><span class="line"><span class="comment">                type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">                type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从</span></span><br><span class="line"><span class="comment">                缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">                type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">                type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此句不能和package一起用：</span></span><br><span class="line"><span class="comment">        &lt;mapper resource=&quot;com/mapper/UserMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">            注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Maven打包后会将java和resources目录下的文件合并在classes目录下，所以mapper接口和mapper映射文件只需分别在java和resources目录下有相同的路径即可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006220429.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006220429.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b15f0683eb0a52a94795ba63ea17a625.png"></p><h1 id="3-MyBatis获取参数值（重点）"><a href="#3-MyBatis获取参数值（重点）" class="headerlink" title="3. MyBatis获取参数值（重点）"></a>3. MyBatis获取参数值（重点）</h1><p>MyBatis获取参数值有两种方式：**${}和#{}**</p><p>${}的本质是字符串拼接，#{}的本质就是占位符赋值</p><p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，<strong>需要手动加单引号</strong>；#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</p><p>使用的五种情况：</p><ol><li>单个字面量类型的参数</li></ol><p>当mapper接口中的方法参数为单个的字面量类型时，可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User select(int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select * from user where id = &#x27;$&#123;a&#125;&#x27;--&gt;</span></span><br><span class="line">    select * from user where id=#&#123;a&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多个字面量类型的参数</li></ol><p>当mapper接口中的方法参数为多个时，MyBatis会自动将这些参数放在一个map集合中：</p><ul><li>以arg0,arg1…为键，以参数为值；</li><li>以 param1,param2…为键，以参数为值；</li></ul><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username, String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select * from user where name = #&#123;arg0&#125; and password = #&#123;arg1&#125;--&gt;</span></span><br><span class="line">    select * from user where name = #&#123;param1&#125; and password = #&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>map集合类型的参数</li></ol><p>当mapper接口中的方法需要的参数为多个时，可以手动创建map集合，将这些数据放在map中，只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String, Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where name = #&#123;name&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;john&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(mapper.checkLoginByMap(map));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>实体类类型的参数</li></ol><p>当mapper接口中的方法参数为实体类对象时，可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user values (#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;address&#125;, #&#123;phone&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>使用@Param标识参数</li></ol><p>可以通过@Param注解标识mapper接口中的方法参数，此时，MaBatis会将这些参数放在map集合中</p><ul><li>以@Param注解的value属性值为键，以参数为值；</li><li>以 param1,param2…为键，以参数为值；</li></ul><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值， 注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where name = #&#123;name&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其实可以不用分这么种情况，除了实体类类型的参数比较特殊，其它都可以使用@Param来解决</p></blockquote><h1 id="4-MyBatis的各种查询功能"><a href="#4-MyBatis的各种查询功能" class="headerlink" title="4. MyBatis的各种查询功能"></a>4. MyBatis的各种查询功能</h1><ol><li>查询一条数据<ul><li>通过实体类对象接收</li><li>通过list集合接收</li><li>通过map集合接收</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; userByMap(@Param(&quot;id&quot;) Integer id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;userByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询多条数据<ul><li>通过实体类类型的list集合接收</li><li>通过map类型的list集合接收</li><li>在mapper接口的方法上添加@MapKey注解，将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个map集合中</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String,Object&gt;&gt; <span class="title function_">allByMap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">allByMapKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Map&lt;String,Object&gt;&gt; allByMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;allByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; allByMapKey();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;allByMapKey&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="5-特殊SQL的执行"><a href="#5-特殊SQL的执行" class="headerlink" title="5. 特殊SQL的执行"></a>5. 特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; userLike(@Param(&quot;name&quot;)String name);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;userLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select * from user where name like(&#x27;%$&#123;name&#125;%&#x27;)</span></span><br><span class="line"><span class="comment">    select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)--&gt;</span></span><br><span class="line">    select * from user where name like(&quot;%&quot;#&#123;name&#125;&quot;%&quot;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>sql 语句有三种书写方式（like后面的正则不用括号也能识别），一般使用第三种，虽然idea提示错误，但是能正常运行</p></blockquote><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">    delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMore(<span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Object&gt; getUserByTableName(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTableName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加时获取自增的主键"><a href="#添加时获取自增的主键" class="headerlink" title="添加时获取自增的主键"></a>添加时获取自增的主键</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user values (#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;address&#125;, #&#123;phone&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>useGeneratedKeys:设置当前标签中的sql使用了自增的主键<br>keyProperty:将自增的主键的值赋值给传输到映射文件中参数的某个属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> MapperUtil.getMapper(UserMapper.class);</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;xian&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(mapper.insertUser(user));</span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将user在数据库存放时的id返回给user对象</p></blockquote><h1 id="6-自定义映射resultMap"><a href="#6-自定义映射resultMap" class="headerlink" title="6. 自定义映射resultMap"></a>6. 自定义映射resultMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String empName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> deptId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段和属性映射"><a href="#字段和属性映射" class="headerlink" title="字段和属性映射"></a>字段和属性映射</h2><p>当字段名和实体类中的属性名不一致，查询虽然不会报错，但读取的数据不完整，有三种方式解决</p><ol><li>通过为字段起别名的方式，保证和实体类中的属性名保持一致</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Emp selectOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select id,emp_name  empName,email,salary from emp where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置MyBatis的全局配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将_自动映射为驼峰，emp_name:empName--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Emp selectOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）的情况才能使用</p></blockquote><ol start="3"><li>通过resultMap设置自定义映射</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Emp selectOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOne&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>若只是处理字段和属性的映射关系，resultMap可以需要什么设置什么</p></blockquote><h2 id="多对一映射"><a href="#多对一映射" class="headerlink" title="多对一映射"></a>多对一映射</h2><p>当一次查询需要用到多个表中的数据，有三种解决方式：</p><ol><li>级联方式处理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp selectOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOne&quot;</span>&gt;</span></span><br><span class="line">    select * from emp left join dept on emp.dept_id=dept.dept_id where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>association处理映射</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">association:专门处理多对一的映射关系</span></span><br><span class="line"><span class="comment">         property:需要处理多对的映射关系的属性名</span></span><br><span class="line"><span class="comment">         javaType:该属性的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp selectOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectTwo&quot;</span>&gt;</span></span><br><span class="line">    select * from emp left join dept on emp.dept_id=dept.dept_id where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 association 时 resultMap 必须指明所有映射关系（未指明的属性会赋值为null）</p></blockquote><ol start="3"><li>分步查询</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询员工</span></span><br><span class="line">    Emp <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//分步查询emp第一步</span></span><br><span class="line">    Emp <span class="title function_">stepOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;stepOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">select:设置分步查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</span></span><br><span class="line"><span class="comment">column:设置分布查询的条件</span></span><br><span class="line"><span class="comment">fetchType:可通过此属性手动控制延迟加载的效果</span></span><br><span class="line"><span class="comment">fetchType=&quot;lazy|eager&quot;:lazy表示延迟加载，eager表示立即加载</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mapper.DeptMapper.stepTwo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp stepOne(@Param(&quot;id&quot;)int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;stepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;stepOne&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">//分步查询emp第二步</span></span><br><span class="line">    Dept <span class="title function_">stepTwo</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span><span class="type">int</span> deptId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Dept stepTwo(@Param(&quot;deptId&quot;)int deptId);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;stepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    select * from dept where dept_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>延迟加载可以避免在分步查询中执行所有的SQL语句，节省资源，实现按需加载。</p></blockquote><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><ol><li>collection</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">collection：处理一对多的映射关系</span></span><br><span class="line"><span class="comment">ofType：表示该属性所对应的集合中存储数据的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept selectOne(@Param(&quot;deptId&quot;)int deptId);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOne&quot;</span>&gt;</span></span><br><span class="line">    select * from dept left join emp on dept.dept_id=emp.dept_id where dept.dept_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若一对多的是简单数据类型，可以参照下列代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;integer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>分步查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">//分步查询emp第二步</span></span><br><span class="line">    Dept <span class="title function_">stepTwo</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span><span class="type">int</span> deptId)</span>;</span><br><span class="line">    <span class="comment">//查询dept的员工</span></span><br><span class="line">    Dept <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span><span class="type">int</span> deptId)</span>;</span><br><span class="line">    <span class="comment">//分步查询dept第一步</span></span><br><span class="line">    Dept <span class="title function_">stepOne</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span><span class="type">int</span> deptId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;stepOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mapper.EmpMapper.stepTwo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_Id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept stepOne(@Param(&quot;deptId&quot;)int deptId);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;stepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;stepOne&quot;</span>&gt;</span></span><br><span class="line">    select * from dept where dept_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询员工</span></span><br><span class="line">    Emp <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//分步查询emp第一步</span></span><br><span class="line">    Emp <span class="title function_">stepOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//分步查询dept第二步</span></span><br><span class="line">    List&lt;Emp&gt; <span class="title function_">stepTwo</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span><span class="type">int</span> deptId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; stepTwo(@Param(&quot;deptId&quot;)int deptId);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;stepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where dept_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>分步查询的优点：可以实现延迟加载<br>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 （默认false）<br>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载 （默认false）<br>实现按需加载后，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加 载)|eager(立即加载)”</p></blockquote><h1 id="7-动态SQL"><a href="#7-动态SQL" class="headerlink" title="7. 动态SQL"></a>7. 动态SQL</h1><p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if 标签可通过test属性的表达式进行判断，若表达式的结果为true，则拼接标签中的内容；反之标签中的内容不会被拼接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; selectMore(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMore&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName!=null and empName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and emp_name=#&#123;empName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and email=#&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary!=0&quot;</span>&gt;</span></span><br><span class="line">        and salary=#&#123;salary&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; selectMore(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMore&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName!=null and empName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and emp_name=#&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and email=#&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary!=0&quot;</span>&gt;</span></span><br><span class="line">            and salary=#&#123;salary&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where和if一般结合使用：</p><ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and或or去掉</li><li>注意：where标签不能将其中内容后面多余的and或or去掉</li></ul><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; selectMore(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMore&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName!=null and empName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and emp_name=#&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and email=#&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary!=0&quot;</span>&gt;</span></span><br><span class="line">            and salary=#&#123;salary&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>trim用于去掉或添加标签中的内容，常用属性： </p><ul><li>prefix：在trim标签中所有内容的前面添加某些内容 </li><li>prefixOverrides：在trim标签中所有内容的前面去掉某些内容 </li><li>suffix：在trim标签中所有内容的后面添加某些内容 </li><li>suffixOverrides：在trim标签中所有内容的后面去掉某些内容</li></ul><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><p>choose、when、otherwise相当于if…else if..else；when至少要有一个，otherwise最多只能有一个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; selectMore(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMore&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName!=null and empName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and emp_name=#&#123;empName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;salary!=0&quot;</span>&gt;</span></span><br><span class="line">                and salary=#&#123;salary&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>实现批量添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMore(@Param(&quot;emps&quot;)List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMore&quot;</span>&gt;</span></span><br><span class="line">    insert into emp values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (null,#&#123;emp.empName&#125;,#&#123;emp.email&#125;,#&#123;emp.salary&#125;,#&#123;emp.dept.deptId&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置了<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code>，但只有第一个记录的id返回，原因：</p><p>使用了<code>on duplicate key update</code>，去掉即可全部记录返回id（存储到对象中）。</p><p>实现批量删除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMore(int[] ids);--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>collection：设置要循环的数组或集合 </li><li>item：表示集合或数组中的每一个数据 </li><li>separator：设置循环体之间的分隔符 </li><li>open：设置foreach标签中所有内容的开始符 </li><li>close：设置foreach标签中所有内容的结束符</li></ul><h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span></span><br><span class="line">    id,emp_name,email,salary,dept_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from emp</span><br></pre></td></tr></table></figure><h1 id="8-MyBatis的缓存"><a href="#8-MyBatis的缓存" class="headerlink" title="8. MyBatis的缓存"></a>8. MyBatis的缓存</h1><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是SqlSession级别的，默认开启，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 </p><p>使一级缓存失效的四种情况：</p><ul><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ul><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</li><li>在映射文件中设置标签&lt;cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String empName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> deptId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>在mapper配置文件中添加的cache标签可以设置一些属性：</p><ul><li>eviction属性：缓存回收策略默认的是 LRU。<ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒，默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 </li><li>size属性：引用数目，正整数，代表缓存最多可以存储多少个对象，太大容易导致内存溢出 </li><li>readOnly属性：只读，true&#x2F;false <ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。 </li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</li></ul></li></ul><h3 id="缓存查询的顺序"><a href="#缓存查询的顺序" class="headerlink" title="缓存查询的顺序"></a>缓存查询的顺序</h3><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存。如果一级缓存也没有命中，则查询数据库。SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p><h2 id="整合第三方缓存EHCache"><a href="#整合第三方缓存EHCache" class="headerlink" title="整合第三方缓存EHCache"></a>整合第三方缓存EHCache</h2><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><ol start="2"><li>创建EHCache的配置文件ehcache.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EHCache配置文件说明:</p><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td></tr></tbody></table><ol start="3"><li>设置二级缓存的类型</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>加入logback日志</li></ol><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="9-MyBatis的逆向工程"><a href="#9-MyBatis的逆向工程" class="headerlink" title="9. MyBatis的逆向工程"></a>9. MyBatis的逆向工程</h1><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程 的。 </p><p>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成资源： Java实体类、Mapper接口、Mapper映射文件</p><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><ol><li>添加依赖和插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的依赖必须对应当前mysql版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建MyBatis的核心配置文件</li><li>创建逆向工程的配置文件</li></ol><blockquote><p>文件名必须是：generatorConfig.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">        MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">        MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--suppressAllComments：去掉所有的注解--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--没有此标签逆向工程会查询其它数据库的同名表--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，</span></span><br><span class="line"><span class="comment">为 true 时把JDBC DECIMAL和 NUMERIC 类型解析为 java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.pojo&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--enableSubPackages 设置是否创建子包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>执行MBG插件的generate目标</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006220455.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20231006220455.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8bb090478c33c0314411d6ded7bd7376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/ef0fb8523055cf51bf90731756f40cc2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/ef0fb8523055cf51bf90731756f40cc2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ef0fb8523055cf51bf90731756f40cc2.png"></p><h2 id="QBC风格"><a href="#QBC风格" class="headerlink" title="QBC风格"></a>QBC风格</h2><p>Query By Criteria，根据标准查询，即条件都是定义好的，只需要调用像对应的方法，就可以生成标准的条件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    <span class="comment">//select id, emp_name, email, salary, dept_id from emp where id = ?]</span></span><br><span class="line">    System.out.println(mapper.selectByPrimaryKey(<span class="number">100</span>));</span><br><span class="line">    EmpExample example=<span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line">    example.createCriteria().andIdLessThan(<span class="number">101</span>);</span><br><span class="line">    <span class="comment">//select id, emp_name, email, salary, dept_id from emp WHERE ( id &lt; ? )]</span></span><br><span class="line">    System.out.println(mapper.selectByExample(example));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-分页插件"><a href="#10-分页插件" class="headerlink" title="10. 分页插件"></a>10. 分页插件</h1><h2 id="分页插件配置"><a href="#分页插件配置" class="headerlink" title="分页插件配置"></a>分页插件配置</h2><ol><li>添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置分页插件</li></ol><p>在MyBatis的核心配置文件中配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</p><blockquote><p>pageNum：当前页的页码；pageSize：每页显示的条数</p></blockquote><p>在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int navigatePages)可以获取分页相关的详细数据</p><blockquote><p>list：分页之后的数据；navigatePages：导航分页的页码数</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">    emps.forEach(System.out::println);</span><br><span class="line">    System.out.println(page);</span><br><span class="line">    PageInfo&lt;Emp&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(emps, <span class="number">5</span>);</span><br><span class="line">    System.out.println(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据详解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=109, pages=22, reasonable=false, pageSizeZero=false&#125;</span><br><span class="line">这里是List的数据</span><br><span class="line">[Emp&#123;id=100...&#125;, Emp&#123;id=102...&#125;, Emp&#123;id=103...&#125;, Emp&#123;id=104...&#125;, Emp&#123;id=105...&#125;]</span><br></pre></td></tr></table></figure><p>其中 reasonable 这个属性含义是分页参数合理化，3.3.0以上版本可用<br>当启用合理化时，如果pageNum&gt;pages，默认会查询最后一页的数据。禁用合理化后，当pageNum&gt;pages会返回空数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;pageNum=1, pageSize=5, size=5, startRow=1, endRow=5, total=109, pages=22, </span><br><span class="line">这里是page中的数据</span><br><span class="line">list=Page&#123;count=true...Emp&#123;id=105...&#125;],</span><br><span class="line"></span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=5, navigatepageNums=[1, 2, 3, 4, 5]&#125;</span><br></pre></td></tr></table></figure><p>这里 pageSize 表示设定一页的数据条数，size 表示实际存在的数据条数，navigatepageNums 表示导航分页的结果</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/08/18/%E5%B7%A5%E5%85%B7/Linux/"/>
      <url>/2023/08/18/%E5%B7%A5%E5%85%B7/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Linux-入门"><a href="#1-Linux-入门" class="headerlink" title="1. Linux 入门"></a>1. Linux 入门</h1><p>Linux 内核最初由芬兰人<strong>林纳斯·托瓦兹</strong>在大学时出于个人爱好而编写的</p><p>Linux 是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。Linux 能运行主要的UNIX工具软件、应用程序和网络协议，支持32和64位硬件，继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203743.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2008561d9e65bb28a9cb401b9a2d703b.png"></p><table><thead><tr><th>比较</th><th>Window</th><th>Linux</th></tr></thead><tbody><tr><td>免费与收费</td><td>收费且很贵</td><td>Linux 免费或少许费用</td></tr><tr><td>软件与支持</td><td>数量和质量的优势，不过大部分为收费软件；由微软官方提供支持和服务；</td><td>开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。</td></tr><tr><td>安全性</td><td>三天两头打补丁安装系统安全更新，还是会中病毒木马；</td><td>要说 Linux 没有安全问题，那当然是不可能的， 这一点仁者见仁智者见智，相对来说肯定比 Windows 平台要更加安全</td></tr><tr><td>使用习惯</td><td>普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易入门简单；</td><td>兼具图形界面操作和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。</td></tr><tr><td>可定制性</td><td>封闭的，系统可定制性很差；</td><td>开源，可定制化非常强。</td></tr><tr><td>应用场景</td><td>桌面操作系统主要使用的是window。</td><td>支撑百度，谷歌，淘宝等应用软件和服务的，是后台成千上万的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的。</td></tr></tbody></table><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>虚拟机软件：VMWare<br>CentOS官网：<a href="https://www.centos.org/">The CentOS Project</a></p><p>VMWare只需要修改安装地址即可；CentOS的安装需要分配CPU内核数和内存。其中处理器数量和每个处理器内核数量相乘不能超过物理机的逻辑处理器个数。</p><p>虚拟机上网方式：</p><ul><li>桥接网络：虚拟机直接连接外部物理网络的模式，主机七到了网桥的作用。这种模式下，虚拟机可以直接访问外部网络，并且对外部网络时可见的。可能造成ip冲突</li></ul><blockquote><p>相当于VMWare创建了一个虚拟交换机（一个网桥不能连接多台虚拟机），通过pc机与虚拟机之间搭建的网桥，让路由器内部的DHCP服务器动态地分配一个ip给虚拟机</p></blockquote><ul><li>NAT模式（网络地址转换）</li></ul><p>虚拟机和主机构建一个专用网络，并通过虚拟网络地址转换（NAT）设备对IP进行转换。虚拟机通过共享主机IP可以访问外部网络，但外部网络无法访问虚拟机。</p><blockquote><p>相当于VMWare创建了一个虚拟路由器（实际上是底层创建了一个NAT服务器做网络地址转换和一个DHCP服务器做动态地址分配），通过pc的IP给虚拟机分配子网ip，此时虚拟机可以连外网。</p><p>VMWare还给pc创建了一个虚拟网卡（VMnet8），连接虚拟路由器，以便pc能连接到虚拟机</p></blockquote><ul><li>仅主机模式：虚拟机只与主机共享一个专用网络，无法与外部通信</li></ul><blockquote><p>相当于VMware创建了一个虚拟交换机连接虚拟机，并给pc创建了一个虚拟网卡（VMnet1）连接到交换机</p></blockquote><p>文件系统的IO方式，磁盘类型都使用推荐，磁盘种类选择创建新虚拟磁盘，分配好空间后选择将虚拟磁盘拆分成多个文件，方便虚拟机的转移。</p><p>第一次启动CentOS时需要定制化内容，软件选择GHOME桌面（图形化界面的方式）；然后可以在安装位置进行手动分区。</p><p>Linux的分区由三部分构成：</p><ol><li>&#x2F;boot：引导分区的挂载点</li><li>swap：交换分区，在内存不够用时的暂存区</li><li>&#x2F;：根目录</li></ol><p>KDUMP会占用一部分内存，学习阶段建议关闭</p><h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><p>Linux 系统中一切皆文件。</p><p>Linux 的文件系统采用级层式的树状目录结构，根目录为“&#x2F;”，在此目录下再创建其它目录</p><p>目录结构具体介绍：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203753.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203753.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7370e95cc2ea69960c59c610b1da10c5.png"></p><ul><li><strong>&#x2F;bin</strong>：Binary 的缩写，存放最常使用的命令</li><li>&#x2F;sbin：s表示Super User，存放系统管理员使用的系统管理程序</li><li><strong>&#x2F;home</strong>：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名由用户的账号命名</li><li><strong>&#x2F;root</strong>：系统管理员，也称超级权限者的用户主目录</li><li>&#x2F;lib：系统开机所需要最基本的动态连接共享库，作用类似于Windows中的DLL文件，几乎所有的应用程序都需要用到这些共享库</li><li><strong>&#x2F;boot</strong>：存放启动Linux时使用的一些核心文件，包括一些连接文件一级镜像文件</li><li><strong>&#x2F;etc</strong>：所有的系统管理所需要的配置文件和子目录</li><li><strong>&#x2F;usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于Windows中的programfiles目录<ul><li>该目录下的local：另一个给主机额外安装软件所安装的目录。一般通过编译源码方式安装的程序。</li></ul></li><li>&#x2F;proc：一个虚拟的目录，是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</li><li>&#x2F;srv：service的缩写，该目录存放一些服务启动之后需要提取的数据</li><li>&#x2F;sys：是linux2.6内核的一个很大的变化，该目录安装了2.6内核中新出现的一个系统文件sysfs</li><li>&#x2F;tmp：用来存放一些临时文件</li><li>&#x2F;dev：类似于Windows的设备管理器，把所有的硬件用文件的形式存储</li><li><strong>&#x2F;media（CentOS6）</strong>：Linux系统会自动识别一些设备，例如U盘等，识别后Linux会将识别的设备挂载到这个目录下；CentOS7迁移到&#x2F;run&#x2F;media</li><li><strong>&#x2F;mnt</strong>：系统提供该目录用于让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，可以进入该目录查看内容</li><li><strong>&#x2F;opt</strong>：给主机额外安装软件所摆放的目录。默认是空的</li><li><strong>&#x2F;var</strong>：用于存放会不断扩充的文件，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</li><li>&#x2F;run：记录自启动以来的系统信息。可以找到有关正在运行的守护程序、登录用户等信息，让我们了解自启动以来系统资源的使用情况</li></ul><h1 id="2-VI-x2F-VIM编辑器"><a href="#2-VI-x2F-VIM编辑器" class="headerlink" title="2. VI&#x2F;VIM编辑器"></a>2. VI&#x2F;VIM编辑器</h1><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。</p><blockquote><p>最小系统需要安装vim：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install vim-enhanced #亲测有用</span><br><span class="line">#全安也行（第一次系统安装完后连不上百度）</span><br></pre></td></tr></table></figure><p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。</p><blockquote><p>vim：”编辑器之神”，效率极高<br>emacs：”神之编辑器”</p></blockquote><h2 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h2><p>以 vi&#x2F;vim 打开一个档案就直接进入一般模式了（这是默认的模式）。</p><table><thead><tr><th align="center">常用语法</th><th>功能描述</th></tr></thead><tbody><tr><td align="center">yy</td><td>复制光标当前一行</td></tr><tr><td align="center">y 数字 y</td><td>复制一段（从第几行到第几行）</td></tr><tr><td align="center">p</td><td>箭头移动到目的行粘贴</td></tr><tr><td align="center">u</td><td>撤销上一步</td></tr><tr><td align="center">dd</td><td>删除光标当前行</td></tr><tr><td align="center">d 数字 d</td><td>删除光标（含）后多少行</td></tr><tr><td align="center">x</td><td>剪切一个字母，相当于 del</td></tr><tr><td align="center">X</td><td>剪切一个字母，相当于 Backspace</td></tr><tr><td align="center">yw</td><td>复制一个词</td></tr><tr><td align="center">dw</td><td>删除一个词</td></tr><tr><td align="center">shift+6(^)</td><td>移动到行头</td></tr><tr><td align="center">shift+4($)</td><td>移动到行尾</td></tr><tr><td align="center">1+shift+g</td><td>移动到页头，数字</td></tr><tr><td align="center">shift+g</td><td>移动到页尾</td></tr><tr><td align="center">数字+shift+g</td><td>移动到目标行</td></tr></tbody></table><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容；</p><p>进入编辑模式：</p><table><thead><tr><th align="center">按键</th><th>功能</th></tr></thead><tbody><tr><td align="center">i</td><td>当前光标前插入</td></tr><tr><td align="center">a</td><td>当前光标后</td></tr><tr><td align="center">o</td><td>当前光标行的下一行</td></tr><tr><td align="center">I</td><td>光标所在行最前</td></tr><tr><td align="center">A</td><td>光标所在行最后</td></tr><tr><td align="center">O</td><td>当前光标行的上一行</td></tr></tbody></table><p>退出编辑模式：ESC；回到一般模式</p><h2 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h2><p>在一般模式当中，输入『 : &#x2F; ?』3个中的任何一个按钮，就可以将光标移动到最底下那 一行。</p><p>基本语法：</p><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">:w</td><td>保存</td></tr><tr><td align="center">:q</td><td>退出</td></tr><tr><td align="center">:!</td><td>强制执行</td></tr><tr><td align="center">&#x2F;要查找的词</td><td>n 查找下一个，N 往上查找</td></tr><tr><td align="center">:noh</td><td>取消高亮显示</td></tr><tr><td align="center">:set nu</td><td>显示行号</td></tr><tr><td align="center">:set nonu</td><td>关闭行号</td></tr><tr><td align="center">:%s&#x2F;old&#x2F;new&#x2F;g</td><td>替换内容 &#x2F;g 替换匹配到的所有内容</td></tr></tbody></table><p>组合使用：</p><ul><li>:wq</li><li>:q!</li><li>:wq!</li></ul><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203759.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8bb9ceadb21aab0708da1f0ca9faea38.png"></p><h1 id="3-网络配置"><a href="#3-网络配置" class="headerlink" title="3. 网络配置"></a>3. 网络配置</h1><p>显示所有网络接口的配置信息：</p><ul><li>windows：ipconfig</li><li>Linux：ifconfig<blockquote><p>安装的最小系统可以使用 ip addr 查看</p></blockquote></li></ul><p>如果安装的Linux不能联网，需要查看windows对应的服务是否开启：</p><ul><li>VMware DHCP Service</li><li>VMware NAT Service</li></ul><p>测试主机之间网络连通性：</p><ul><li>ping 目的主机（测试当前服务器是否可以连接目的主机）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# ping www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="修改IP地址："><a href="#修改IP地址：" class="headerlink" title="修改IP地址："></a>修改IP地址：</h2><p>由于动态分配ip地址在连接前还需要查询ip，所以为了方便我们可以直接修改为静态IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot; #网络类型（通常是 Ethemet）</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot; #IP 的配置方法[none|static|bootp|dhcp]</span><br><span class="line">#（引导时不使用协议|静态分配 IP|BOOTP 协议|DHCP 协议）</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;e83804c1-3257-4584-81bb-660665ac22f6&quot; #随机 id</span><br><span class="line">DEVICE=&quot;ens33&quot; #接口名（设备,网卡）</span><br><span class="line">ONBOOT=&quot;yes&quot; #系统启动的时候网络接口是否有效（yes/no）</span><br><span class="line">#IP 地址</span><br><span class="line">IPADDR=192.168.1.100</span><br><span class="line">#网关</span><br><span class="line">GATEWAY=192.168.1.2</span><br><span class="line">#域名解析器</span><br><span class="line">DNS1=192.168.1.2</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203808.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203808.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b401842c87fc6b0154a67f9fb242b3ab.png"></p><p>修改完后使用命令 service network restart 重启网络即可生效</p><blockquote><p>【service 服务名 操作】是CentOS6的指令，network是CentOS6的网络服务名，CentOS7版本进行了兼容。</p><p>【systemctl 操作 服务名】CentOS7中指令，NetworkManager是CentOS7的网络服务名</p><p>NetworkManager虽然也会运行，但CentOS7中默认使用的还是network</p></blockquote><h2 id="修改主机名称："><a href="#修改主机名称：" class="headerlink" title="修改主机名称："></a>修改主机名称：</h2><p>hostname：查看当前服务器的主机名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# hostname</span><br></pre></td></tr></table></figure><p>如果感觉此主机名不合适，我们可以进行修改。通过编辑&#x2F;etc&#x2F;hostname 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vi /etc/hostname</span><br></pre></td></tr></table></figure><p>修改完成后重启生效。</p><p>不重启也能直接修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# hostnamectl #查看主机名相关信息</span><br><span class="line">[root@hadoop100 ~]# hostnamectl set-hostname hadoop100 #修改的主机名</span><br></pre></td></tr></table></figure><h2 id="修改映射文件："><a href="#修改映射文件：" class="headerlink" title="修改映射文件："></a>修改映射文件：</h2><p>为了方便连接，可以修改Linux和Windows的hosts文件</p><p>Linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/hosts</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br></pre></td></tr></table></figure><h2 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h2><p>方式一：</p><p>Windows和Linux都支持基于SSH协议的远程登陆方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\16958&gt;ssh root@hadoop100</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203829.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203829.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2ffb9d7d042488d6e576249995e4a934.png"></p><blockquote><p>此方式虽然简单，但是功能比较有限</p></blockquote><p>文件上传下载：scp指令</p><p>方式二：</p><p>使用远程登录工具（基本都是基于SSH协议）</p><p>Xshell：强大的安全终端模拟软件，支持SSH1，SSH2以及Microsoft Windows平台的TELNET协议。</p><p>Linux需要启动SSHD服务，该服务会监听22号端口</p><p>远程上传下载文件需要使用配套工具：Xftp5，一个基于ftp协议的SFTP、FTP文件传输软件</p><h1 id="4-系统管理"><a href="#4-系统管理" class="headerlink" title="4. 系统管理"></a>4. 系统管理</h1><p>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）。 启动之后一直存在、常驻内存的进程，一般被称作“服务”（service）。</p><h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><p>CentOS6：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203839.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203839.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ee6da7a514b9fb4140edfe4f78a3c009.png"></p><p>CentOS7：</p><p>运行级别简化为:</p><ul><li>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面）</li><li>graphical.target  等价于原运行级别 5（多用户有网，有图形界面）</li></ul><p>进入系统管理的图形化界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# setup</span><br></pre></td></tr></table></figure><ol><li>上下左右键移动选择</li><li>tab键切换选择到确定还是退出或者其他的界面</li><li>空格键在系统服务界面可以开启关闭服务（有*表示开启，无*表示关闭）</li><li>enter键确认你的选择是退出还是其他选项</li></ol><h2 id="CentOS6"><a href="#CentOS6" class="headerlink" title="CentOS6"></a>CentOS6</h2><p>基本语法：<code>service 服务名 start | stop | restart | status</code></p><p>chkconfig 设置后台服务的自启配置：</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkconfig   （功能描述：查看所有服务器自启配置）</span><br><span class="line">chkconfig 服务名 off    （功能描述：关掉指定服务的自动启动）</span><br><span class="line">chkconfig 服务名 on     （功能描述：开启指定服务的自动启动）</span><br><span class="line">chkconfig 服务名 --list （功能描述：查看服务开机启动状态</span><br><span class="line">chkconfig --level 指定级别 服务名 on|off （开启/关闭服务指定级别的自动启动）</span><br></pre></td></tr></table></figure><h2 id="CentOS7-重点掌握"><a href="#CentOS7-重点掌握" class="headerlink" title="CentOS7(重点掌握)"></a>CentOS7(重点掌握)</h2><p>systemctl 设置后台服务的自启配置：</p><p>基本语法：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>systemctl start 服务名</td><td>开启服务</td></tr><tr><td>systemctl stop 服务名</td><td>关闭服务</td></tr><tr><td>systemctl status 服务名</td><td>显示状态</td></tr><tr><td>systemctl restart 服务名</td><td>重启服务</td></tr><tr><td>systemctl enable 服务名</td><td>开机启动服务</td></tr><tr><td>systemctl disable 服务名</td><td>禁止开机启动</td></tr><tr><td>systemctl list-units</td><td>查看系统中所有正在运行的服务</td></tr><tr><td>systemctl list-unit-files</td><td>查看系统中所有服务的开机启动状态</td></tr><tr><td>systemctl list-dependencies 服务名</td><td>查看系统中服务的依赖关系</td></tr><tr><td>systemctl mask 服务名</td><td>冻结服务</td></tr><tr><td>systemctl unmask 服务名</td><td>解冻服务</td></tr><tr><td>systemctl set-default multi-user.target</td><td>开机时不启动图形界面</td></tr><tr><td>systemctl set-default graphical.target</td><td>开机时启动图形界面</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817204058.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817204058.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d49eb16546af402770051c5212a567b6.png"></p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>active(running)</td><td>表示程序正在执行</td></tr><tr><td>atcive(exited)</td><td>执行一次就正常退出的服务,不在系统中执行任何程序</td></tr><tr><td>active(waiting)</td><td>正在执行中,处于阻塞状态,需要等待其他程序执行完才能执行</td></tr><tr><td>inactive (dead)</td><td>未启动状态</td></tr></tbody></table><p><strong>vendor preset</strong>后面的表示服务默认的启动状态<br><strong>vendor preset</strong>前面的表示服务当前的启动状态,有以下几种情况:</p><table><thead><tr><th>启动状态</th><th>含义</th></tr></thead><tbody><tr><td>inactive</td><td>服务关闭</td></tr><tr><td>disable</td><td>服务开机不启动</td></tr><tr><td>enabled</td><td>服务开机启动</td></tr><tr><td>static</td><td>服务开机启动项被管理</td></tr><tr><td>failed</td><td>服务配置错误</td></tr></tbody></table><p>修改防火墙：</p><p>CentOS6及以前的版本防火墙服务的名称为 iptables</p><p>CentOS7改名为 firewalld</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# systemctl stop firewalld     #临时关闭防火墙</span><br><span class="line">[root@hadoop100 ~]# systemctl disable firewalld  #开机启动时关闭防火墙</span><br></pre></td></tr></table></figure><h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><p>Linux 大多用在服务器上，很少遇到关机的操作。</p><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">sync</td><td>将数据由内存同步到硬盘中</td></tr><tr><td align="center">halt</td><td>停机但不断电</td></tr><tr><td align="center">poweroff</td><td>断电关机</td></tr><tr><td align="center">reboot</td><td>重启</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] 时间</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-H</td><td>相当于–halt，停机</td></tr><tr><td align="center">、-h、-P</td><td>断电关机，等同于poweroff</td></tr><tr><td align="center">-r</td><td>重启</td></tr><tr><td align="center">-c</td><td>取消操作</td></tr><tr><td align="center">now</td><td>立刻</td></tr></tbody></table><blockquote><p>shutdown默认是一分钟后执行操作，可以在选项后添加时间决定什么时间关机或多少分钟后关机</p></blockquote><h1 id="5-常用基本命令"><a href="#5-常用基本命令" class="headerlink" title="5. 常用基本命令"></a>5. 常用基本命令</h1><p>Shell 可以看作是一个命令解释器，为我们提供了交互式的文本控制台界面。我们可以通过终端控制台来输入命令，由 shell 进行解释并最终交给内核执行。</p><h2 id="帮助文档命令"><a href="#帮助文档命令" class="headerlink" title="帮助文档命令"></a>帮助文档命令</h2><ol><li>man</li></ol><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man [命令或配置文件] （功能描述：获得帮助信息）</span><br><span class="line">示例：</span><br><span class="line">[root@hadoop100 ~]# man ls</span><br></pre></td></tr></table></figure><p>帮助文档显示说明：</p><table><thead><tr><th align="center">信息</th><th>功能</th></tr></thead><tbody><tr><td align="center">NAME</td><td>命令的名称和单行描述</td></tr><tr><td align="center">SYNOPSIS</td><td>怎样使用命令</td></tr><tr><td align="center">DESCRIPTION</td><td>命令功能的深入讨论</td></tr><tr><td align="center">EXAMPLES</td><td>怎样使用命令的例子</td></tr><tr><td align="center">SEE ALSO</td><td>相关主题（通常是手册页）</td></tr></tbody></table><p>一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”；相应的其它命令 被称为“外部命令”。</p><ol start="2"><li>help</li></ol><p>man命令查找内置命令会直接解释shell，可以使用 help 获取shell内置命令的帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">help 命令（功能描述：获得 shell 内置命令的帮助信息）</span><br><span class="line">示例：</span><br><span class="line">[root@hadoop100 ~]# help cd</span><br><span class="line">[root@hadoop100 ~]# ls --help  #外部命令的帮助文档</span><br></pre></td></tr></table></figure><p>判断是否是内置命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# type cd</span><br></pre></td></tr></table></figure><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th>常用快捷键</th><th>功能</th></tr></thead><tbody><tr><td>ctrl + c</td><td>停止进程</td></tr><tr><td>ctrl+shift+c</td><td>复制</td></tr><tr><td>ctrl+shift+v</td><td>粘贴</td></tr><tr><td>ctrl+l</td><td>清屏，等同于 clear；彻底清屏是：reset</td></tr><tr><td>tab 键</td><td>提示(更重要的是可以防止敲错)</td></tr><tr><td>上下键</td><td>查找执行过的命令</td></tr></tbody></table><h2 id="文件目录命令"><a href="#文件目录命令" class="headerlink" title="文件目录命令"></a>文件目录命令</h2><ol><li>pwd：print working directory；打印工作目录</li></ol><p>显示当前工作目录的绝对路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><ol start="2"><li>ls：list；列出目录内容</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] [目录或文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">常用选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-a</td><td>显示所有文件，连同隐藏档( 开头为 . 的文件) 一起列出</td></tr><tr><td align="center">-l</td><td>长数据串列出，包含文件的属性与权限等等数据；等价于“ll”</td></tr></tbody></table><p>每行列出的信息依次是： 文件类型与权限；链接数；文件属主；文件属组；文件大小(用byte表示)；建立或最近修改的时间；文件名</p><ol start="3"><li>cd：Change Directory；切换路径</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">cd 绝对路径</td><td>切换路径</td></tr><tr><td align="center">cd 相对路径</td><td>相对路径</td></tr><tr><td align="center">cd ~或者 cd</td><td>回到家目录</td></tr><tr><td align="center">cd -</td><td>回到上一次所在目录</td></tr><tr><td align="center">cd ..</td><td>回到当前目录的上一级目录</td></tr><tr><td align="center">cd -P</td><td>跳转到实际物理路径，而非快捷方式路径</td></tr></tbody></table><ol start="4"><li>mkdir：Make directory；创建新目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 要创建的目录</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-p</td><td>一次创建多层目录</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# mkdir a c #创建a和c目录</span><br><span class="line">[root@hadoop100 ~]# mkdir -p a/b/c #a中创建b,c两层目录</span><br></pre></td></tr></table></figure><ol start="5"><li>rmdir：Remove directory；删除空目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# rmdir c #创建c目录</span><br><span class="line">[root@hadoop100 ~]# rmdir -p a/b/c #依次删除c,b,a三层空目录</span><br></pre></td></tr></table></figure><ol start="6"><li>touch：创建空文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# touch a #不带后缀名默认为文本文件</span><br></pre></td></tr></table></figure><blockquote><p>vim其实也可以创建文件，退出时需要保存</p></blockquote><ol start="7"><li>cp：复制文件或目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] source dest （功能描述：复制source文件到dest）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-r</td><td>递归复制整个文件夹</td></tr></tbody></table><blockquote><p>cp 是 cp -i 的别名</p></blockquote><p>强制覆盖不提示的方法：\cp</p><ol start="8"><li>rm：删除文件或目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] deleteFile （功能描述：递归删除目录中所有内容）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-r</td><td>递归删除目录中所有内容</td></tr><tr><td align="center">-f</td><td>强制执行删除操作，而不提示用于进行确认</td></tr><tr><td align="center">-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# rm -rf /* #删除根目录下所有文件（梗）</span><br></pre></td></tr></table></figure><ol start="9"><li>mv：移动文件与目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv oldNameFile newNameFile （功能描述：重命名）</span><br><span class="line">mv /temp/movefile /targetFolder （功能描述：移动文件）</span><br></pre></td></tr></table></figure><ol start="10"><li>cat：查看文件内容</li></ol><p>查看文件内容，从第一行开始显示。一般用于查看简短文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 要查看的文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能描述</th></tr></thead><tbody><tr><td align="center">-n</td><td>显示所有行的行号，包括空行。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# cat -n hello #查看文件内容并显示行号</span><br></pre></td></tr></table></figure><ol start="11"><li>more：文件内容分屏查看器</li></ol><p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">操作</th><th>功能说明</th></tr></thead><tbody><tr><td align="center">空白键 (space)</td><td>向下翻一页；</td></tr><tr><td align="center">Enter</td><td>向下翻『一行』；</td></tr><tr><td align="center">q</td><td>立刻离开 more ，不再显示该文件内容</td></tr><tr><td align="center">Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td align="center">Ctrl+B</td><td>返回上一屏</td></tr><tr><td align="center">&#x3D;</td><td>输出当前行的行号</td></tr><tr><td align="center">:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><blockquote><p>pageDown 和 pageUp 也有效</p></blockquote><ol start="12"><li>less：分屏显示文件内容</li></ol><p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">操作</th><th>功能说明</th></tr></thead><tbody><tr><td align="center">空白键</td><td>向下翻动一页；</td></tr><tr><td align="center">[pagedown]</td><td>向下翻动一页</td></tr><tr><td align="center">[pageup]</td><td>向上翻动一页；</td></tr><tr><td align="center">&#x2F;字串</td><td>向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td></tr><tr><td align="center">?字串</td><td>向上搜寻『字串』的功能；n：向上查找；N：向下查找；</td></tr><tr><td align="center">q</td><td>离开 less 这个程序；</td></tr></tbody></table><blockquote><p>用SecureCRT时[pagedown]和[pageup]可能会出现无法识别的问题。</p></blockquote><ol start="13"><li>echo：输出内容到控制台</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br></pre></td></tr></table></figure><p>-e：支持反斜线控制的字符转换</p><table><thead><tr><th align="center">控制字符</th><th>作用</th></tr></thead><tbody><tr><td align="center">\</td><td>输出\本身</td></tr><tr><td align="center">\n</td><td>换行符</td></tr><tr><td align="center">\t</td><td>制表符，也就是 Tab 键</td></tr></tbody></table><ol start="14"><li>head：显示文件头部内</li></ol><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head 文件 （功能描述：查看文件头10行内容）</span><br><span class="line">head -n x 文件 （功能描述：查看文件头x行内容）</span><br></pre></td></tr></table></figure><ol start="15"><li>tail：输出文件尾部内容</li></ol><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail 文件 （功能描述：查看文件尾部10行内容）</span><br><span class="line">tail -n x 文件 （功能描述：查看文件尾部x行内容）</span><br><span class="line">tail -f 文件 （功能描述：实时追踪该文档的所有更新）</span><br></pre></td></tr></table></figure><blockquote><p>使用 tail -f 指令时，可以显示追加的数据，如果复写会报错</p><p>注意：使用vim修改的文件不能继续追踪（vim修改后，文件的索引号会变）</p><p>ctrl+s：暂停；ctrl+q：继续；ctrl+c：退出</p></blockquote><ol start="16"><li>&gt;：输出重定向和 &gt;&gt;：追加</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; 文件 （功能描述：列表的内容写入文件中（覆盖写））</span><br><span class="line">ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件的末尾）</span><br><span class="line">cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）</span><br><span class="line">echo “内容” &gt;&gt; 文件 （将字符内容追加到文件末尾）</span><br></pre></td></tr></table></figure><blockquote><p>Linux中 &lt; 作为输入重定向<br>17. ln：软链接</p></blockquote><p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放 了链接其他文件的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</span><br></pre></td></tr></table></figure><p>注意：删除软链接使用 rm -rf 软链接名，而不是 rm -rf 软链接名&#x2F;</p><p><strong>如果使用 rm -rf 软链接名&#x2F;  删除，会把软链接对应的真实目录下内容删掉</strong></p><p>拓展：</p><p>硬链接：ln [原文件] [硬链接名] </p><p>创建的硬链接名与源文件为同一个inode（文件的索引号），所以源文件删除对硬链接没有影响；不能链接目录使用较少。</p><blockquote><p>软链接：b -&gt; a -&gt; inode；硬链接：a -&gt; idode;b -&gt; idode；</p><p>软链接类似快捷键；硬链接类似复制</p></blockquote><ol start="18"><li>history：查看已经执行过历史命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# history</span><br><span class="line">[root@hadoop100 ~]# history 10   #显示最近使用的10条命令</span><br><span class="line">[root@hadoop100 ~]# !命令历史编号 #复现命令</span><br><span class="line">[root@hadoop100 ~]# history -c   #清除记录</span><br></pre></td></tr></table></figure><h2 id="时间日期命令"><a href="#时间日期命令" class="headerlink" title="时间日期命令"></a>时间日期命令</h2><ol><li>date</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [OPTION]... [+FORMAT]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">&lt;+日期时间格式&gt;</td><td>指定显示时使用的日期时间格式</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# date         （功能描述：显示当前时间）</span><br><span class="line">[root@hadoop100 ~]# date +%Y     （功能描述：显示当前年份）</span><br><span class="line">[root@hadoop100 ~]# date +%m     （功能描述：显示当前月份）</span><br><span class="line">[root@hadoop100 ~]# date +%d     （功能描述：显示当前是哪一天）</span><br><span class="line">[root@hadoop100 ~]# date +%s     （功能描述：显示当前时间戳）</span><br><span class="line">[root@hadoop100 ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot; （功能描述：固定格式显示年月日时分秒）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-d&lt;时间字符串&gt;</td><td>显示指定的“时间字符串”表示的时间，而非当前时间</td></tr><tr><td align="center">-s&lt;日期时间&gt;</td><td>设置系统日期时间</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -d &#x27;1 days ago&#x27; （功能描述：显示前一天时间）</span><br><span class="line">date -d &#x27;-1 days ago&#x27; （功能描述：显示明天时间）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s 字符串时间</span><br><span class="line">[root@hadoop100 ~]# date -s &quot;2017-06-19 20:52:18&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>cal：查看日历</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] （功能描述：不加选项，显示本月日历）</span><br><span class="line">[root@hadoop100 ~]# cal -3   #显示本月及前后月的日历</span><br><span class="line">[root@hadoop100 ~]# cal 2022 #显示2022年日历</span><br></pre></td></tr></table></figure><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><ol><li>useradd：添加新用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 （功能描述：添加新用户）</span><br><span class="line">useradd -g 组名 用户名 （功能描述：添加新用户到某个组）</span><br><span class="line">useradd -d /home/文件名 用户名 （以新目录名作为新用户的主文件夹）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# useradd John</span><br></pre></td></tr></table></figure><ol start="2"><li>passwd：设置用户密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名 （功能描述：设置用户密码）</span><br></pre></td></tr></table></figure><blockquote><p>当密码过于简单或不满8位，会有提示，再次输入相同密码即可</p></blockquote><ol start="3"><li>id：查看用户是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure><ol start="4"><li>查看创建了哪些用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><blockquote><p>当然也可以使用less查看，Linux系统中有很多系统用户（伪用户）</p></blockquote><ol start="5"><li>su：swith user；切换用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su 用户名称 （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量）</span><br><span class="line">su - 用户名称 （功能描述：切换到用户并获得该用户的环境变量及执行权限）</span><br></pre></td></tr></table></figure><blockquote><p>用户跳转是会话的嵌套，可以使用exit回到上一级用户</p><p>who am i：显示会话最外层用户名</p><p>whoami：显示当前会话用户名</p></blockquote><ol start="6"><li>sudo：设置普通用户具有 root 权</li></ol><p><strong>使用sudo指令必修修改sudoers配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/sudoers</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">John ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>或者配置成采用 sudo 命令时，不需要输入密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">John ALL=(ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>修改完毕后登录 John 帐号，可以用命令 sudo 获得 root 权限进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[John@hadoop100 root]# sudo ls</span><br></pre></td></tr></table></figure><ol start="7"><li>userdel：删除用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名 （功能描述：删除用户但保存用户主目录）</span><br><span class="line">userdel -r 用户名 （功能描述：用户和用户主目录，都删除）</span><br></pre></td></tr></table></figure><blockquote><p>-r 删除用户的同时，删除与用户相关的所有文件。</p></blockquote><ol start="8"><li>usermod：修改用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure><blockquote><p>-g 修改用户的初始登录组，给定的组必须存在。默认组 id 是 1。</p></blockquote><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同。</p><p>Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 </p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 &#x2F;etc&#x2F;group文件的更新。</p><ol><li>groupadd：新增组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><ol start="2"><li>groupdel：删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><ol start="3"><li>groupmod：修改组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod -n 新组名 老组名</span><br></pre></td></tr></table></figure><blockquote><p>-n&lt;新组名&gt; 指定工作组的新组名</p></blockquote><ol start="4"><li>查看有哪些组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure><blockquote><p>wheel：管理员组（一个用户可以有多个组）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheelALL=(ALL)ALL</span><br></pre></td></tr></table></figure><h2 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属 的用户和组。</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203857.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203857.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fa58a361ca44b6de4027be67e4e01c22.png"></p><ol><li><p>首位0表示类型：</p><ul><li>- 代表文件 </li><li>d 代表目录 </li><li>l 链接文档(link file)</li><li>c 代表二进制设备（鼠标等）</li><li>b 代表块设备（硬盘等）</li></ul></li><li><p>第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p></li><li><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p></li><li><p>第7-9位确定其他用户拥有该文件的权限 —Other</p></li></ol><p>rwx 作用文件和目录：</p><p>文件：</p><ul><li>[ r ]代表可读(read): 可以读取，查看</li><li>[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</li><li>[ x ]代表可执行(execute):可以被系统执行</li></ul><p>目录：</p><ul><li>[ r ]代表可读(read): 可以读取，ls查看目录内容</li><li>[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</li><li>[ x ]代表可执行(execute):可以进入该目录</li></ul><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203904.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fac5bbe006d4efe2afcd84b57057ba8d.png"></p><p>每行列出的信息依次是： 文件类型与权限；链接数；文件属主；文件属组；文件大小(用byte表示)；建立或最近修改的时间；文件名</p><blockquote><p>如果查看到是文件：链接数指的是硬链接个数。</p><p>如果查看的是文件夹：链接数指的是子文件夹个数。</p></blockquote><p>Linux系统默认使用的是UGO（User、Group、Other）权限控制策略，是一种粗粒度的权限管理策略。</p><ol><li>chmod：改变权限</li></ol><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203908.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203908.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0e843a36c2807b7d148d47a7025c5032.png"></p><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] 文件或目录</span><br></pre></td></tr></table></figure><blockquote><p>u:所有者；g:所有组；o:其他人；a:所有人(u、g、o 的总和)</p><p>+：添加权限；-：移除权限</p></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# chmod a=rwx hello</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [mode=421] [文件或目录] </span><br></pre></td></tr></table></figure><blockquote><p>r&#x3D;4 w&#x3D;2 x&#x3D;1；以二进制设定权限</p></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# chmod 644 hello #即 rw-r--r--(110100100)</span><br><span class="line">#修改文件夹中所有文件的所有者、所属组及其他用户都具有读写执行权限。</span><br><span class="line">[root@hadoop100 ~]# chmod -R 777 公共</span><br></pre></td></tr></table></figure><ol start="2"><li>chown：改变所有者</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] [最终用户] （功能描述：改变文件或者目录的所有者）</span><br></pre></td></tr></table></figure><blockquote><p>-R：递归操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#递归改变文件所有者和所有组</span><br><span class="line">[root@hadoop100 xiyou]# ll</span><br><span class="line">drwxrwxrwx. 2 root root 4096 9 月 3 21:20 xiyou</span><br><span class="line">[root@hadoop100 xiyou]# chown -R atguigu:atguigu xiyou/</span><br><span class="line">[root@hadoop100 xiyou]# ll</span><br><span class="line">drwxrwxrwx. 2 atguigu atguigu 4096 9 月 3 21:20 xiyou</span><br></pre></td></tr></table></figure><ol start="3"><li>chgrp：改变所属组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [最终用户组] [文件或目录] （功能描述：改变文件或者目录的所属组）</span><br></pre></td></tr></table></figure><h2 id="搜索查找命令"><a href="#搜索查找命令" class="headerlink" title="搜索查找命令"></a>搜索查找命令</h2><ol><li>find：查找文件或者目录</li></ol><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">常用选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td align="center">-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td align="center">-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件,单位为: b —— 块（512 字节）；c —— 字节；w —— 字（2 字节）；k —— 千字节；M —— 兆字节；G —— 吉字节</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查找当前目录下以txt结尾的文件</span><br><span class="line">[root@hadoop101 ~]# find -name &quot;*.txt&quot;</span><br><span class="line">#查找用户名为Leamon的所有文件</span><br><span class="line">[root@hadoop101 ~]# find / -user Leamon</span><br><span class="line">#查找大于200m的文件（+n 大于；-n 小于；n 等于）</span><br><span class="line">[root@hadoop101 ~]find / -size +200M</span><br></pre></td></tr></table></figure><ol start="2"><li>locate：快速定位文件路径</li></ol><p>locate 指令利用事先建立在系统中含有所有文件名称及路径的 locate 数据库实现快速定位文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updatedb #更新数据库</span><br><span class="line">locate 搜索文件</span><br></pre></td></tr></table></figure><ol start="3"><li>查询命令所在的路径</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which [命令]</span><br><span class="line">whereis [命令]</span><br></pre></td></tr></table></figure><ol start="4"><li>grep：过滤查找及”|”管道符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 选项 查找内容 源文件</span><br></pre></td></tr></table></figure><blockquote><p>-n：显示匹配行及行号。<br/>-i：忽略大小写。<br/>-m：只显示查询结果的第一行。</p></blockquote><p>管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查找cfg后缀的文件并列出</span><br><span class="line">[root@hadoop100 ~]# ls | grep -n .cfg </span><br><span class="line">1:anaconda-ks.cfg</span><br><span class="line">2:initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><p>拓展：wc：统计数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# ls | wc </span><br><span class="line">     10      10      93</span><br></pre></td></tr></table></figure><blockquote><p>统计的三个数据分别是行数，数据个数（空格间断），字节大小</p></blockquote><h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><ol><li>gzip&#x2F;gunzip：压缩&#x2F;解压</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件）</span><br><span class="line">gunzip 文件.gz （功能描述：解压缩文件命令）</span><br></pre></td></tr></table></figure><blockquote><p>只能压缩文件不能压缩目录；不保留原来的文件；同时多个文件会产生多个压缩包</p></blockquote><ol start="2"><li>zip&#x2F;unzip：压缩&#x2F;解压缩</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] XXX.zip 将要压缩的内容 （功能描述：压缩文件和目录的命令）</span><br><span class="line">unzip [选项] XXX.zip （功能描述：解压缩文件）</span><br></pre></td></tr></table></figure><blockquote><p>zip 选项：-r；压缩目录</p><p>unzip 选项：-d&lt;目录&gt;；指定解压后文件的存放目录</p><p>zip 压缩命令在windows&#x2F;linux都通用，可以压缩目录且保留源文件。</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203915.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203915.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2f24f5e33d306a2070a282408c7848ad.png"></p><ol start="3"><li>tar：打包</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 将要打包进去的内容 （功能描述：打包目录，压缩后的文件格式为.tar.gz）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-c</td><td>产生.tar打包文件</td></tr><tr><td align="center">-v</td><td>显示详细信息</td></tr><tr><td align="center">-f</td><td>指定压缩后的文件名</td></tr><tr><td align="center">-z</td><td>打包同时压缩</td></tr><tr><td align="center">-x</td><td>解包.tar文件</td></tr><tr><td align="center">-C</td><td>解压到指定目录</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#压缩打包文件</span><br><span class="line">[root@hadoop100 tmp]# tar -zcvf tmp.tar.gz yum.log packaging.log</span><br><span class="line">#解压缩解包</span><br><span class="line">[root@hadoop100 tmp]# tar -zxvf tmp.tar.gz -C /tmp/tmp</span><br></pre></td></tr></table></figure><blockquote><p>解压缩的目的目录必须存在才能解压成功</p></blockquote><h2 id="磁盘查看和分区命令"><a href="#磁盘查看和分区命令" class="headerlink" title="磁盘查看和分区命令"></a>磁盘查看和分区命令</h2><p>安装tree工具；用于查看嵌套的文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# yum install tree</span><br></pre></td></tr></table></figure><ol><li>du：查看文件和目录占用的磁盘空间</li></ol><p>du：disk usage；磁盘占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du 目录/文件 （功能描述：显示目录下每个子目录的磁盘使用情况）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr><tr><td align="center">-a</td><td>不仅查看子目录大小，还要包括文件</td></tr><tr><td align="center">-c</td><td>显示所有的文件和子目录大小后，显示总和</td></tr><tr><td align="center">-s</td><td>只显示总和</td></tr><tr><td align="center">–max-depth&#x3D;n</td><td>指定统计子目录的深度为第 n 层</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# du -sh #查看目录占用的磁盘空间大小</span><br></pre></td></tr></table></figure><ol start="2"><li>df：查看磁盘空间使用情况</li></ol><p>df：disk free；空余磁盘</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203921.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203921.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b17f911816881949cbdf0b29c4321747.png"></p><blockquote><p>其中tmpfs为分配的内存；&#x2F;dev&#x2F;shm：shared memory，共享内存；devtmpfs在Linux内核一开始启动时创建dev目录，来管理所有设备</p></blockquote><p>拓展：</p><p>free：查看内存使用情况</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203925.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203925.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fed94d1501ed2cc4b09c7ae982a18d8b.png"></p><ol start="3"><li>lsblk：查看设备挂载情况</li></ol><blockquote><p>选项：-f；查看详细的设备挂载情况，显示文件系统信息</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203926.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203926.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="97f723ad7a42fd955a1f5ef1ed8592db.png"></p><blockquote><p>sr0 是安装系统时的使用的光驱镜像文件</p></blockquote><ol start="4"><li>mount&#x2F;umount：挂载&#x2F;卸载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [-t vfstype] [-o options] device dir （功能描述：挂载设备）</span><br><span class="line">umount 设备文件名或挂载点 （功能描述：卸载设备）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">-t vfstype</td><td>指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<br>光盘或光盘镜像：iso9660<br>DOS fat16 文件系统：msdos<br/>Windows 9x fat32 文件系统：vfat<br/>Windows NT ntfs 文件系统：ntfs<br/>Mount Windows 文件网络共享：smbfs<br/>UNIX(LINUX) 文件网络共享：nfs</td></tr><tr><td align="center">-o options</td><td>主要用来描述设备或档案的挂接方式。常用的参数有：<br>loop：用来把一个文件当成硬盘分区挂接上系统<br>ro：采用只读方式挂接设备<br/>rw：采用读写方式挂接设备<br/>iocharset：指定访问文件系统所用字符集</td></tr><tr><td align="center">device</td><td>要挂接(mount)的设备</td></tr><tr><td align="center">dir</td><td>设备在系统上的挂接点(mount point)</td></tr></tbody></table><p>在VMware虚拟机的设置中打开光盘驱动器的连接</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203936.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203936.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fad724d3c0a2ef3802e83d284ae6a493.png"></p><p>可以看到自动挂载的挂载点；我们可以将它卸载后进行手动挂载</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203937.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203937.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="76b0d3de01ee64c68c4e0c61124548f7.png"></p><p>设置开机自动挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203941.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203941.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="18e545c15813de36fabc43d8fd0f5951.png"></p><blockquote><p>由左到右分别是：设备的uuid或设备名；挂载点；文件系统的类型；dump选项（是否定期备份）；系统检查的优先级（fsck：文件系统的检查，1最高）</p></blockquote><ol start="5"><li>fdisk：分区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l （功能描述：显示所有硬盘的分区列表）</span><br><span class="line">fdisk 硬盘设备名 （功能描述：对新增硬盘进行分区操作）</span><br></pre></td></tr></table></figure><blockquote><p>该命令必须在 root 用户下才能使用</p></blockquote><p>使用fdisk命令分区后，还需要对新加硬盘进行格式化（lsblk-f命令可以看到新加硬盘没有uuid和挂载点）分配uuid</p><p>格式化命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t xfs [设备名称]</span><br></pre></td></tr></table></figure><blockquote><p>mkfs：创建文件系统；-t：指定当前文件系统类型</p></blockquote><p>使用mount命令将新加硬盘挂载在需要使用的目录</p><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><ol><li>ps：查看当前系统进程状态</li></ol><p>ps:process status 进程状态</p><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">a</td><td>列出带有终端的所有用户的进程</td></tr><tr><td align="center">x</td><td>列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td align="center">u</td><td>面向用户友好的显示风格</td></tr><tr><td align="center">-e</td><td>列出所有进程</td></tr><tr><td align="center">-u</td><td>列出某个用户关联的所有进程</td></tr><tr><td align="center">-f</td><td>显示完整格式的进程列表</td></tr></tbody></table><blockquote><p>前三种是BSD风格；后三种是标准的UNIX风格</p></blockquote><p>常用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">（信息说明）</span><br><span class="line">USER：该进程是由哪个用户产生的</span><br><span class="line">PID：进程的 ID 号</span><br><span class="line">%CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；</span><br><span class="line">%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</span><br><span class="line">VSZ：该进程占用虚拟内存的大小，单位 KB；</span><br><span class="line">RSS：该进程占用实际物理内存的大小，单位 KB；</span><br><span class="line">TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1是图形化终端，ty2-tty6 是本地的字符界面终端；pts/0-255 代表虚拟终端。</span><br><span class="line">STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示、&lt;/N：优先级高/低</span><br><span class="line">START：该进程的启动时间</span><br><span class="line">TIME：该进程占用 CPU 的运算时间，注意不是系统时间</span><br><span class="line">COMMAND：产生此进程的命令名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">(信息说明)</span><br><span class="line">UID：用户 ID</span><br><span class="line">PPID：父进程 ID</span><br><span class="line">C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</span><br><span class="line">STIME：进程启动的时间</span><br><span class="line">CMD：启动进程所用的命令和参数</span><br></pre></td></tr></table></figure><blockquote><p>想查看进程的 CPU 占用率和内存占用率，可以使用 aux；想查看进程的父进程 ID 可以使用 -ef；</p></blockquote><ol start="2"><li>kill：终止进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] 进程号 （功能描述：通过进程号杀死进程）</span><br><span class="line">killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这</span><br><span class="line">在系统因负载过大而变得很慢时很有用）</span><br></pre></td></tr></table></figure><blockquote><p>选项：-9；表示强迫进程立即停止</p></blockquote><ol start="3"><li>pstree：查看进程树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-p</td><td>显示进程的 PID</td></tr><tr><td align="center">-u</td><td>显示进程的所属用户</td></tr></tbody></table><ol start="4"><li>top：实时监控系统进程状态</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-d 秒数</td><td>指定 top 命令每隔几秒更新。默认是 3 秒</td></tr><tr><td align="center">-i</td><td>使 top 不显示任何闲置或者僵死进程。</td></tr><tr><td align="center">-p</td><td>通过指定监控进程 ID 来仅仅监控某个进程的状</td></tr></tbody></table><table><thead><tr><th align="center">操作</th><th>功能</th></tr></thead><tbody><tr><td align="center">P</td><td>以 CPU 使用率排序，默认就是此项</td></tr><tr><td align="center">M</td><td>以内存的使用率排序</td></tr><tr><td align="center">N</td><td>以 PID 排序</td></tr><tr><td align="center">q</td><td>退出 top</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203947.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203947.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1aaeb1f7e343e44ddbf9b07cbc3bb836.png"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一行信息为任务队列信息:系统当前时间;</span><br><span class="line">up 系统的运行时间；</span><br><span class="line">登录的用户数量（终端+图形化界面）；</span><br><span class="line">load average 系统在之前 1 分钟，5 分钟，15 分钟的平均负载。（小于0.7，负载较小；大于1，系统已经超出负荷）</span><br><span class="line"></span><br><span class="line">第二行为进程信息：Tasks 系统中的进程总数；</span><br><span class="line">正在运行的进程数；</span><br><span class="line">睡眠的进程；</span><br><span class="line">正在停止的进程；</span><br><span class="line">僵尸进程。如果不是 0，需要手工检查僵尸进程。</span><br><span class="line"></span><br><span class="line">第三行为 CPU 信息：us 用户模式占用的 CPU 百分比；（默认情况下没有专门修改优先级的用户进程）</span><br><span class="line">sy 系统模式占用的 CPU 百分比；</span><br><span class="line">ni 改变过优先级的用户进程占用的 CPU 百分比；</span><br><span class="line">id 空闲 CPU 的 CPU 百分比；</span><br><span class="line">wa 等待输入/输出的进程的占用 CPU 百分比；</span><br><span class="line">hi 硬中断请求服务占用的 CPU 百分比；</span><br><span class="line">si 软中断请求服务占用的 CPU 百分比</span><br><span class="line">st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比。</span><br><span class="line"></span><br><span class="line">第四行为物理内存信息：物理内存的总量，单位 KB；</span><br><span class="line">used 已经使用的物理内存数量；</span><br><span class="line">free 空闲的物理内存数量；</span><br><span class="line">buffers 作为缓冲的内存数量。</span><br><span class="line"></span><br><span class="line">第五行为交换分区（swap）信息：同上</span><br><span class="line"></span><br><span class="line">表格：PR:任务调度的优先级；</span><br><span class="line">NI:用户指定的进程调度运行的nice值（越低优先级越高）；</span><br><span class="line">VIRT：虚拟内存占用的大小；</span><br><span class="line">RES：物理内存占用的大小；SHR：共享内存占用的大小；</span><br><span class="line">S:进程状态</span><br></pre></td></tr></table></figure><blockquote><p>在top界面按 u 可以查看指定用户进程；按 k 可以kill指定进程</p></blockquote><ol start="5"><li>netstat：显示网络状态和端口占用信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 进程号 （功能描述：查看该进程网络信息）</span><br><span class="line">netstat –nlp | grep 端口号 （功能描述：查看网络端口号占用情况）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-a</td><td>显示所有正在监听（listen）和未监听的套接字（socket）</td></tr><tr><td align="center">-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td align="center">-l</td><td>仅列出在监听的服务状态</td></tr><tr><td align="center">-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# netstat -anp | less</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203950.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817203950.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="59671197912d0fc820be7dd0611ed4de.png"></p><blockquote><p>Proto：网络协议；<br>Recv-Q：用户程序接收但还未拷贝出来的字节数；<br>Send-Q：已发送但远程主机还未确认收到的字节数；<br>Local Address：本地地址；（0.0.0.0表示本本地的所有地址）<br>Foreign Address：远程地址；（Socket形式：[ip:端口号]）<br>State：网络连接状态；<br>PID&#x2F;Program name：进程id&#x2F;进程名字</p></blockquote><h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><p>系统定时任务的命令需要启用守护进程crond：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status crond</span><br></pre></td></tr></table></figure><ul><li>crontab：定时任务设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-e</td><td>编辑 crontab 定时任务</td></tr><tr><td align="center">-l</td><td>查询 crontab 任务</td></tr><tr><td align="center">-r</td><td>删除当前用户所有的 crontab 任务</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# crontab -e</span><br></pre></td></tr></table></figure><blockquote><p>进入crontab编辑界面，会打开vim编辑工作；</p><p>编写格式：* * * * * 命令</p></blockquote><table><thead><tr><th align="center">项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td align="center">第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td align="center">第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td align="center">第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td align="center">第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td align="center">第五个“*”</td><td>一周当中的星期几</td><td>0-7 （ 0 和 7 都 代 表 星 期 日）</td></tr></tbody></table><p>特殊符号：</p><table><thead><tr><th align="center">特殊符号</th><th>含义</th></tr></thead><tbody><tr><td align="center">*</td><td>代表任何时间。比如第一个“*”就代表一小时中每分钟 都执行一次的意思。</td></tr><tr><td align="center">,</td><td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表 在每天的 8 点 0 分，12 点 0 分，16 点 0</td></tr><tr><td align="center">-</td><td>代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在 周一到周六的凌晨 5 点 0 分执行命令</td></tr><tr><td align="center">*&#x2F;n</td><td>代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”，代 表每隔 10 分钟就执行一遍命令</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# crontab -e</span><br><span class="line">[root@hadoop100 ~]# crontab -l</span><br><span class="line">#每分钟向/root/hello文件追加字符串</span><br><span class="line">* * * * * echo &quot;hello,world!&quot; &gt;&gt; /root/hello</span><br><span class="line">[root@hadoop100 ~]# crontab -r</span><br></pre></td></tr></table></figure><h1 id="6-软件包管理"><a href="#6-软件包管理" class="headerlink" title="6. 软件包管理"></a>6. 软件包管理</h1><h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe，是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><p>RPM包的名称格式：Apache-1.3.23-11.i386.rpm </p><ul><li>“apache” 软件名称 </li><li>“1.3.23-11”软件的版本号，主版本和此版本 </li><li>“i386”是软件所运行的硬件平台，Intel 32位处理器的统称</li><li>“rpm”文件扩展名，代表RPM包</li></ul><ol><li>RPM：查询命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa （功能描述：查询所安装的所有 rpm 软件包）</span><br><span class="line">rpm -qi 软件名 （查询软件的详细信息）</span><br></pre></td></tr></table></figure><blockquote><p>由于软件包比较多，一般都会采取过滤。rpm -qa | grep 软件包</p></blockquote><ol start="2"><li>RPM：卸载命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 软件包 （卸载软件包）</span><br><span class="line">rpm -e --nodeps 软件包 （卸载软件时，不检查依赖。）</span><br></pre></td></tr></table></figure><blockquote><p>卸载软件时不检查依赖可能会导致那些使用该软件包的软件在此之后不能正常工作。谨慎使用</p></blockquote><ol start="3"><li>RPM：安装命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh RPM包全名</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>功能</th></tr></thead><tbody><tr><td align="center">-i</td><td>install，安装</td></tr><tr><td align="center">-v</td><td>–verbose，显示详细信息</td></tr><tr><td align="center">-h</td><td>–hash，进度条</td></tr><tr><td align="center">–nodeps</td><td>安装前不检查依赖</td></tr></tbody></table><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</p><blockquote><p>YUM类似于Java开发中的maven工具，可以从镜像网站下载应用程序并安装</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [选项] [参数]</span><br></pre></td></tr></table></figure><blockquote><p>选项：-y；对所有提问都回答“yes”</p></blockquote><table><thead><tr><th align="center">参数</th><th>功能</th></tr></thead><tbody><tr><td align="center">install</td><td>安装 rpm 软件包</td></tr><tr><td align="center">update</td><td>更新 rpm 软件包</td></tr><tr><td align="center">check-update</td><td>检查是否有可用的更新 rpm 软件包</td></tr><tr><td align="center">remove</td><td>删除指定的 rpm 软件包</td></tr><tr><td align="center">list</td><td>显示软件包信息</td></tr><tr><td align="center">clean</td><td>清理 yum 过期的缓存</td></tr><tr><td align="center">deplist</td><td>显示 yum 软件包的所有依赖关系</td></tr><tr><td align="center">search</td><td>查找命令所在的包</td></tr></tbody></table><p>修改网络 YUM 源：</p><blockquote><p>其实yum会根据所在地自动选择镜像网站</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1.安装 wget, wget 用来从指定的 URL 下载文件</span><br><span class="line">[root@hadoop101 ~] yum install wget</span><br><span class="line">#2.在/etc/yum.repos.d/目录下，备份默认的 repos 文件</span><br><span class="line">[root@hadoop101 yum.repos.d] pwd</span><br><span class="line">/etc/yum.repos.d</span><br><span class="line">[root@hadoop101 yum.repos.d] cp CentOS-Base.repo CentOS-Base</span><br><span class="line">.repo.backup</span><br><span class="line">#3.下载网易 163 或者是 aliyun 的 repos 文件,任选其一</span><br><span class="line">[root@hadoop101 yum.repos.d] wget http://mirrors.aliyun.com/repo/Centos-7.repo //阿里云</span><br><span class="line">[root@hadoop101 yum.repos.d] wget http://mirrors.163.com/.help/CentOS7-Base-163.repo //网易 163</span><br><span class="line">#4.使用下载好的 repos 文件替换默认的 repos 文件</span><br><span class="line">[root@hadoop101 yum.repos.d]# mv CentOS7-Base-163.repo CentOS-Base.repo</span><br><span class="line">#5.清理旧缓存数据，缓存新数据</span><br><span class="line">[root@hadoop101 yum.repos.d]#yum clean all</span><br><span class="line">[root@hadoop101 yum.repos.d]#yum makecache</span><br><span class="line">#yum makecache 就是把服务器的包信息下载到本地电脑缓存起来</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具快捷键</title>
      <link href="/2023/08/17/%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/08/17/%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h1><h2 id="快捷键默认为windows"><a href="#快捷键默认为windows" class="headerlink" title="快捷键默认为windows"></a>快捷键默认为windows</h2><h3 id="调换格式"><a href="#调换格式" class="headerlink" title="调换格式"></a>调换格式</h3><table><thead><tr><th align="center">按键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl + alt + L</td><td align="center">格式化代码</td></tr><tr><td align="center">ctrl + Y</td><td align="center">删除一行</td></tr><tr><td align="center">ctrl + D</td><td align="center">向下复制一行</td></tr><tr><td align="center">ctrl + X</td><td align="center">剪切</td></tr><tr><td align="center">ctrl + &#x2F;</td><td align="center">单行注释</td></tr><tr><td align="center">ctrl + shift + &#x2F;</td><td align="center">多行注释</td></tr><tr><td align="center">alt + shift + ↑</td><td align="center">向上移动</td></tr><tr><td align="center">alt + shift + ↓</td><td align="center">向下移动</td></tr><tr><td align="center">ctrl + G</td><td align="center">快速定位行</td></tr><tr><td align="center">ctrl + R</td><td align="center">查找后替换</td></tr><tr><td align="center">alt + ←</td><td align="center">返回上一个文件</td></tr><tr><td align="center">alt + shift + ←</td><td align="center">返回上一个操作点</td></tr><tr><td align="center">ctrl + shift + u</td><td align="center">切换大小写</td></tr></tbody></table><h3 id="快速出代码"><a href="#快速出代码" class="headerlink" title="快速出代码"></a>快速出代码</h3><table><thead><tr><th align="center">按键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">输 main</td><td align="center">生成main方法</td></tr><tr><td align="center">输 sout</td><td align="center">输出语句</td></tr><tr><td align="center">alt + enter</td><td align="center">代码修正提示</td></tr><tr><td align="center">ctrl + J</td><td align="center">弹出快捷代码提示</td></tr><tr><td align="center">alt + insert</td><td align="center">实现方法&#x2F;toString&#x2F;构造方法&#x2F;重写方法 (insert键在delete键旁边)</td></tr><tr><td align="center">ctrl + alt + T</td><td align="center">快速包裹代码,比如if for try catch synchronized..(先选中代码)</td></tr><tr><td align="center">ctrl + alt + V</td><td align="center">快速声明一个变量，本地变量赋值(先写new对象())</td></tr><tr><td align="center">ctrl + I</td><td align="center">重写需要实现的方法</td></tr><tr><td align="center">ctrl + O</td><td align="center">查看所有可以重写的方法</td></tr></tbody></table><h3 id="查看类和方法"><a href="#查看类和方法" class="headerlink" title="查看类和方法"></a>查看类和方法</h3><table><thead><tr><th align="center">按键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ctrl + 鼠标左键</td><td align="center">查看鼠标选中的类或方法</td></tr><tr><td align="center">ctrl + F12</td><td align="center">查看类中所有的方法</td></tr><tr><td align="center">ctrl + H</td><td align="center">查看方法或类的层级关系</td></tr><tr><td align="center">ctrl + alt + H</td><td align="center">此方法的调用关系(先选中方法)</td></tr><tr><td align="center">Ctrl + Shift + 加号</td><td align="center">展开方法(先选中方法)</td></tr><tr><td align="center">Ctrl + Shift + 减号</td><td align="center">折叠方法(先选中方法)</td></tr><tr><td align="center">Ctrl + F7</td><td align="center">查找方法在当前类使用的地方(先选中方法)</td></tr><tr><td align="center">Ctrl+Shift+N</td><td align="center">按文件名搜索文件</td></tr><tr><td align="center">Ctrl+Shift+F</td><td align="center">全局搜索</td></tr><tr><td align="center">Shift+Shift</td><td align="center">搜索</td></tr></tbody></table><h3 id="全局类操作"><a href="#全局类操作" class="headerlink" title="全局类操作"></a>全局类操作</h3><table><thead><tr><th align="center">按键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">alt + 1</td><td align="center">打开&#x2F;隐藏 左侧项目目录结构</td></tr><tr><td align="center">alt + 4</td><td align="center">打开&#x2F;隐藏 控制台</td></tr><tr><td align="center">ctrl + alt + O</td><td align="center">自动导包或删除无用的包</td></tr><tr><td align="center">Shift + F6</td><td align="center">重命名(先选中文件)</td></tr><tr><td align="center">alt + Shift + F10</td><td align="center">打开可以启动的项目模块列表</td></tr><tr><td align="center">ctrl + N</td><td align="center">打开类&#x2F;文件</td></tr><tr><td align="center">ctrl + z</td><td align="center">上一步</td></tr><tr><td align="center">ctrl + shift + z</td><td align="center">下一步</td></tr><tr><td align="center">ctrl + shift + r</td><td align="center">全局替换</td></tr></tbody></table><h3 id="查看继承关系"><a href="#查看继承关系" class="headerlink" title="查看继承关系"></a>查看继承关系</h3><p>右键类名，进入Diagrams，其中<code>Show Diagram...</code>和<code>Show Diagram Popup...</code>分别表示在标签页中显示和在小窗口显示，接着点击<code>Java classes diagram</code>查看继承图。</p><p>进入标签页后，点击接口或类，使用快捷键<strong>ctrl+alt+b</strong>展现所有实现类，接着ctrl+a全选，回车即可自动画出结构图。</p><h1 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h1><h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><ol><li>补全代码的声明：alt + &#x2F;</li><li>快速修复: ctrl + 1</li><li>批量导包：<ins>ctrl</ins> + shift + o</li><li>使用单行注释：<ins>ctrl</ins> + &#x2F;</li><li>使用多行注释： <ins>ctrl</ins> + shift + &#x2F;</li><li>取消多行注释：<ins>ctrl</ins> + shift + \</li><li>复制指定行的代码：<ins>ctrl</ins> + <ins>alt</ins> + down 或 <ins>ctrl</ins> + <ins>alt</ins> + up</li><li>删除指定行的代码：<ins>ctrl</ins> + d</li><li>上下移动代码：<ins>alt</ins> + up 或 <ins>alt</ins> + down</li><li>切换到下一行代码空位：shift + enter</li><li>切换到上一行代码空位：<ins>ctrl</ins> + shift + enter</li><li>如何查看源码：<ins>ctrl</ins> + 选中指定的结构 或 <ins>ctrl</ins> + shift + t</li><li>退回到前一个编辑的页面：<ins>alt</ins> + left</li><li>进入到下一个编辑的页面(针对于上面那条来说的)：<ins>alt</ins> + right</li><li>光标选中指定的类，查看继承树结构：<ins>ctrl</ins> + t</li><li>复制代码： <ins>ctrl</ins> + c</li><li>撤销： <ins>ctrl</ins> + z</li><li>反撤销： <ins>ctrl</ins> + y</li><li>剪切：<ins>ctrl</ins> + x</li><li>粘贴：<ins>ctrl</ins> + v</li><li>保存： <ins>ctrl</ins> + s</li><li>全选：<ins>ctrl</ins> + a</li><li>格式化代码： <ins>ctrl</ins> + shift + f</li><li>选中数行，整体往后移动：tab</li><li>选中数行，整体往前移动：shift + tab</li><li>在当前类中，显示类结构，并支持搜索指定的方法、属性等：<ins>ctrl</ins> + o</li><li>批量修改指定的变量名、方法名、类名等：<ins>alt</ins> + shift + r</li><li>选中的结构的大小写的切换：变成大写： <ins>ctrl</ins> + shift + x</li><li>选中的结构的大小写的切换：变成小写：<ins>ctrl</ins> + shift + y</li><li>调出生成getter&#x2F;setter&#x2F;构造器等结构： <ins>alt</ins> + shift + s</li><li>显示当前选择资源(工程 or 文件)的属性：<ins>alt</ins> + enter</li><li>快速查找：参照选中的Word快速定位到下一个 ：<ins>ctrl</ins> + k</li></ol><h2 id="不太常用的："><a href="#不太常用的：" class="headerlink" title="不太常用的："></a>不太常用的：</h2><ol><li>关闭当前窗口：<ins>ctrl</ins> + w</li><li>关闭所有的窗口：<ins>ctrl</ins> + shift + w</li><li>查看指定的结构使用过的地方：<ins>ctrl</ins> + <ins>alt</ins> + g</li><li>查找与替换：<ins>ctrl</ins> + f</li><li>最大化当前的View：ctrl + m</li><li>直接定位到当前行的首位：home</li><li>直接定位到当前行的末位：end</li></ol><h2 id="二、程序调试"><a href="#二、程序调试" class="headerlink" title="二、程序调试"></a>二、程序调试</h2><ol><li>System.out.println().<ul><li>“硬看”代码，将可能有误的数据输出全部输出。</li></ul></li><li>Eclipse - Debug调试<ul><li>将可能有误的代码区段设置断点（在代码行数左侧双击左键）；</li><li>右键空白处，选择Debug As（在Run As下面）。<ul><li>Step Into(F5)：进入方法内部</li><li>Step Over(F6)：下一步（运行下一行代码）</li><li>Step Return(F7)：跳出方法回到main方法</li></ul></li></ul></li></ol><h2 id="三、Java中的JUnit单元测试"><a href="#三、Java中的JUnit单元测试" class="headerlink" title="三、Java中的JUnit单元测试"></a>三、Java中的JUnit单元测试</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</li><li>创建Java类，进行单元测试。<ul><li>此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器</li></ul></li><li>此类中声明单元测试方法。<ul><li>此时的单元测试方法：方法的权限是public,没有返回值，没有形参</li></ul></li><li>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</li><li>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</li><li>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</li></ol><p>说明：</p><ol><li>如果执行结果没有任何异常：绿条</li><li>如果执行结果出现异常：红条</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapStruct</title>
      <link href="/2023/08/17/%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/MapStruct/"/>
      <url>/2023/08/17/%E4%B8%AA%E4%BA%BA%E7%A7%AF%E7%B4%AF/MapStruct/</url>
      
        <content type="html"><![CDATA[<h1 id="MapStruct"><a href="#MapStruct" class="headerlink" title="MapStruct"></a>MapStruct</h1><p>多层应用通常需要在不同的对象模型（例如实体和DTOs）之间进行映射。</p><p>MapStruct是一个代码生成器，便捷的配置能很方便地解决两个Java bean内部字段之间的映射，在编译时生成setter&#x2F;getter代码实现的字节码，因此在真正run的时候，速度快，类型安全。</p><p>官方文档：<a href="https://mapstruct.org/documentation/reference-guide/">Reference Guide – MapStruct</a></p><h2 id="DTO模式"><a href="#DTO模式" class="headerlink" title="DTO模式"></a>DTO模式</h2><p>DTO即数据传输对象(Data Transfer Objects)。该模式是一种简单的设计模式，主要目的是通过将一次单一调用的多个参数分批来减少到服务器的往返次数，在远程操作中降低网络开销。</p><p>该实践的其它好处是序列化的逻辑（转换对象结构和数据为一种能被存储和传输的指定格式的机制）的封装。它提供了在序列化细微差别中一个单一改变点。它也解耦了表示层的领域模型，允许它们独自改变。</p><p>DTOs是平整的数据结构，不包含业务逻辑，仅仅有存储、访问和最终关联序列化或解析的方法。数据从领域模型映射为 DTO，一般通过在表示层或门面层的 mapper 组件。下方的图片说明了组件间的交互：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817200849.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230817200849.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="0f07a9a8fe50547444f5e760783cdb22.png"></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO：</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarDto</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String make;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> seatCount;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//entity:</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String make;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> numberOfSeats;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便我们进行对象间字段的映射，我们制定一个基类接口，进行统一化的定制，如果有特殊的需要，再自己去复写基类接口中的相应方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EntityConverter</span>&lt;D, E&gt; &#123;</span><br><span class="line">  E <span class="title function_">toEntity</span><span class="params">(D dto)</span>;</span><br><span class="line"></span><br><span class="line">  D <span class="title function_">toDto</span><span class="params">(E entity)</span>;</span><br><span class="line"></span><br><span class="line">  List&lt;E&gt; <span class="title function_">toEntity</span><span class="params">(List&lt;D&gt; dtoList)</span>;</span><br><span class="line"></span><br><span class="line">  List&lt;D&gt; <span class="title function_">toDto</span><span class="params">(List&lt;E&gt; entityList)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的转换类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不注入Sping容器，那么在使用时需要以下代码获取实例:</span></span><br><span class="line"><span class="comment">//CarMapper mapper = Mappers.getMapper(CarMapper.class);</span></span><br><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarMapper</span> <span class="keyword">extends</span> <span class="title class_">EntityConverter</span>&lt;CarDto, Car&gt; &#123;</span><br><span class="line">  <span class="meta">@Mapping(source = &quot;numberOfSeats&quot;, target = &quot;seatCount&quot;)</span></span><br><span class="line">  CarDto <span class="title function_">toDto</span><span class="params">(Car car)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p><code>@Mapper</code>注解中指定了<code>componentModel</code>为<code>&quot;spring&quot;</code>，即将该接口的实现类放入了IOC容器</p></li><li><p><code>@Mapping</code>中指定了两个字段，表示<code>car</code>中的字段<code>numberOfSeats</code>中的值映射到<code>CarDto</code>中的<code>seatCount</code>,这是因为mapstruct的映射是根据字段名来进行的，所以字段名不能对应的字段，他们之间的映射必须要 <strong>显式指定</strong>。</p></li><li><p>如果存在多个映射，可以使用<code>@Mappings</code></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;type.name&quot;,target = &quot;typeName&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(source = ..,target = ..),</span></span><br><span class="line"><span class="meta">            ...</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure><p>在使用MapStruct，idea2020.3版本在build项目的时候出现错误：<code>java: Internal error in the mapping processor: java.lang.NullPointerException</code></p><p>解决： <code>Setting --&gt;Build,Execution,Deployment --&gt;Compiler --&gt;User-local build</code>加上参数： <code>-Djps.track.ap.dependencies=false</code></p><h2 id="进阶属性"><a href="#进阶属性" class="headerlink" title="进阶属性"></a>进阶属性</h2><p>在映射器中忽略未映射目标属性的警告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;, unmappedTargetPolicy = ReportingPolicy.IGNORE)</span></span><br></pre></td></tr></table></figure><p>@Mappering注解的特殊属性：</p><ul><li>ignore：忽略该属性的转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappering(target=&quot;&quot;,ignore=true)</span></span><br></pre></td></tr></table></figure><ul><li>expression：可以使用函数转换属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappering(target=&quot;&quot;,expression=&quot;java(Integer.parseInt(user.getId()))&quot;)</span></span><br><span class="line">UserDto <span class="title function_">userToDto</span><span class="params">(userVo user)</span>;</span><br></pre></td></tr></table></figure><ul><li>numberFormat：格式化该元素的值</li><li>defaultValue：设置元素默认值，如果原对象的该属性为空，则使用默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappering(source = &quot;salary&quot;,target=&quot;salary&quot;,numberFormat=&quot;￥#.oo&quot;,defaultValue=&quot;￥0.00&quot;)</span></span><br><span class="line">UserDto <span class="title function_">userToDto</span><span class="params">(userVo user)</span>;</span><br></pre></td></tr></table></figure><p>反转注解：<code>@InheritInverseConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将UserDto方法的转换规则反转</span></span><br><span class="line"><span class="meta">@InheritInverseConfiguration(name=&quot;userToDto&quot;)</span></span><br><span class="line">UserVo <span class="title function_">userToVo</span><span class="params">(UserDto user)</span>;</span><br></pre></td></tr></table></figure><h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><p>MapStruct Suppot</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>实体类：</p><table><thead><tr><th align="left">Courses</th><th>CoursesVO</th></tr></thead><tbody><tr><td align="left">private Long id;</td><td>private Long id;</td></tr><tr><td align="left">private String name;</td><td>private String name;</td></tr><tr><td align="left">private String code;</td><td>private String code;</td></tr><tr><td align="left">private Integer type;</td><td>private String type;</td></tr><tr><td align="left">private Boolean open;</td><td>private String open;</td></tr><tr><td align="left">private Long category;</td><td>private Long category;</td></tr><tr><td align="left">private String describe;</td><td>private String describe;</td></tr><tr><td align="left">private Boolean excellent;</td><td>private String excellent;</td></tr><tr><td align="left">private Boolean expire;</td><td>private String expire;</td></tr><tr><td align="left">private LocalDateTime createDate;</td><td>private String createDate;</td></tr><tr><td align="left">private LocalDateTime updateDate;</td><td>private String updateDate;</td></tr><tr><td align="left">private String createrId;</td><td>private String createrId;</td></tr><tr><td align="left">private String createrName;</td><td>private String createrName;</td></tr><tr><td align="left">private String managerId;</td><td>private String managerId;</td></tr><tr><td align="left">private String managerName;</td><td>private String managerName;</td></tr><tr><td align="left">private Boolean deleteFlag;</td><td>private String deleteFlag;</td></tr><tr><td align="left">private Integer status;</td><td>private Integer status;</td></tr><tr><td align="left">private Boolean beProtect;</td><td>private String beProtect;</td></tr></tbody></table><p>MapMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;, unmappedTargetPolicy = ReportingPolicy.IGNORE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoursesMapMapper</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">booleanToString</span><span class="params">(Boolean value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Boolean <span class="title function_">stringToboolean</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;是&quot;</span>.equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;否&quot;</span>.equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LocalDateTime 转换为 String</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">localDateTimeToString</span><span class="params">(LocalDateTime dateTime)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">        <span class="keyword">return</span> DateFormatUtils.format(date, <span class="string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;beProtect&quot;, expression = &quot;java(courses.getBeProtect() ? \&quot;是\&quot; : \&quot;否\&quot;)&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;type&quot;, expression = &quot;java(courses.getType() == 1 ? \&quot;面授\&quot; : (courses.getType() == 2 ? \&quot;在线\&quot; : \&quot;混合\&quot;))&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    CoursesVO <span class="title function_">toVO</span><span class="params">(Courses courses)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;CoursesVO&gt; <span class="title function_">toVO</span><span class="params">(List&lt;Courses&gt; courses)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将toVO方法的转换规则反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration(name = &quot;toVO&quot;)</span></span><br><span class="line">    Courses <span class="title function_">toEntity</span><span class="params">(CoursesVO coursesVO)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Courses&gt; <span class="title function_">toEntity</span><span class="params">(List&lt;CoursesVO&gt; coursesVO)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MapStruct可以自动检测到我们接口的默认方法并进行使用，可以省去我们重复的mapping注解。但是容易出bug，这就是为什么只有LocalDateTime 转换为String，不过MapStruct自动实现了String转LocalDateTime。</p></blockquote><p><strong>注意</strong>：source、defaultValue 不能 和 expression 一起出现</p><h1 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unknown property &quot;xxx&quot; in result type xxx. Did you mean &quot;null&quot;?</span><br></pre></td></tr></table></figure><p>原因：项目中同时使用了Lombok，两者生成代码顺序出现冲突</p><p>解决方案：</p><ol><li>代码生成器annotationProcessor标签部分，将lombok放在mapstruct之前。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--自动生成代码annotationProcessor--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>官网解释：<a href="https://mapstruct.org/faq/">常见问题 （FAQ） – MapStruct</a></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-mapstruct-binding<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用的封装名称"><a href="#常用的封装名称" class="headerlink" title="常用的封装名称"></a>常用的封装名称</h2><table><thead><tr><th>含义</th><th>命名规范示例</th></tr></thead><tbody><tr><td>存储请求体信息</td><td>XxRequest</td></tr><tr><td>展示层对象命名（存储返回给前端的信息）</td><td>XxVo</td></tr><tr><td>数据传输对象（用于存储从数据库中查询的数据）</td><td>XxDto</td></tr><tr><td>es实体类命名</td><td>XxindexDO</td></tr><tr><td>db实体命名</td><td>与表名相同</td></tr><tr><td>service接口命名</td><td>Xxservice</td></tr><tr><td>service实现命名</td><td>XxserviceImpl</td></tr><tr><td>manager，service引入多个manager进行复杂的组合业务处理</td><td>Xxmanager</td></tr><tr><td>dao层命名</td><td>XxManager</td></tr><tr><td>封装持久化组合服务（一个实体需要从db，es，redis多种存储获取）</td><td>XxRepository</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 个人积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MapStruct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/2023/08/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2023/08/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="LVS、Nginx和HAProxy区别"><a href="#LVS、Nginx和HAProxy区别" class="headerlink" title="LVS、Nginx和HAProxy区别"></a>LVS、Nginx和HAProxy区别</h1><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p><strong>优点：</strong></p><ul><li><strong>高并发连接</strong>：LVS基于内核网络层面工作，有超强的承载能力和并发处理能力。单台LVS负载均衡器，可支持上万并发连接。</li><li><strong>抗负载能力强：</strong>是工作在网络4层之上仅作分发之用，这个特点也决定了它在负载均衡软件里的性能最强，稳定性最好，对内存和cpu资源消耗极低。</li><li><strong>无流量</strong>：LVS只分发请求，而流量并不从它本身出去，保证了均衡器IO的性能不会受到大流量的影响；</li><li><strong>成本低廉：</strong>硬件负载均衡器少则十几万，多则几十万上百万，LVS只需一台服务器和就能免费部署使用，性价比极高。</li><li><strong>配置简单：</strong>LVS配置非常简单，仅需几行命令即可完成配置，也可写成脚本进行管理。这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率；</li><li><strong>支持多种算法：</strong>支持多种论调算法，可根据业务场景灵活调配进行使用</li><li><strong>支持多种工作模型：</strong>可根据业务场景，使用不同的工作模式来解决生产环境请求处理问题。</li><li><strong>应用范围广</strong>：因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、DNS、ftp服务等等</li><li><strong>工作稳定</strong>：因为其本身抗负载能力很强，自身有完整的双机热备方案， 如LVS+Keepalived(常用)，LVS+Heartbeat。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>工作在4层，不支持7层规则修改</strong>：软件本身不支持正则处理，不能做动静分离，这就凸显了Nginx&#x2F;HAProxy+Keepalived的优势。</li><li><strong>机制过于庞大，不适合小规模应用</strong>：如果网站应用比较庞大，LVS&#x2F;DR+Keepalived就比较复杂了，特别是后面有Windows Server应用的机器，实施及配置还有维护过程就比较麻烦，相对而言，Nginx&#x2F;HAProxy+Keepalived就简单多了。</li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>优点：</p><ol><li>工作在OSI第7层，可以针对http应用做一些分流的策略。比如针对域名、目录结构。它的正则比HAProxy更为强大和灵活；</li><li>Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势所在；</li><li>Nginx安装和配置比较简单，测试起来比较方便；</li><li>可以承担高的负载压力且稳定，一般能支撑超过几万次的并发量；</li><li>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点；</li><li>Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器。LNMP现在也是非常流行的web环境，大有和LAMP环境分庭抗礼之势，Nginx在处理静态页面、特别是抗高并发方面相对apache有优势；</li><li>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以作反向代理加速器；</li></ol><p>缺点：</p><ol><li>Nginx不支持url来检测。</li><li>Nginx仅能支持http和Email，这个它的弱势。</li><li>Nginx的Session的保持，Cookie的引导能力相对欠缺。</li></ol><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>优点：</p><ol><li>HAProxy支持虚拟主机，可以工作在4、7层(支持多网段)；</li><li>能够补充Nginx的一些缺点比如Session的保持，Cookie的引导等工作；</li><li>支持url检测后端的服务器；</li><li>它跟LVS一样，本身仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的；</li><li>HAProxy可以对Mysql读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，不过在后端的MySQL slaves数量超过10台时性能不如LVS；</li><li>HAProxy的算法较多，达到8种；</li></ol><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><p>LVS： 基于四层的转发，只能做流量调度<br>HAproxy： 基于四层和七层的转发，是专业的代理服务器<br>Nginx： WEB服务器，缓存服务器，又是反向代理服务器，可以做基于四层和七层的转发</p><p>区别：</p><p>LVS只能做端口转发，而基于URL的、基于目录的这种转发LVS就做不了</p><p>HAproxy和Nginx由于可以做七层的转发，所以URL和目录的转发都可以做</p><p>工作选择：</p><ul><li>并发量很大时选择LVS</li><li>中小型公司并发量没那么大，选择HAproxy或者Nginx足已</li><li>中小型企业推荐使用HAproxy，HAproxy是专业的代理服务器，配置简单</li><li>公网ip不足，通过四层负载进行端口调度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2023/08/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/2.RabbitMQ/"/>
      <url>/2023/08/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/2.RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MQ"><a href="#1-MQ" class="headerlink" title="1. MQ"></a>1. MQ</h1><p>MQ本质是个队列，是一种跨进程的通信机制，是一种上下游“逻辑解耦+物理解耦”的消息通信服务。消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><p>使用MQ三大好处：</p><ol><li><strong>流量消峰</strong></li></ol><p>服务器的处理能力有限，若在某个时刻QPS（每秒查询率）激增，可能会导致系统无法承受而崩溃，此时可以将请求堆积在MQ中，保护下游系统。</p><blockquote><p>QPS指的是“每秒查询率”；而TPS指的是“事务数&#x2F;秒”。</p><p>对于一个页面的一次访问，形成一个Tps；而一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p></blockquote><ol start="2"><li><strong>应用解耦</strong></li></ol><p>当每次要给系统添加功能时都需要重新修改原来系统的代码，大大增加系统的维护成本。使用MQ后新加服务只需要消费数据即可，不需要修改原系统。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212900.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212900.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="3e432d98630ac6e980afbcc3ae7c01e2.png"></p><ol start="3"><li><strong>异步处理</strong></li></ol><p>以支付系统为例，用户发起支付请求，如果后台业务复杂，可能会花费较长时间，此时用户体验会很不好。支付系统在接收请求后将支付结果发送给MQ并直接响应用户，无论后端业务逻辑有多复杂，用户都无法察觉。比如我们日常在完成支付后都会立刻返回支付成功，但过一会才会收到扣费的通知。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>ActiveMQ</li></ol><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，较低的概率丢失数据</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><ol start="2"><li>Kafka</li></ol><p>为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量闻名。</p><p>优点：性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点就是吞吐量高。时效性 ms 级，可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p><p>缺点：Kafka 单机超过 64 个队列&#x2F;分区，cpu负载（load）会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢；</p><ol start="3"><li>RocketMQ</li></ol><p>自阿里巴巴的开源产品，用 Java 语言实现</p><p>优点：单机吞吐量十万级,可用性非常高，分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</p><p>缺点：支持的客户端语言不多，目前是 java 及 c++</p><ol start="4"><li>RabbitMQ</li></ol><p>在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言</p><h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2. RabbitMQ"></a>2. RabbitMQ</h1><p>RabbitMQ 是一个消息中间件：它接受、存储和转发消息数据。</p><p><strong>四大核心</strong>：</p><ul><li>生产者：产生数据发送消息的程序是生产者</li><li>交换机：一方面接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，由交换机类型决定。</li><li>队列：RabbitMQ 内部使用的一种数据结构，队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</li><li>消费者：消费者大多时候是一个等待接收消息的程序。</li></ul><h3 id="核心组成部分"><a href="#核心组成部分" class="headerlink" title="核心组成部分"></a>核心组成部分</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212907.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212907.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="55844230ca7aa398eb6bc3bc67ed685a.png"></p><p><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server</p><p><strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP&#x2F;IP&#x2F; <a href="https://so.csdn.net/so/search?q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&spm=1001.2101.3001.7020">三次握手</a>和四次挥手</p><p><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。</p><p><strong>Message</strong> ：服务与应用程序之间传送的数据，由<a href="https://so.csdn.net/so/search?q=Properties&spm=1001.2101.3001.7020">Properties</a>和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</p><p><strong>Virtual Host</strong>：虚拟地址，用于进行逻辑隔离，不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，是最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange</p><p><strong>Exchange</strong>：交换机，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout  (multicast)</p><p><strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.</p><p><strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</p><p><strong>Queue</strong>：保存消息并将它们转发给消费者。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>RabbitMQ安装需要安装对应的erlang环境，可以在<a href="https://packagecloud.io/rabbitmq">rabbitmq - Repositories · packagecloud</a>查找。</p><p>RabbitMQ的官网难找到对应操作系统的版本，可以在上述网站中查，根据介绍安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测是否安装成功</span></span><br><span class="line">rpm -qa|grep rabbitmq</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机启动</span></span><br><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p>RabbiltMQ开启web管理插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>访问地址<code>http://ip:15672/</code></p><p>创建账户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user 用户名 密码</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rabbitmqctl delete_user 用户名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置超级管理员角色</span></span><br><span class="line">rabbitmqctl set_user_tags 用户名 administrator</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有用户和角色</span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户权限</span></span><br><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><p>web应用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭应用</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清除</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h1 id="3-工作模式"><a href="#3-工作模式" class="headerlink" title="3. 工作模式"></a>3. 工作模式</h1><p>RabbitMQ官方介绍有七种工作模式，详情见<a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials</a></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>由一个生产者和一个消费者组成，也称为<strong>简单模式</strong>。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME=<span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.64.105&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化 默认消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.最后一个消费者端开连接以后该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment">         * 3.其他的参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,NAME,<span class="literal">null</span>,<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.64.105&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//如何进行消费的接口回调</span></span><br><span class="line">        <span class="comment">//同一个会话 tag 是固定的 可以做会话的名字</span></span><br><span class="line">        <span class="comment">//包含消息的字节形式的类</span></span><br><span class="line">        DeliverCallback dc=(tag,delivery)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cc=(tag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 消费者消费消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.true代表自动应答，false 手动应答；自动应答会让rabbitMQ删除消费了的消息</span></span><br><span class="line"><span class="comment">         * 3.消费者成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者消费失败的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;HELLO&quot;</span>,<span class="literal">true</span>,dc,cc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>简单模式的强化版，也称为<strong>工作队列</strong>。一个队列可以有多个消费者来竞争消费消息，但是我们仍需保证队列的<strong>幂等性</strong>（任意次执行对资源本身所产生的影响与一次执行的影响相同），队列存在就不能再创建同名队列。</p><h3 id="轮训分发消息"><a href="#轮训分发消息" class="headerlink" title="轮训分发消息"></a>轮训分发消息</h3><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, NAME, <span class="literal">null</span>, s.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//false指定关闭自动应答</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;HELLO&quot;</span>, <span class="literal">false</span>,</span><br><span class="line">                     (tag, delivery) -&gt; &#123;</span><br><span class="line">                         System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody()));</span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                             Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                             e.printStackTrace();</span><br><span class="line">                         &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;w1执行完成，删除消息！&quot;</span>);</span><br><span class="line">                         <span class="comment">//手动应答</span></span><br><span class="line">                         channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">                     &#125;,</span><br><span class="line">                     (tag) -&gt; &#123;</span><br><span class="line">                         System.out.println(<span class="string">&quot;消费中断&quot;</span>);</span><br><span class="line">                     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用两个工作线程，进入<code>Run/Debug Configurations</code>界面，点击<code>Modify options</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/fac93ac8f2dcc66ab0f56f92dd9bf30b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/fac93ac8f2dcc66ab0f56f92dd9bf30b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fac93ac8f2dcc66ab0f56f92dd9bf30b.png"></p><p>当我们开启多个工作线程时，队列会默认采取轮训的方式发送消息。简单模式时和工作队列模式的区别只是增加了消费者，队列会自动处理。</p><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>为了保证消息在发送过程的安全性，rabbitmq引入了消息应答机制：消费者在接收到消息并且处理该消息之后，会通知rabbitmq，随后 rabbitmq 把该消息删除。</p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡。</p><p>一方面消费者连接失败或channel关闭会导致消息丢失；另一方面没有对传递的消息数量进行限制，消费者可能因为消息的积压最终宕机，所以这种模式<strong>仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><ul><li>肯定应答</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//false 表示只确认DelivertTag号消息，true 表示确认小于等于DelivertTag的所有消息（批量确认）</span></span><br><span class="line">Channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><ul><li>否定应答</li></ul><p>否定确认时，需要指定是丢弃掉这条消息，还是让这条消息重新排队，过一会再来，又或者是让这条消息重新排队，并尽快让另一个消费者接收并处理它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//丢弃</span></span><br><span class="line">channel.BasicNack(deliveryTag: e.DeliveryTag, multiple: <span class="literal">false</span>, requeue: <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//重新排队</span></span><br><span class="line"> channel.BasicNack(deliveryTag: e.DeliveryTag, multiple: <span class="literal">false</span>, requeue: <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>multiple 的 true 代表批量应答 channel 上未应答的消息，false 代表仅确认当前消息。</p></blockquote><p> 设置手动应答后，当某一个消费者处理消息时宕机，rabbitmq会将消息重新排队，确保消息不会丢失。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>为了让rabbitmq崩溃时能保证队列和消息的安全性，我们需要将队列和消息都标记为持久化。</p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：不能同时存在同名的队列，需要将原先的队列删除。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212933.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212933.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="b66612f3f26f95c0bb503a9f1faa89b6.png"></p><p>其中D就表示持久化，此时即使重启rabbitmq队列也依然存在。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, s.getBytes());</span><br></pre></td></tr></table></figure><p>消息标记为持久化并不能完全保证不会丢失消息，消息的缓存和持久化还有一段时间，还需要发布确认章节的知识才能组成更强有力的持久化策略。</p><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>最开始我们学习的轮训模式不是很合理，由于物理机的性能差异，所以我们应该使用不公平分发，即“能者多劳”</p><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/84213c2bb2a9ebed05307950f713993e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/84213c2bb2a9ebed05307950f713993e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="84213c2bb2a9ebed05307950f713993e.png"></p><p>相当于每个消费者声明只能处理一个任务，完成当前任务后才会接取下一个任务，但如果所有的消费者都没有完成当前任务，可能会出现队列被撑满的情况。</p><h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><p>channel中存在一个未确认的消息缓冲区，我们可以限制此缓冲区的大小，以实现最大的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该值定义通道上允许的未确认消息的最大数量。</span></span><br><span class="line">channel.basicQos(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><blockquote><p>该值过大会增加消费者的RAM消耗（随机存取存储器）</p></blockquote><h2 id="发布确认模式"><a href="#发布确认模式" class="headerlink" title="发布确认模式"></a>发布确认模式</h2><p>官方名称为<code>Publisher Confirms</code></p><p>队列持久化+消息持久化+发布确认能极高地保证消息的安全性。</p><p>开启发布确认：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><ol><li>单个确认发布</li></ol><p>是一种同步确认发布的方式，也就是一个消息被确认发布，后续的消息才能继续发布。</p><blockquote><p>如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singlePublish</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="literal">null</span>, (i + <span class="string">&quot;&quot;</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：发布速度特别慢。</p><ol start="2"><li>批量确认发布</li></ol><p>这种方式可以极大地提高吞吐量，缺点是发布失败时，不知道哪个消息出现问题，当然这种方式也是同步的，一样会阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">batchPublish</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="literal">null</span>, (i + <span class="string">&quot;&quot;</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i % <span class="number">9</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">            System.out.println(i / <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>异步确认发布</li></ol><p>异步确认发布利用回调函数可靠地传递消息，不会阻塞消息发布，可靠性和效率都是最高的。</p><p>需要添加异步的监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1是确认收到消息的回调；var2是未被接收消息的回调</span></span><br><span class="line">ConfirmListener <span class="title function_">addConfirmListener</span><span class="params">(ConfirmCallback var1, ConfirmCallback var2)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存放所有消息</span></span><br><span class="line">ConcurrentSkipListMap&lt;Long,String&gt; map=<span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment"> * 1.消息序列号</span></span><br><span class="line"><span class="comment"> * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment"> * false 确认当前序列号消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.addConfirmListener((messageNumber,multiple)-&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">        <span class="comment">//返回小于等于当前序列号的未确认消息</span></span><br><span class="line">        ConcurrentNavigableMap&lt;Long, String&gt; temp = map.headMap(messageNumber, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//清除该部分未确认消息</span></span><br><span class="line">        temp.clear();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,(messageNumber,multiple)-&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。</p><p>生产者只能将消息发送到交换机(exchange)；之前我们传递消息使用的是默认交换机。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212946.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212946.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="79ad5e7b096b5bbc9c254a7d4cec817b.png"></p><p>从上图我们可以看到 Exchanges 的类型总共有四种：</p><ul><li>扇出(fanout)</li><li>直接(direct)</li><li>主题(topic)</li><li>标题(headers)：基本不用</li></ul><h3 id="无名交换机"><a href="#无名交换机" class="headerlink" title="无名交换机"></a>无名交换机</h3><p>前面我们没有指定交换机，依然能将消息发送到队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="literal">null</span>, s.getBytes());</span><br></pre></td></tr></table></figure><p>第一个参数是交换机的名称，空串表示默认交换机；第二个参数是交换机和队列的绑定关系：<code>routingKey(bindingkey)</code></p><blockquote><p>默认交换机隐式绑定到队列，路由密钥等于队列名称。无法显式绑定到默认交换或取消绑定。</p></blockquote><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p>可以创建一个具有随机名称的队列，一旦我们断开了消费者的连 接，队列将被自动删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><h4 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h4><p>binding 是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和哪个队 列进行了绑定关系。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212950.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212950.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="90a8ac0798dfb87e08c4741afda0e2b8.png"></p><h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><p>扇出交换机将接收到的所有消息广播到它绑定的所有队列中。也称为<strong>发布&#x2F;订阅(Publish&#x2F;Subscribe)模式</strong>。</p><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">    <span class="comment">//创建交换机；交换机名+类型</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">&quot;exchange1&quot;</span>, BuiltinExchangeType.FANOUT);</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;test1&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;test2&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//声明绑定关系；队列名+交换机名+binding key</span></span><br><span class="line">    channel.queueBind(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">    channel.queueBind(<span class="string">&quot;test2&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>, scanner.nextLine().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;成功发送！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test1,test2</code>两个不同的队列会接收到相同的消息。即使 binding key 不同也会收到相同的消息。</p><h2 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h2><p>消息只去到它绑定的 routingKey 队列中去。功能比Fanout强大，也称为<strong>路由(Routing)模式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange1&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line">...</span><br><span class="line">channel.queueBind(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log1&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;test2&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log2&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log1&quot;</span>, <span class="literal">null</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log2&quot;</span>, <span class="literal">null</span>, (<span class="string">&quot;消息&quot;</span> + i).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test1,test2</code>两个队列由于 binding key 的不同会收到不同的消息。实际运用中可以使用map存储binding key和消息。</p><h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><p>当多个队列使用同一个 binding key ，则功能类似于Fanout。一个队列绑定多个 binding key ：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212957.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806212957.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="865a05a6ebd6b221d7822a2b1c2562bc.png"></p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>Direct 尽管已经可以有选择性地发送消息，但仍然不够灵活。</p><p>topic 交换机的 routing_key 不能随意，必须是一个单词列表，以点号分隔开。</p><p>替换符：</p><ul><li><code>*</code>可以代替一个单词</li><li><code>#</code>可以替代零个或多个单词</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange1&quot;</span>, BuiltinExchangeType.TOPIC);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//声明绑定关系；队列名+交换机名+binding key</span></span><br><span class="line">channel.queueBind(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;#.test&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log.*&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;test2&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;*.rabbitmq.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;log.rabbitmq.test&quot;</span>, <span class="literal">null</span>, (<span class="string">&quot;都能收到&quot;</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;test.rabbitmq.log&quot;</span>, <span class="literal">null</span>, (<span class="string">&quot;test2的消息&quot;</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;test.log.rabbitmq&quot;</span>, <span class="literal">null</span>, (<span class="string">&quot;都收不到&quot;</span>).getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>无法被消费的消息被称为死信，处理死信的队列称为死信队列。</p><p>死信的来源：</p><ul><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213010.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="f4993f431c053901550cf792e633bca7.png"></p><h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">    channel.exchangeDeclare(<span class="string">&quot;normalE&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line">    channel.exchangeDeclare(<span class="string">&quot;deadE&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;deadQ&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.queueBind(<span class="string">&quot;deadQ&quot;</span>,<span class="string">&quot;deadE&quot;</span>,<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">    <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//正常队列设置死信交换机和routing-key；参数 key 是固定值</span></span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;deadE&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;normalQ&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, map);</span><br><span class="line">    channel.queueBind(<span class="string">&quot;normalQ&quot;</span>, <span class="string">&quot;normalE&quot;</span>, <span class="string">&quot;normal&quot;</span>);</span><br><span class="line">    <span class="comment">//设置消息的TTL为10s</span></span><br><span class="line">    AMQP.BasicProperties properties=<span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;normalE&quot;</span>,<span class="string">&quot;normal&quot;</span>,properties,<span class="string">&quot;死信&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213022.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7cf16694f8565d8c9c74d9483d0e3126.png"></p><p>消息过期后会被送到”deadQ”，如果我们不配置死亡队列，消息过期后会丢失。</p><h3 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置正常队列的最大长度</span></span><br><span class="line">map.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213017.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="a527c14934229274008374d67db8fde0.png"></p><h3 id="消息被拒绝"><a href="#消息被拒绝" class="headerlink" title="消息被拒绝"></a>消息被拒绝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;normalQ&quot;</span>,<span class="literal">false</span>,(tag,message)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//false 代表拒绝重新入队</span></span><br><span class="line">        channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    &#125;,(tag)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-延迟队列"><a href="#4-延迟队列" class="headerlink" title="4. 延迟队列"></a>4. 延迟队列</h1><p>延时队列最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理。</p><p>使用场景：</p><ol><li>订单在十分钟之内未支付则自动取消</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定的时间点前十分钟通知各个与会人员参加会议等</li></ol><blockquote><p>可以使用死信队列的方式来实现延迟队列的效果</p></blockquote><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><p>使用 Spring Initailizr 生成项目，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--swagger</span></span><br><span class="line"><span class="comment">将项目中所有的接口展现在页面上，这样后端程序员就不需要专门为前端使用者编写专门的接口文档；</span></span><br><span class="line"><span class="comment">当接口更新之后，只需要修改代码中的 Swagger 描述就可以实时生成新的接口文档了，从而规避了接口文档老旧不能使用的问题；</span></span><br><span class="line"><span class="comment">通过 Swagger 页面，我们可以直接进行接口调用，降低了项目开发阶段的调试成本。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.64</span><span class="number">.105</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">john</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>添加Swagger配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//相当于让该类继承WebMvcConfigurationSupport类</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">            .apiInfo(webApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;LemonPuer&quot;</span>, <span class="string">&quot;https://baidu.com&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;123456789@qq.com&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot在2.6版本之后<strong>处理映射匹配的默认策略发生变化</strong>；导致出现与Swagger不兼容的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.6之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pathmatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MatchingStrategy</span> <span class="variable">matchingStrategy</span> <span class="operator">=</span> MatchingStrategy.ANT_PATH_MATCHER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.6之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pathmatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MatchingStrategy</span> <span class="variable">matchingStrategy</span> <span class="operator">=</span> MatchingStrategy.PATH_PATTERN_PARSER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案1：配置文件添加<code>@EnableWebMvc</code>注解</p><p>方案2：配置文件中添加<code>spring.mvc.pathmatch.matching-strategy=ant_path_matcher</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213034.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213034.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="18ed21895ae1eb9be5158f2bf5a63931.png"></p><p>配置文件类中创建好交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认持久化</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;X&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL</span></span><br><span class="line">        map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">&quot;QA&quot;</span>).withArguments(map).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(</span></span><br><span class="line"><span class="params">        //<span class="meta">@Bean</span>的方法名就是对象名</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>存在多个相同类型的对象，所以这里使用@Qualifier根据对象名引入</p></blockquote><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">//解决返回中文乱码的问题</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&#123;message&#125;&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTest1</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接收完毕!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 设置全部返回数据的编码还是需要配置<code>CharacterEncodingFilter</code></p></blockquote><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelateConsume</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就使用死信队列完成了延迟队列的功能，但仍有不足：队列的延迟时间固定，不够灵活。</p><h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/&#123;message&#125;/&#123;time&#125;&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getTest2</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;message&quot;)</span> String message,</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;time&quot;)</span> String time</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),time, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, msg -&gt; &#123;</span><br><span class="line">        <span class="comment">//设置消息的过期时间</span></span><br><span class="line">        msg.getMessageProperties().setExpiration(time);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;接收完毕!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似好像解决了问题，但消息可能不会“按时死亡”：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213041.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7f90a0769a8a5abde7bd74a5b277d490.png"></p><p>因为RabbitMQ 只会检查第一个消息是否过期，后面的消息过期也不会被优先执行。</p><h2 id="延时队列插件"><a href="#延时队列插件" class="headerlink" title="延时队列插件"></a>延时队列插件</h2><p>进入RabbitMQ的<a href="https://www.rabbitmq.com/community-plugins.html">社区插件</a></p><p>下载<code>rabbitmq_delayed_message_exchange</code>插件，然后放置到 RabbitMQ 的插件目录<code>/usr/lib/rabbitmq/lib/rabbitmq_server-3.10.0/plugins</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启插件</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><blockquote><p>注意需要下载对应版本的插件</p></blockquote><p>重启RabbitMQ生效：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213044.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6c2f6e4464afd0557d61ddfbc8ad1dc0.png"></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213048.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213048.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1b2d2d8780e2901294e7da3026eed782.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">zExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">&quot;QE&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueEBindingX</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Qualifier(&quot;queueE&quot;)</span> Queue queueE,</span></span><br><span class="line"><span class="params">    <span class="meta">@Qualifier(&quot;zExchange&quot;)</span> CustomExchange zExchange</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">//noargs表示没有参数了；自定义交换机必须调用此方法，普通交换机绑定也可以在最后调用</span></span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueE).to(zExchange).with(<span class="string">&quot;ZE&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/&#123;message&#125;/&#123;time&#125;&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getTest3</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;message&quot;)</span> String message,</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;time&quot;)</span> Integer time</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条延迟&#123;&#125;毫秒的信息给延迟队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), time, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot;ZE&quot;</span>, message, msg -&gt; &#123;</span><br><span class="line">        <span class="comment">//设置消息的过期时间</span></span><br><span class="line">        msg.getMessageProperties().setDelay(time);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;接收完毕!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里使用的是<code>setDelay()</code></p></blockquote><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;QE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveE</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延迟队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213547.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213547.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d05f3567e253e4b58b3e16f5c5b75285.png"></p><p>当然，延时队列还有很多其它选择，比如利用<code>Java</code>的<code>DelayQueue</code>，利用<code>Redis</code>的<code>zset</code>，利用<code>Quartz</code>或者利用<code>kafka</code>的时间轮，这些方式各有特点,看需要适用的场景。</p><h1 id="5-高级发布确认"><a href="#5-高级发布确认" class="headerlink" title="5. 高级发布确认"></a>5. 高级发布确认</h1><p>当RabbitMQ故障重启期间，生产者投递的消息都会丢失，需要手动处理和恢复。</p><p>单机环境下，可以让交换机在收到消息后再删除缓存中的消息。</p><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li>NONE（默认）：禁用发布确认模式‘</li><li>CORRELATED：发布消息成功到交换器后触发回调方法</li><li>SIMPLE：会触发回调方法；并且发布消息成功后使用<code>rabbitTemplate</code>调用<code>waitForConfirms</code>或<code>waitForConfirmsOrDie</code>方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是<code>waitForConfirmsOrDie</code>方法如果返回false则会关闭channel，则接下来无法发送消息到broker</li></ul><h3 id="接收回调"><a href="#接收回调" class="headerlink" title="接收回调"></a>接收回调</h3><p>回调接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallback</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     * CorrelationData:消息相关数据</span></span><br><span class="line"><span class="comment">     * ack:交换机是否收到消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishProducer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> MyCallback myCallback;</span><br><span class="line">    <span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line">    <span class="comment">//@PostConstruct注解被用于需要在依赖注入完成后执行的方法上。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(myCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTest4</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        CorrelationData data1=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">        data1.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;Z&quot;</span>,<span class="string">&quot;ZE&quot;</span>,<span class="string">&quot;ZE+&quot;</span>+message,data1);</span><br><span class="line">        log.info(<span class="string">&quot;ZE发送消息内容:&#123;&#125;&quot;</span>,message);</span><br><span class="line">        <span class="comment">//交换机能接收但队列不存在，消息丢失</span></span><br><span class="line">        CorrelationData data2=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">        data2.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;Z&quot;</span>,<span class="string">&quot;AE&quot;</span>,<span class="string">&quot;AE+&quot;</span>+message,data2);</span><br><span class="line">        log.info(<span class="string">&quot;AE发送消息内容:&#123;&#125;&quot;</span>,message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如猜想一样，此方式只能确保交换机能接收到消息，并不能保证消息的安全性</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>通过设置 mandatory 参数可以在消息传递过程中不可达目的地时将消息返回给生产者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallback</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">         * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">         * 配置文件中配置了&quot;spring.rabbitmq.template.mandatory=true&quot;就不用此语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     * CorrelationData:消息相关数据</span></span><br><span class="line"><span class="comment">     * ack:交换机是否收到消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">String</span>(returnedMessage.getMessage().getBody()),</span><br><span class="line">                 returnedMessage.getReplyText(),</span><br><span class="line">                 returnedMessage.getExchange(),</span><br><span class="line">                 returnedMessage.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mandatory</code>、<code>publisher-confirms</code>、<code>publisher-return</code>属性：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置此属性配置可以确保消息成功发送到交换器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#指定消息在没有被队列接收时是强行退回还是直接丢弃</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#可以确保消息在未被队列接收时返回;常与mandatory属性配合使用</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><code>mandatory</code>、<code>publisher-return</code>差异：</p><ul><li>mandatory属性的优先级更高</li><li>mandatory属性可能会返回三种值null、false、true</li><li>mandatory结果为null（即不配置）时结果由publisher-returns确定</li></ul><h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><p>程序架构：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213612.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213612.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="c368f720c381cb597d55048651a872ee.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;confirm.exChange&quot;</span>;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExChange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE).durable(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">////设置该交换机的备份交换机</span></span><br><span class="line">        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里展示交换机需要添加的参数，其它部分正常编写即可</p></blockquote><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = MyConfiguration.WARNING_QUEUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarning</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mandatory</code>参数与备份交换机可以一起使用，但备份交换机的优先级更高。</p><h1 id="6-其它知识点"><a href="#6-其它知识点" class="headerlink" title="6. 其它知识点"></a>6. 其它知识点</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>用户对于同一操作发起的一次请求或多次请求的结果是一致的，不会因为多次点击而产生副作用。</p><p>消息重复消费：</p><p>消费者在给 MQ 返回 ack 时网络中断，该条消息被重新发给其他的消费者，或者在网络重连后再次发送给该消费者，造成消费者消费了重复的消息。</p><p>业界主流的幂等性有两种操作：</p><ul><li>唯一ID+指纹码机制，利用数据库主键去重</li></ul><p>指纹码就是根据某些规则得到的唯一信息码。利用查询语句判断该id是否存在数据库。</p><p>优势：实现简单。劣势：高并发场景下窜在写入性能瓶颈，可以采用分库分表提升性能。</p><ul><li>利用 redis 的原子性实现</li></ul><p>利用<code>setnx</code>指令从而避免重复消费。</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>在订单催付场景中，我们需要根据客户级别调整订单处理顺序。</p><p>队列创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//默认为0-255，手动设置范围0-10</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加消息优先级</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line"><span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure><blockquote><p>消息的默认优先级为最低</p></blockquote><p>唯有消息在队列中堆积，才会有优先级的判断。</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>3.6.0 版本开始引入了惰性队列的概念。一般情况下，队列中的消息存在于内存中，惰性队列会将消息存入磁盘，在消费之消费到消息时才会被加载到内存中 。</p><p>其设计目标是能够支持更长的队列，即支持更多的消息存储。</p><p>惰性队列可以在声明队列的时候使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure><p>也可以通过 Policy 的方式设置， Policy 的方式具备更高的优先级。</p><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>Policies是RabbitMQ的Server端机制</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213621.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213621.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="07d2fa5b88da54a32ad1ba164a125bd2.png"></p><p>打开<code>Add / update an operator policy</code></p><ul><li>Name：Policy的名称</li><li>Pattern：此Policy根据正则表达式去匹配Queues&#x2F;Exchanges名称</li><li>Apply to：此Policy对Queue还是对Exchange生效，或者两者都适用</li><li>Priority：优先级</li><li>Definition：添加的args，KV键值对。</li></ul><p>Operator Policy 和 User Policy 的区别：</p><ul><li>Operator Policy 是给服务提供商或公司基础设施部门用来设置某些需要强制执行的通用规则</li><li>User Policy 是给业务应用用来设置的规则</li></ul><p>Operator Policy 和 User Policy 会合并后作用于队列，并且为防止 Operator Policy 对队列某些关键属性例如死信队列交换器<code>Dead Letter Exchange</code>的覆盖导致业务应用产生非预期的结果，Operator Policy 只支持 <code>expire</code>、<code>message-ttl</code>、<code>max-length</code>、<code>max-length-bytes</code> 4个参数。</p><h1 id="7-RabbitMQ集群"><a href="#7-RabbitMQ集群" class="headerlink" title="7. RabbitMQ集群"></a>7. RabbitMQ集群</h1><h2 id="主从副本集群："><a href="#主从副本集群：" class="headerlink" title="主从副本集群："></a>主从副本集群：</h2><ol><li>修改 3 台机器的主机名称</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><ol start="2"><li>配置各个节点的 hosts 文件，让各个节点都能互相识别</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><ol start="3"><li>确保各个节点的 cookie 文件使用的是同一个值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@从机器名:/var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure><ol start="4"><li>启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务（全部机器都要执行）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><ol start="5"><li>从机器执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rabbitmqctl stop 会将 Erlang 虚拟机关闭</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rabbitmqctl stop_app 只关闭 RabbitMQ 服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@集群中的机器名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只启动应用服务</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><ol start="6"><li>查看集群状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><ol start="7"><li>重新设置用户（集群中任意一台机器）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建账号</span></span><br><span class="line">rabbitmqctl add_user admin 123</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户权限</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ol start="8"><li>解除集群节点</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@从机器名(上级机器上执行)</span><br></pre></td></tr></table></figure><p>默认情况下RabbitMQ代理操作所需的所有数据&#x2F;状态都将跨所有节点复制。</p><p>但消息队列是例外，默认情况下，消息队列仅位于一个节点上，尽管它们可以从所有节点看到和访问</p><p>当队列所在的机器宕机，队列就会失去作用。</p><h2 id="镜像集群："><a href="#镜像集群：" class="headerlink" title="镜像集群："></a>镜像集群：</h2><p>镜像集群是基于主从副本集群的，解决了队列的单点故障问题。</p><p>搭建步骤：</p><p>随便再一个节点中添加policy</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213632.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213632.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="de19e346317f0f52549b5d5d23cefd58.png"></p><p>改策略会将<code>mirrior</code>开头的交换机和队列备份一份，即整个集群有两份。</p><blockquote><p>该策略会保证集群中一直有两份数据，当其中一份数据所在的节点宕机，会自动在其他节点中再备份一份。</p></blockquote><h2 id="实现高可用负载均衡"><a href="#实现高可用负载均衡" class="headerlink" title="实现高可用负载均衡"></a>实现高可用负载均衡</h2><p>使用<code>Haproxy+Keepalive</code>两项工具</p><h3 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy"></a>Haproxy</h3><p>HAProxy 提供高可用性、负载均衡及基于 TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。</p><p>目前关于网站架构一般比较合理流行的架构方案：Web前端采用Nginx&#x2F;HAProxy+Keepalived作负载均衡器；后端采用MySQL数据库一主多从和读写分离，采用LVS+Keepalived的架构。</p><p>整体架构大都相似：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213634.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806213634.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="af53d124b98e7d3acebb0bbc969fc5e8.png"></p><h4 id="搭建："><a href="#搭建：" class="headerlink" title="搭建："></a>搭建：</h4><ol><li>下载<code>haproxy</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install haproxy</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件的ip为当前机器ip</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure><ol start="3"><li>启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">ps -ef | grep haproxy</span><br></pre></td></tr></table></figure><ol start="4"><li>访问地址：<code>ip:8888/stats</code></li></ol><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。</p><h4 id="搭建：-1"><a href="#搭建：-1" class="headerlink" title="搭建："></a>搭建：</h4><ol><li>下载</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install keepalived</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure><blockquote><p>Nginx章节已做简单介绍，此处不再赘述</p></blockquote><ol start="3"><li>添加<code>haproxy_chk.sh</code></li></ol><p>该脚本用来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启 HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作。</p><ol start="4"><li>启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure><ol start="5"><li>观察<code>Keepalived</code>的日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/messages -n 200</span><br></pre></td></tr></table></figure><ol start="6"><li>观察最新添加的 vip</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip add show</span><br></pre></td></tr></table></figure><h2 id="Federation"><a href="#Federation" class="headerlink" title="Federation"></a>Federation</h2><p>Federation 插件的设计目标是使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群，该功能在很多场景下都非常有用。</p><p>Federation 插件能够在不同管理域（可能设置了不同的用户和 vhost，也可能运行在不同版本的 RabbitMQ 和 Erlang 上）中的 Broker 或者集群之间传递消息。</p><p>Federation 插件基于 AMQP 0-9-1 协议在不同的 Broker 之间进行通信，并设计成<strong>能够容忍不稳定的网络连接情况</strong>。</p><p>一个 Broker 节点中可以同时存在联邦交换器（或队列）或者本地交换器（或队列），只需要对特定的交换器（或队列）创建 Federation 连接（Federation link）。</p><p>一个联邦交换器（federated exchange）或者一个联邦队列（federated queue）接收上游（upstream）的消息，这里的上游是指位于其他 Broker 上的交换器或者队列。联邦交换器能够将原本发送给上游交换器（upstream exchange）的消息路由到本地的某个队列中；联邦队列则允许一个本地消费者接收到来自上游队列（upstream queue）的消息。</p><h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><p>与 Federation 具备的数据转发功能类似，Shovel 能够可靠、持续地从一个 Broker 中的队列拉取数据并转发至另一个 Broker 中的交换器。<strong>作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker 上，也可以位于不同的 Broker 上。</strong></p><p>主要优势：</p><ol><li>松耦合。Shovel 可以移动位于不同管理域中的 Broker（或者集群）上的消息，这些 Broker（或者集群）可以包含不同的用户和 vhost，也可以使用不同的 RabbitMQ 和 Erlang 版本。</li><li>支持广域网。Shovel 插件同样基于 AMQP 协议在 Broker 之间进行通信，被设计成<strong>可以容忍时断时续的连通情形</strong>，并且能够保证消息的可靠性。</li><li>高度定制。当 Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2023/08/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/1.Nginx/"/>
      <url>/2023/08/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/1.Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1. Nginx简介"></a>1. Nginx简介</h1><p>流行的Nginx的版本有：</p><ul><li><a href="http://nginx.org/">nginx</a>：Nginx的官方开源版本</li><li><a href="http://nginx.org/">nginx plus</a>：Nginx发型的付费版本，在整合第三方模块、运营监控以及技术支持上有很大的优势</li><li><a href="http://openresty.org/cn/">Tengine</a>：阿里基于nginx的开发版本</li><li><a href="http://tengine.taobao.org/">OpenResty</a>：如需开发API服务器或防火墙可选</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>配置好虚拟机的静态ip后解压tar包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.25.1.tar.gz</span><br></pre></td></tr></table></figure><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p>进入解压的文件夹后编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>关闭防火墙后启动服务我们就可以直接通过浏览器访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//进入安装好的目录</span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx 启动</span><br><span class="line">./nginx -s stop 快速停止</span><br><span class="line">./nginx -s quit 优雅关闭，在退出前完成已经接受的连接请求</span><br><span class="line">./nginx -s reload 重新加载配置</span><br></pre></td></tr></table></figure><p>安装为系统服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">nginx - web server</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network.target remote-fs.target nss-lookup.target</span></span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">forking</span></span><br><span class="line"><span class="attr">PIDFile</span>=<span class="string">/usr/local/nginx/logs/nginx.pid</span></span><br><span class="line"><span class="attr">ExecStartPre</span>=<span class="string">/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="attr">ExecReload</span>=<span class="string">/usr/local/nginx/sbin/nginx -s reload</span></span><br><span class="line"><span class="attr">ExecStop</span>=<span class="string">/usr/local/nginx/sbin/nginx -s stop</span></span><br><span class="line"><span class="attr">ExecQuit</span>=<span class="string">/usr/local/nginx/sbin/nginx -s quit</span></span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure><p>重新加载服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">//启动服务</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">//开机启动</span><br><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>nginx的主目录：<code>/usr/local/nginx</code></p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/2670d7c0d2b303a7aec36a8b84bd03b5.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/2670d7c0d2b303a7aec36a8b84bd03b5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2670d7c0d2b303a7aec36a8b84bd03b5.png"></p><blockquote><p>其中以_temp结尾的都是第一次运行时生成的用于存放临时文件的</p></blockquote><ul><li>conf：用来存放配置文件相关</li><li>html：用来存放静态文件的默认目录 html、css等</li><li>logs：用于存放日志文件</li><li>sbin：nginx的主程序</li></ul><h1 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h1><p>运行流程：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211257.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211257.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="e84c8c3f7d6123fdceecb413fd8bb251.png"></p><blockquote><p>当我们reload进程时，Nginx会通知worker不再接收请求，并在处理完当前请求后销毁，同时创建新的worker接收请求。</p></blockquote><h2 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h2><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211306.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211306.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="8c04fecc3be01e469c5be70484aa89c8.png"></p><ul><li>worker_processes：默认为1，表示开启一个业务进程</li><li>worker_connections 1024; 单个业务进程可接受连接数</li><li>include mime.types; 引入http mime类型</li><li>default_type application&#x2F;octet-stream; 如果mime类型没匹配上，默认使用二进制流的方式传输。</li><li>sendfile on; 使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。</li><li>keepalive_timeout 65;</li></ul><p>未开启sendfile：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211311.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211311.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="d67c433a859b7827c85e018637eda585.png"></p><p>开启：</p><p><img src="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211315.png" class="lazyload placeholder" data-srcset="https://fastly.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="17ec96d16653df5102e2b060ba3de1e8.png"></p><h3 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h3><p>传统的DNS（也称LocalDNS）原理：</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211424.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211424.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="19d3e6de96de5b2cbfd91c826b1206ff.png"></p><p>HTTPDNS是使用HTTP协议向DNS服务器的进行请求，代替传统的DNS协议使用UDP协议向DNS服务器的进行请求,绕开了运营商的Local DNS，简化了请求的复杂性，避免了使用运营商Local DNS造成的劫持和跨网问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/de83010910f6e78b69c6bae4cc2e9c25.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/de83010910f6e78b69c6bae4cc2e9c25.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="de83010910f6e78b69c6bae4cc2e9c25.png"></p><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务，一个server就是一个虚拟主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; #监听端口号</span><br><span class="line">    server_name localhost; #主机名</span><br><span class="line">    location / &#123; #匹配路径</span><br><span class="line">        root html; #文件根目录</span><br><span class="line">        index index.html index.htm; #默认页名称</span><br><span class="line"> &#125;</span><br><span class="line">    error_page 500 502 503 504 /50x.html; #报错编码对应页面</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以配置多个server（<strong>端口号和主机名不能都相同</strong>），但需要注意的servername匹配分先后顺序，Nginx会直接响应最先匹配的server。</p><p>可以在同一servername中匹配多个域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name vod.mmban.com www1.mmban.com;</span><br></pre></td></tr></table></figure><p>通配符匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_name *.mmban.com #实现多用户二级域名</span><br><span class="line">server_name vod.*;</span><br></pre></td></tr></table></figure><blockquote><p>短网址和多用户二级域名的实现有些类似，都是服务端在数据库中查询数据</p></blockquote><p>正则匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name ~^[0-9]+\.mmban\.com$;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><ul><li>正向代理：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211440.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211440.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="2daff0cdf18d732803022a68f00a43e4.png"></p><blockquote><p>这里的代理服务器其实就是网关。</p></blockquote><ul><li>反向代理：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211442.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="6ee10e9724ea764e614600da21df9fba.png"></p><blockquote><p>这种网络的传输速度有代理服务器的带宽限制，称为<strong>隧道式代理</strong></p><p>若在返回数据时直接返回给用户，称为DR模型，由LVS实现</p></blockquote><p>传统公司系统架构</p><p><img src="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211445.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/lemonpuer/figure@latest/blog-images/20230806211445.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="temp.png"></p><p>但在一些互联网项目，需要传输音频等大体积的静态资源时，Nginx就会成为网络瓶颈，此时就需要创建多个Nginx组，引入负载均衡器。</p><h3 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://www.atguigu.com/;</span><br><span class="line">#或</span><br><span class="line">#proxy_pass http://192.168.3.100:8080;</span><br><span class="line">#root html;</span><br><span class="line">#index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ip地址和域名是一对多的关系。</strong>一个ip地址可以有多个域名，一个域名只能有一个ip地址。</p><h3 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream temp &#123;</span><br><span class="line">server 192.168.64.102:80;</span><br><span class="line">server 192.168.64.103:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass temp;</span><br><span class="line"> &#125;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>配置好负载均衡后，默认使用的负载均衡策略是<strong>轮询</strong>，逐一转发，这种方式适用于无状态请求。</p><p><strong>weight（权重）</strong>：指定轮询几率，用于后端服务器性能不均的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream httpd &#123;</span><br><span class="line">#默认为80端口可以不指定</span><br><span class="line">    server 127.0.0.1:8050 weight=10 down;</span><br><span class="line">    server 127.0.0.1:8060 weight=1;</span><br><span class="line">    server 127.0.0.1:8060 weight=1 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>down：表示当前的server暂时不参与负载</li><li>weight：默认为1.weight越大，负载的权重就越大。</li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。</li></ul></blockquote><p><strong>ip_hash</strong>：根据客户端的ip地址转发同一台服务器，可以保持回话（定向用户转发）</p><p><strong>least_conn</strong>：优先向最少连接访问的服务器发起请求</p><p><strong>url_hash</strong>：需要第三方组件，根据用户访问的url定向转发请求（定向流量转发）</p><p><strong>fair</strong>：需要第三方组件，根据后端服务器响应时间转发请求</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>将静态的资源放到Nginx中，Tomcat专门处理动态请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /css &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location /images &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location /js &#123;</span><br><span class="line">    root /usr/local/nginx/static;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">    root /usr/local/nginx/html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/</code>通用匹配，任何请求都会匹配到；<code>=</code>精准匹配，不是以指定模式开头；<code>~</code>正则匹配，区分大小写；<code>~*</code>正则匹配，不区分大小写；<code>^~</code>非正则匹配，匹配以指定模式开头的location。</p><p>除了root，alias也可以指定路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /css &#123;</span><br><span class="line">    alias /usr/local/nginx/static/css;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>alias在接受请求的时候在路径上不会加上location；有bug不建议使用</p></blockquote><h3 id="UrlRewrite"><a href="#UrlRewrite" class="headerlink" title="UrlRewrite"></a>UrlRewrite</h3><p>rewrite语法格式及参数语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rewrite是实现URL重写的关键指令，根据regex (正则表达式)部分内容，重定向到replacement，结尾是flag标记。</span><br><span class="line"></span><br><span class="line">rewrite &lt;regex&gt; &lt;replacement&gt; [flag];</span><br><span class="line">关键字   正则     替代内容    flag标记</span><br><span class="line"></span><br><span class="line">rewrite参数的标签段位置：</span><br><span class="line">server,location,if</span><br><span class="line"></span><br><span class="line">flag标记说明：</span><br><span class="line">last #本条规则匹配完成后，继续向下匹配新的location URI规则</span><br><span class="line">break #本条规则匹配完成即终止，不再匹配后面的任何规则</span><br><span class="line">redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址</span><br><span class="line">permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</span><br></pre></td></tr></table></figure><blockquote><p>301和302仅面向爬虫和浏览器，用户体验无差</p></blockquote><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /css &#123;</span><br><span class="line">rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 break;</span><br><span class="line">proxy_pass http://192.168.44.100:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网关服务器"><a href="#网关服务器" class="headerlink" title="网关服务器"></a>网关服务器</h3><p>综合负载均衡器和反向代理服务器等功能。</p><p>首先开启应用服务器的防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启防火墙</span></span><br><span class="line">systemctl restart firewalld</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重载规则</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定端口和ip访问</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.44.101&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已配置规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移除规则</span></span><br><span class="line">firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.44.101&quot; port port=&quot;8080&quot; protocol=&quot;tcp&quot; accept&quot;</span><br></pre></td></tr></table></figure><p>网关配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream httpds &#123;</span><br><span class="line">    server 192.168.44.102 weight=8 down;</span><br><span class="line">    server 192.168.44.103:8080 weight=2;</span><br><span class="line">    server 192.168.44.104:8080 weight=1 backup;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">#UrlRewrite</span><br><span class="line">    rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 redirect;</span><br><span class="line">    #反向代理+负载均衡</span><br><span class="line">    proxy_pass http://httpds ;</span><br><span class="line">&#125;</span><br><span class="line">#动静分离</span><br><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">    root /usr/local/nginx/html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置防盗链"><a href="#配置防盗链" class="headerlink" title="配置防盗链"></a>配置防盗链</h3><p>为了防止其它网站随意引用我们页面的资源，可以使用Nginx进行url过滤。</p><p>使用规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valid_referers none | blocked | server_names | ....;</span><br></pre></td></tr></table></figure><ul><li>none， Referer 头域不存在时允许访问。</li><li>blocked，检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以 “http:&#x2F;&#x2F;” 或 “https:&#x2F;&#x2F;” 开头。</li><li>server_names ，可以允许多个ip或域名访问，优先使用域名（如果域名下有外链图片只能用域名）</li></ul><blockquote><p>Referer 是请求头的一部分，显示来源地址。</p><p>外链图片就是非项目本地服务器的资源，通过网络使用其他网站图片</p></blockquote><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">valid_referers 192.168.44.101;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">    root html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回错误页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">valid_referers 192.168.44.101;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 401;</span><br><span class="line">        #return /401.html; 这个不用额外配置，更简洁</span><br><span class="line">    &#125;</span><br><span class="line">    root html;</span><br><span class="line">&#125;</span><br><span class="line">error_page 401 /401.html</span><br><span class="line">location = /401.html&#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合rewrite返回报错图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~*/(css|img|js) &#123;</span><br><span class="line">valid_referers 192.168.44.101;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">    #图片在html/img目录下</span><br><span class="line">    rewrite ^/ /img/x.png break;</span><br><span class="line">    &#125;</span><br><span class="line">    root html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>一个非常实用的、用来与服务器之间传输数据的工具。</p><p>可以使用curl测试Nginx是否配置成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#-e表示带引用，即设置Rerferer，-I表示显示响应头信息</span><br><span class="line">curl -e &quot;http://baidu.com&quot; -I http://192.168.44.101/img/logo.png</span><br></pre></td></tr></table></figure><h3 id="配置高可用"><a href="#配置高可用" class="headerlink" title="配置高可用"></a>配置高可用</h3><p>手动安装Keepalived：</p><p>[下载地址](<a href="https://www.keepalived.org/download.html#">Keepalived for Linux</a>)；使用 .&#x2F;configure 编译安装</p><p>如报错需要安装依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure><p>yum安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y keepalived</span><br></pre></td></tr></table></figure><blockquote><p>使用yum安装后配置文件在<code>/etc/keepalived/keepalived.conf</code></p></blockquote><p>最小配置（两台Nginx）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">#组中的id</span><br><span class="line">    router_id lb111</span><br><span class="line">&#125;</span><br><span class="line">#名字随意</span><br><span class="line">vrrp_instance atguigu &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    #配置网卡信息，通过ip addr查看</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    #优先级</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    #虚拟ip（vip）用于接收请求</span><br><span class="line">        192.168.44.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id lb110</span><br><span class="line">&#125;</span><br><span class="line">#名字随意</span><br><span class="line">vrrp_instance atguigu &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 50</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.44.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Keepalived根据检测到多台机器上的Keepalived进程来判断机器是否宕机，不能查看Nginx是否出异常，我们可以写脚本将Nginx和Keepalived关联起来。</p><h3 id="Https证书"><a href="#Https证书" class="headerlink" title="Https证书"></a>Https证书</h3><p>服务器和CA机构以及https的关系：</p><ol><li>服务器首先向CA机构提交资料，被承认后服务器返回客户端的公钥会被CA机构使用私钥进行加密包装为证书</li><li>客户端收到证书后会用操作系统绑定的CA公钥进行解锁，取得服务器发送的公钥</li><li>然后客户端使用服务器的公钥加密对称加密的密钥，之后服务器拿私钥解密，最终服务器与客户端便使用对称加密进行数据传输。</li></ol><p>使用阿里云配置实践<a href="https://www.bilibili.com/video/BV1yS4y1N76R?p=43&vd_source=43882264793a4ce5e4b13671c1025aa3">可以参照</a></p><p>配置环境可以使用<a href="https://oneinstack.com/auto/">OneinStack</a></p><p>BBS系统就是网络论坛，网上有许多优秀的开源项目。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速成MarkDown</title>
      <link href="/2023/06/30/%E5%B7%A5%E5%85%B7/MarkDown/"/>
      <url>/2023/06/30/%E5%B7%A5%E5%85%B7/MarkDown/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h2><ul><li><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p></li><li><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p></li><li><p>Markdown 编写的文档后缀为 .md, .markdown。</p></li></ul><h3 id="Markdown应用"><a href="#Markdown应用" class="headerlink" title="Markdown应用"></a>Markdown应用</h3><ul><li><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p></li><li><p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p></li></ul><p>方式一：使用 &#x3D; 和 - 标记一级和二级标题<br>&#x3D;和-的个数任意</p><h2 id="标题格式"><a href="#标题格式" class="headerlink" title="标题格式"></a>标题格式</h2><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是一级标题</span><br><span class="line">===</span><br><span class="line">我是二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>方式二：使用 # 号标记<br>使用 # 号可表示 1-6 级标题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h2 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h2><p>在段落后面使用一个空行来表示重新开始一个段落。<br>示例1</p><p>示例2</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><hr><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下</p><p><del>例子</del></p><p>文字前面两个 ~~ 表示删除线起点，后面两个表示终点</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 &lt; u &gt; 标签来实现：</p><p><u>示例</u></p><p>&lt; u &gt;表示开始，&lt; &#x2F;u &gt;表示结束</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[^要注明的文本]</span><br><span class="line">[^文本1]:内容1</span><br></pre></td></tr></table></figure><p>创建脚注格式类似这样 <a href="%E5%86%85%E5%AE%B91">^文本1</a>。</p><p>角标会自动叠加<a href="%E5%86%85%E5%AE%B92">^文本2</a></p><p>注意：脚注的:必须是英文格式下的</p><p>如果后续文本不是标题，便会出现在脚注区域</p><p>开新段落后不受影响；标题后续的文字不受影响</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><p>第一项</p></li><li><p>第二项</p></li><li><p>第三项</p></li></ul><p>有序列表使用数字并加上 . 号来表示（）</p><ol><li>示例一</li><li>示例二</li></ol><p>.后面要加空格，否则：<br>1.示例一<br>2.示例二</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：</p><ol><li>第一项（列表前至少需要三个空格）：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li></ol><ul><li>第二项（列表前至少需要两个空格）：<ol><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ol></li></ul><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><blockquote><p>区块引用</p></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：<br><img src="/:/1a335596bdce47c68b37417339c5e950" class="lazyload placeholder" data-srcset="/:/1a335596bdce47c68b37417339c5e950" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fa017d90f5439af63bb3589e7f6cd43a.png"><br>效果：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><ul><li>第一项<blockquote><p>内容</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><p><code>printf()</code> 函数<br>反引号 &#96; 即英文模式下的 ~ 键</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//下面的/代表转义，使用时去掉</span><br><span class="line">\```java</span><br><span class="line">public calss A&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss A&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用方法如下：<br><code>[链接名称](链接地址)</code><br>或者<br>&lt;链接地址&gt;</p><p>例如：<br>这是一个链接 <a href="https://www.baidu.com/">百度</a><br>或者<br><a href="https://www.baidu.com/">https://www.baidu.com</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：<br>使用方法：[][]<br>有点类似脚注，第二个[]中为网址变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[百度][1]</span><br><span class="line">[百度][百度]</span><br><span class="line">[1]: http://www.baidu.com/</span><br><span class="line">[百度]: http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>示例：<br>这个链接用 1 作为网址变量 <a href="http://www.baidu.com/">百度</a><br>这个链接用 百度 作为网址变量 <a href="http://www.baidu.com/">百度</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 图片语法格式如下：</p><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![测试](https://images.wallpaperscraft.com/image/single/starry_sky_boat_reflection_125803_1920x1080.jpg &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://images.wallpaperscraft.com/image/single/starry_sky_boat_reflection_125803_1920x1080.jpg" class="lazyload placeholder" data-srcset="https://images.wallpaperscraft.com/image/single/starry_sky_boat_reflection_125803_1920x1080.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="测试" title="可选标题"></p><p>地址不对：</p><p><img src="https://images.wallpaperscraft.com/" class="lazyload placeholder" data-srcset="https://images.wallpaperscraft.com/" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="测试" title="可选标题"></p><p>当然，也可以像网址那样对图片网址使用变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[示例][图片]</span><br><span class="line">[图片]: https://images.wallpaperscraft.com/image/single/starry_sky_boat_reflection_125803_1920x1080.jpg</span><br></pre></td></tr></table></figure><p>在文档的结尾为变量赋值（网址）</p><p><a href="https://images.wallpaperscraft.com/image/single/starry_sky_boat_reflection_125803_1920x1080.jpg">示例</a></p><p>Markdown 还没有办法指定图片的高度与宽度，如果需要的话，你可以使用普通的 &lt; img &gt; 标签。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头|表头|</span><br><span class="line">|-|-|</span><br><span class="line">|单元格|单元格|</span><br><span class="line">|单元格|单元格|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式</p><p>我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 |右对齐| 居中对齐 |</span><br><span class="line">| :-| -: | :-: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><p><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></p><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\ 反斜线</span><br><span class="line">` 反引号</span><br><span class="line">\* 星号</span><br><span class="line">_ 下划线</span><br><span class="line">&#123;&#125; 花括号</span><br><span class="line">\[\] 方括号</span><br><span class="line">() 小括号</span><br><span class="line">\# 井字号</span><br><span class="line">\+ 加号</span><br><span class="line">\- 减号</span><br><span class="line">. 英文句点</span><br><span class="line">! 感叹号</span><br></pre></td></tr></table></figure><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p><strong>Markdown Preview Enhanced</strong> 使用 <ins>KaTeX</ins> 或者 <ins>MathJax</ins> 来渲染数学表达式。KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。<br>你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。</p><p>默认下的分隔符：</p><p><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。<code>$$...$$</code> 或者 <code>\[...\]</code> 或者 <code> ```math</code> 中的数学表达式将会在块内显示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#直接写就行，不需要代码块</span><br><span class="line"></span><br><span class="line">$f(x)=2x+8$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">   a &amp; b \\</span><br><span class="line">   c &amp; d</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\begin&#123;CD&#125;</span><br><span class="line">   A @&gt;a&gt;&gt; B \\</span><br><span class="line">@VbVV @AAcA \\</span><br><span class="line">   C @= D</span><br><span class="line">\end&#123;CD&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：</p><p>$f(x)&#x3D;2x+8$</p><p>$$<br>\begin{Bmatrix}<br>   a &amp; b \<br>   c &amp; d<br>\end{Bmatrix}<br>$$<br>$$<br>\begin{CD}<br>   A @&gt;a&gt;&gt; B \<br>@VbVV @AAcA \<br>   C @&#x3D; D<br>\end{CD}<br>$$</p><p>几个实例效果图如下：</p><p>1、横向流程图源码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><p>2、竖向流程图源码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><p>3、标准流程图源码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>4、标准流程图源码格式（横向）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>5、UML时序图源码样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><p>6、UML时序图源码复杂样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><p>7、UML标准时序图样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><p>8、甘特图样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
